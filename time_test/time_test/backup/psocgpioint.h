/******************************************************************************
*  Generated by PSoC Designer 5.2.2551
******************************************************************************/
#include <m8c.h>
/*
*   PSoCGPIOINT.h
*   Data: 04 June, 2002
*   Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
*
*  This file is generated by the Device Editor on Application Generation.
*  It contains equates that are useful in writing code relating to GPIO
*  related values.
*  
*  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
*  Edits to this file will not be preserved.
*/
// hall_in address and mask defines
#pragma	ioport	hall_in_Data_ADDR:	0x4
BYTE			hall_in_Data_ADDR;
#pragma	ioport	hall_in_DriveMode_0_ADDR:	0x104
BYTE			hall_in_DriveMode_0_ADDR;
#pragma	ioport	hall_in_DriveMode_1_ADDR:	0x105
BYTE			hall_in_DriveMode_1_ADDR;
#pragma	ioport	hall_in_DriveMode_2_ADDR:	0x7
BYTE			hall_in_DriveMode_2_ADDR;
#pragma	ioport	hall_in_GlobalSelect_ADDR:	0x6
BYTE			hall_in_GlobalSelect_ADDR;
#pragma	ioport	hall_in_IntCtrl_0_ADDR:	0x106
BYTE			hall_in_IntCtrl_0_ADDR;
#pragma	ioport	hall_in_IntCtrl_1_ADDR:	0x107
BYTE			hall_in_IntCtrl_1_ADDR;
#pragma	ioport	hall_in_IntEn_ADDR:	0x5
BYTE			hall_in_IntEn_ADDR;
#define hall_in_MASK 0x40
// AnalogColumn_InputMUX_1 address and mask defines
#pragma	ioport	AnalogColumn_InputMUX_1_Data_ADDR:	0x0
BYTE			AnalogColumn_InputMUX_1_Data_ADDR;
#pragma	ioport	AnalogColumn_InputMUX_1_DriveMode_0_ADDR:	0x100
BYTE			AnalogColumn_InputMUX_1_DriveMode_0_ADDR;
#pragma	ioport	AnalogColumn_InputMUX_1_DriveMode_1_ADDR:	0x101
BYTE			AnalogColumn_InputMUX_1_DriveMode_1_ADDR;
#pragma	ioport	AnalogColumn_InputMUX_1_DriveMode_2_ADDR:	0x3
BYTE			AnalogColumn_InputMUX_1_DriveMode_2_ADDR;
#pragma	ioport	AnalogColumn_InputMUX_1_GlobalSelect_ADDR:	0x2
BYTE			AnalogColumn_InputMUX_1_GlobalSelect_ADDR;
#pragma	ioport	AnalogColumn_InputMUX_1_IntCtrl_0_ADDR:	0x102
BYTE			AnalogColumn_InputMUX_1_IntCtrl_0_ADDR;
#pragma	ioport	AnalogColumn_InputMUX_1_IntCtrl_1_ADDR:	0x103
BYTE			AnalogColumn_InputMUX_1_IntCtrl_1_ADDR;
#pragma	ioport	AnalogColumn_InputMUX_1_IntEn_ADDR:	0x1
BYTE			AnalogColumn_InputMUX_1_IntEn_ADDR;
#define AnalogColumn_InputMUX_1_MASK 0x1
// AnalogColumn_InputMUX_0 address and mask defines
#pragma	ioport	AnalogColumn_InputMUX_0_Data_ADDR:	0x0
BYTE			AnalogColumn_InputMUX_0_Data_ADDR;
#pragma	ioport	AnalogColumn_InputMUX_0_DriveMode_0_ADDR:	0x100
BYTE			AnalogColumn_InputMUX_0_DriveMode_0_ADDR;
#pragma	ioport	AnalogColumn_InputMUX_0_DriveMode_1_ADDR:	0x101
BYTE			AnalogColumn_InputMUX_0_DriveMode_1_ADDR;
#pragma	ioport	AnalogColumn_InputMUX_0_DriveMode_2_ADDR:	0x3
BYTE			AnalogColumn_InputMUX_0_DriveMode_2_ADDR;
#pragma	ioport	AnalogColumn_InputMUX_0_GlobalSelect_ADDR:	0x2
BYTE			AnalogColumn_InputMUX_0_GlobalSelect_ADDR;
#pragma	ioport	AnalogColumn_InputMUX_0_IntCtrl_0_ADDR:	0x102
BYTE			AnalogColumn_InputMUX_0_IntCtrl_0_ADDR;
#pragma	ioport	AnalogColumn_InputMUX_0_IntCtrl_1_ADDR:	0x103
BYTE			AnalogColumn_InputMUX_0_IntCtrl_1_ADDR;
#pragma	ioport	AnalogColumn_InputMUX_0_IntEn_ADDR:	0x1
BYTE			AnalogColumn_InputMUX_0_IntEn_ADDR;
#define AnalogColumn_InputMUX_0_MASK 0x2
// AnalogColumn_InputMUX_3 address and mask defines
#pragma	ioport	AnalogColumn_InputMUX_3_Data_ADDR:	0x0
BYTE			AnalogColumn_InputMUX_3_Data_ADDR;
#pragma	ioport	AnalogColumn_InputMUX_3_DriveMode_0_ADDR:	0x100
BYTE			AnalogColumn_InputMUX_3_DriveMode_0_ADDR;
#pragma	ioport	AnalogColumn_InputMUX_3_DriveMode_1_ADDR:	0x101
BYTE			AnalogColumn_InputMUX_3_DriveMode_1_ADDR;
#pragma	ioport	AnalogColumn_InputMUX_3_DriveMode_2_ADDR:	0x3
BYTE			AnalogColumn_InputMUX_3_DriveMode_2_ADDR;
#pragma	ioport	AnalogColumn_InputMUX_3_GlobalSelect_ADDR:	0x2
BYTE			AnalogColumn_InputMUX_3_GlobalSelect_ADDR;
#pragma	ioport	AnalogColumn_InputMUX_3_IntCtrl_0_ADDR:	0x102
BYTE			AnalogColumn_InputMUX_3_IntCtrl_0_ADDR;
#pragma	ioport	AnalogColumn_InputMUX_3_IntCtrl_1_ADDR:	0x103
BYTE			AnalogColumn_InputMUX_3_IntCtrl_1_ADDR;
#pragma	ioport	AnalogColumn_InputMUX_3_IntEn_ADDR:	0x1
BYTE			AnalogColumn_InputMUX_3_IntEn_ADDR;
#define AnalogColumn_InputMUX_3_MASK 0x4
// d2 address and mask defines
#pragma	ioport	d2_Data_ADDR:	0x4
BYTE			d2_Data_ADDR;
#pragma	ioport	d2_DriveMode_0_ADDR:	0x104
BYTE			d2_DriveMode_0_ADDR;
#pragma	ioport	d2_DriveMode_1_ADDR:	0x105
BYTE			d2_DriveMode_1_ADDR;
#pragma	ioport	d2_DriveMode_2_ADDR:	0x7
BYTE			d2_DriveMode_2_ADDR;
#pragma	ioport	d2_GlobalSelect_ADDR:	0x6
BYTE			d2_GlobalSelect_ADDR;
#pragma	ioport	d2_IntCtrl_0_ADDR:	0x106
BYTE			d2_IntCtrl_0_ADDR;
#pragma	ioport	d2_IntCtrl_1_ADDR:	0x107
BYTE			d2_IntCtrl_1_ADDR;
#pragma	ioport	d2_IntEn_ADDR:	0x5
BYTE			d2_IntEn_ADDR;
#define d2_MASK 0x4
// d1 address and mask defines
#pragma	ioport	d1_Data_ADDR:	0x4
BYTE			d1_Data_ADDR;
#pragma	ioport	d1_DriveMode_0_ADDR:	0x104
BYTE			d1_DriveMode_0_ADDR;
#pragma	ioport	d1_DriveMode_1_ADDR:	0x105
BYTE			d1_DriveMode_1_ADDR;
#pragma	ioport	d1_DriveMode_2_ADDR:	0x7
BYTE			d1_DriveMode_2_ADDR;
#pragma	ioport	d1_GlobalSelect_ADDR:	0x6
BYTE			d1_GlobalSelect_ADDR;
#pragma	ioport	d1_IntCtrl_0_ADDR:	0x106
BYTE			d1_IntCtrl_0_ADDR;
#pragma	ioport	d1_IntCtrl_1_ADDR:	0x107
BYTE			d1_IntCtrl_1_ADDR;
#pragma	ioport	d1_IntEn_ADDR:	0x5
BYTE			d1_IntEn_ADDR;
#define d1_MASK 0x10
// p2_0 address and mask defines
#pragma	ioport	p2_0_Data_ADDR:	0x8
BYTE			p2_0_Data_ADDR;
#pragma	ioport	p2_0_DriveMode_0_ADDR:	0x108
BYTE			p2_0_DriveMode_0_ADDR;
#pragma	ioport	p2_0_DriveMode_1_ADDR:	0x109
BYTE			p2_0_DriveMode_1_ADDR;
#pragma	ioport	p2_0_DriveMode_2_ADDR:	0xb
BYTE			p2_0_DriveMode_2_ADDR;
#pragma	ioport	p2_0_GlobalSelect_ADDR:	0xa
BYTE			p2_0_GlobalSelect_ADDR;
#pragma	ioport	p2_0_IntCtrl_0_ADDR:	0x10a
BYTE			p2_0_IntCtrl_0_ADDR;
#pragma	ioport	p2_0_IntCtrl_1_ADDR:	0x10b
BYTE			p2_0_IntCtrl_1_ADDR;
#pragma	ioport	p2_0_IntEn_ADDR:	0x9
BYTE			p2_0_IntEn_ADDR;
#define p2_0_MASK 0x1
