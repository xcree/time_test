FILE: .\boot.asm                        (0001) ;  Generated by PSoC Designer 5.2.2551
                                        (0002) ;
                                        (0003) ;@Id: boot.tpl#895 @
                                        (0004) ;=============================================================================
                                        (0005) ;  FILENAME:   boot.asm
                                        (0006) ;  Version:    4.18
                                        (0007) ;
                                        (0008) ;  DESCRIPTION:
                                        (0009) ;  M8C Boot Code for CY8C29xxx microcontroller family.
                                        (0010) ;
                                        (0011) ;  Copyright (c) Cypress Semiconductor 2009. All Rights Reserved.
                                        (0012) ;
                                        (0013) ; NOTES:
                                        (0014) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
                                        (0015) ; the project's root directory to create BOOT.ASM. Any changes made to
                                        (0016) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                        (0017) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                        (0018) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
                                        (0019) ; are not accidentally modified.
                                        (0020) ;
                                        (0021) ;=============================================================================
                                        (0022) 
                                        (0023) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
                                        (0024) include "m8c.inc"			;Part specific file
                                        (0025) include "m8ssc.inc"			;Part specific file
                                        (0026) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
                                        (0027) 
                                        (0028) ;--------------------------------------
                                        (0029) ; Export Declarations
                                        (0030) ;--------------------------------------
                                        (0031) 
                                        (0032) export __Start
                                        (0033) IF	(TOOLCHAIN & HITECH)
                                        (0034) ELSE
                                        (0035) export __bss_start
                                        (0036) export __data_start
                                        (0037) export __idata_start
                                        (0038) export __func_lit_start
                                        (0039) export __text_start
                                        (0040) ENDIF
                                        (0041) export  _bGetPowerSetting
                                        (0042) export   bGetPowerSetting
                                        (0043) 
                                        (0044) 
                                        (0045) ;--------------------------------------
                                        (0046) ; Optimization flags
                                        (0047) ;--------------------------------------
                                        (0048) ;
                                        (0049) ; To change the value of these flags, modify the file boot.tpl, not
                                        (0050) ; boot.asm. See the notes in the banner comment at the beginning of
                                        (0051) ; this file.
                                        (0052) 
                                        (0053) ; Optimization for Assembly language (only) projects and C-language projects
                                        (0054) ; that do not depend on the C compiler to initialize the values of RAM variables.
                                        (0055) ;   Set to 1: Support for C Run-time Environment initialization
                                        (0056) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                        (0057) ;
                                        (0058) IF	(TOOLCHAIN & HITECH)
                                        (0059) ; The C compiler will customize the startup code - it's not required here
                                        (0060) 
                                        (0061) C_LANGUAGE_SUPPORT:              equ 0
                                        (0062) ELSE
                                        (0063) C_LANGUAGE_SUPPORT:              equ 1
                                        (0064) ENDIF
                                        (0065) 
                                        (0066) 
                                        (0067) ; The following equate is required for proper operation. Reseting its value
                                        (0068) ; is discouraged.  WAIT_FOR_32K is effective only if the crystal oscillator is
                                        (0069) ; selected.  If the designer chooses to not wait then stabilization of the ECO
                                        (0070) ; and PLL_Lock must take place within user code. See the family data sheet for
                                        (0071) ; the requirements of starting the ECO and PLL lock mode.
                                        (0072) ;
                                        (0073) ;   Set to 1: Wait for XTAL (& PLL if selected) to stabilize before
                                        (0074) ;                invoking main
                                        (0075) ;   Set to 0: Boot code does not wait; clock may not have stabilized by
                                        (0076) ;               the time code in main starts executing.
                                        (0077) ;
                                        (0078) WAIT_FOR_32K:                    equ 1
                                        (0079) 
                                        (0080) 
                                        (0081) ; For historical reasons, by default the boot code uses an lcall instruction
                                        (0082) ; to invoke the user's _main code. If _main executes a return instruction,
                                        (0083) ; boot provides an infinite loop. By changing the following equate from zero
                                        (0084) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                        (0085) ; bytes on the stack which are otherwise required for the return address. If
                                        (0086) ; this option is enabled, _main must not return. (Beginning with the 4.2
                                        (0087) ; release, the C compiler automatically places an infinite loop at the end
                                        (0088) ; of main, rather than a return instruction.)
                                        (0089) ;
                                        (0090) ENABLE_LJMP_TO_MAIN:             equ 0
                                        (0091) 
                                        (0092) 
                                        (0093) ;-----------------------------------------------------------------------------
                                        (0094) ; Interrupt Vector Table
                                        (0095) ;-----------------------------------------------------------------------------
                                        (0096) ;
                                        (0097) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                        (0098) ; a jump instruction to an ISR (Interrupt Service Routine), although
                                        (0099) ; very short ISRs could be encoded within the table itself. Normally,
                                        (0100) ; vector jump targets are modified automatically according to the user
                                        (0101) ; modules selected. This occurs when the 'Generate Application' opera-
                                        (0102) ; tion is run causing PSoC Designer to create boot.asm and the other
                                        (0103) ; configuration files. If you need to hard code a vector, update the
                                        (0104) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                        (0105) ; of this file.
                                        (0106) ;-----------------------------------------------------------------------------
                                        (0107) 
                                        (0108)     AREA TOP (ROM, ABS, CON)
                                        (0109) 
                                        (0110)     org   0                        ;Reset Interrupt Vector
                                        (0111) IF	(TOOLCHAIN & HITECH)
                                        (0112) ;   jmp   __Start                  ;C compiler fills in this vector
                                        (0113) ELSE
0000: 80 67    JMP   0x0068             (0114)     jmp   __Start                  ;First instruction executed following a Reset
                                        (0115) ENDIF
                                        (0116) 
                                        (0117)     org   04h                      ;Low Voltage Detect (LVD) Interrupt Vector
0004: 30       HALT                     (0118)     halt                           ;Stop execution if power falls too low
                                        (0119) 
                                        (0120)     org   08h                      ;Analog Column 0 Interrupt Vector
                                        (0121)     // call	void_handler
0008: 7E       RETI                     (0122)     reti
                                        (0123) 
                                        (0124)     org   0Ch                      ;Analog Column 1 Interrupt Vector
                                        (0125)     // call	void_handler
000C: 7E       RETI                     (0126)     reti
                                        (0127) 
                                        (0128)     org   10h                      ;Analog Column 2 Interrupt Vector
                                        (0129)     // call	void_handler
0010: 7E       RETI                     (0130)     reti
                                        (0131) 
                                        (0132)     org   14h                      ;Analog Column 3 Interrupt Vector
                                        (0133)     // call	void_handler
0014: 7E       RETI                     (0134)     reti
                                        (0135) 
                                        (0136)     org   18h                      ;VC3 Interrupt Vector
                                        (0137)     // call	void_handler
0018: 7E       RETI                     (0138)     reti
                                        (0139) 
                                        (0140)     org   1Ch                      ;GPIO Interrupt Vector
001C: 7D 12 24 LJMP  PSoC_GPIO_ISR      (0141)     ljmp	PSoC_GPIO_ISR
001F: 7E       RETI                     (0142)     reti
                                        (0143) 
                                        (0144)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
                                        (0145)     // call	void_handler
0020: 7E       RETI                     (0146)     reti
                                        (0147) 
                                        (0148)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
0024: 7D 08 1C LJMP  _PWM16_1_ISR       (0149)     ljmp	_PWM16_1_ISR
0027: 7E       RETI                     (0150)     reti
                                        (0151) 
                                        (0152)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
                                        (0153)     // call	void_handler
0028: 7E       RETI                     (0154)     reti
                                        (0155) 
                                        (0156)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
002C: 7D 07 2B LJMP  _Timer16_1_ISR     (0157)     ljmp	_Timer16_1_ISR
002F: 7E       RETI                     (0158)     reti
                                        (0159) 
                                        (0160)     org   30h                      ;PSoC Block DBB10 Interrupt Vector
0030: 7D 07 D5 LJMP  _PWM8_1_ISR        (0161)     ljmp	_PWM8_1_ISR
0033: 7E       RETI                     (0162)     reti
                                        (0163) 
                                        (0164)     org   34h                      ;PSoC Block DBB11 Interrupt Vector
                                        (0165)     // call	void_handler
0034: 7E       RETI                     (0166)     reti
                                        (0167) 
                                        (0168)     org   38h                      ;PSoC Block DCB12 Interrupt Vector
                                        (0169)     // call	void_handler
0038: 7E       RETI                     (0170)     reti
                                        (0171) 
                                        (0172)     org   3Ch                      ;PSoC Block DCB13 Interrupt Vector
003C: 7D 08 ED LJMP  _ADCINC_1_ADConversion_ISR(0173)     ljmp	_ADCINC_1_ADConversion_ISR
003F: 7E       RETI                     (0174)     reti
                                        (0175) 
                                        (0176)     org   40h                      ;PSoC Block DBB20 Interrupt Vector
0040: 7D 08 BC LJMP  _DigBuf_1_ISR      (0177)     ljmp	_DigBuf_1_ISR
0043: 7E       RETI                     (0178)     reti
                                        (0179) 
                                        (0180)     org   44h                      ;PSoC Block DBB21 Interrupt Vector
                                        (0181)     // call	void_handler
0044: 7E       RETI                     (0182)     reti
                                        (0183) 
                                        (0184)     org   48h                      ;PSoC Block DCB22 Interrupt Vector
                                        (0185)     // call	void_handler
0048: 7E       RETI                     (0186)     reti
                                        (0187) 
                                        (0188)     org   4Ch                      ;PSoC Block DCB23 Interrupt Vector
004C: 7D 05 F2 LJMP  _TX8_1_ISR         (0189)     ljmp	_TX8_1_ISR
004F: 7E       RETI                     (0190)     reti
                                        (0191) 
                                        (0192)     org   50h                      ;PSoC Block DBB30 Interrupt Vector
                                        (0193)     // call	void_handler
0050: 7E       RETI                     (0194)     reti
                                        (0195) 
                                        (0196)     org   54h                      ;PSoC Block DBB31 Interrupt Vector
                                        (0197)     // call	void_handler
0054: 7E       RETI                     (0198)     reti
                                        (0199) 
                                        (0200)     org   58h                      ;PSoC Block DCB32 Interrupt Vector
                                        (0201)     // call	void_handler
0058: 7E       RETI                     (0202)     reti
                                        (0203) 
                                        (0204)     org   5Ch                      ;PSoC Block DCB33 Interrupt Vector
                                        (0205)     // call	void_handler
005C: 7E       RETI                     (0206)     reti
                                        (0207) 
                                        (0208)     org   60h                      ;PSoC I2C Interrupt Vector
                                        (0209)     // call	void_handler
0060: 7E       RETI                     (0210)     reti
                                        (0211) 
                                        (0212)     org   64h                      ;Sleep Timer Interrupt Vector
                                        (0213)     // call	void_handler
0064: 7E       RETI                     (0214)     reti
0068: 71 10    OR    F,0x10             
                                        (0215) 
                                        (0216) ;-----------------------------------------------------------------------------
                                        (0217) ;  Start of Execution.
                                        (0218) ;-----------------------------------------------------------------------------
                                        (0219) ;  The Supervisory ROM SWBootReset function has already completed the
                                        (0220) ;  calibrate1 process, loading trim values for 5 volt operation.
                                        (0221) ;
                                        (0222) 
                                        (0223) IF	(TOOLCHAIN & HITECH)
                                        (0224)  	AREA PD_startup(CODE, REL, CON)
                                        (0225) ELSE
                                        (0226)     org 68h
                                        (0227) ENDIF
                                        (0228) __Start:
                                        (0229) 
                                        (0230)     ; initialize SMP values for voltage stabilization, if required,
                                        (0231)     ; leaving power-on reset (POR) level at the default (low) level, at
                                        (0232)     ; least for now. 
                                        (0233)     ;
                                        (0234)     M8C_SetBank1
006A: 62 FA 00 MOV   REG[0xFA],0x0      (0235)     mov reg[0FAh], 0				;Reset flash location
006D: 62 E3 87 MOV   REG[0xE3],0x87     (0236)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
0070: 70 EF    AND   F,0xEF             
                                        (0237)     M8C_SetBank0
                                        (0238) 
                                        (0239)     ; %53%20%46%46% Apply Erratum 001-05137 workaround
0072: 50 20    MOV   A,0x20             (0240)     mov   A, 20h
0074: 28       ROMX                     (0241)     romx
0075: 50 40    MOV   A,0x40             (0242)     mov   A, 40h
0077: 28       ROMX                     (0243)     romx
0078: 50 60    MOV   A,0x60             (0244)     mov   A, 60h
007A: 28       ROMX                     (0245)     romx
                                        (0246)     ; %45%20%46%46% End workaround
                                        (0247) 
                                        (0248) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                        (0249)     M8C_EnableWatchDog
                                        (0250) ENDIF
                                        (0251) 
                                        (0252) IF ( SELECT_32K )
                                        (0253)     or   reg[CPU_SCR1],  CPU_SCR1_ECO_ALLOWED  ; ECO will be used in this project
                                        (0254) ELSE
007B: 41 FE FB AND   REG[0xFE],0xFB     (0255)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                        (0256) ENDIF
                                        (0257) 
                                        (0258)     ;---------------------------
                                        (0259)     ; Set up the Temporary stack
                                        (0260)     ;---------------------------
                                        (0261)     ; A temporary stack is set up for the SSC instructions.
                                        (0262)     ; The real stack start will be assigned later.
                                        (0263)     ;
                                        (0264) _stack_start:          equ 80h
007E: 50 80    MOV   A,0x80             (0265)     mov   A, _stack_start          ; Set top of stack to end of used RAM
0080: 4E       SWAP  SP,A               (0266)     swap  SP, A                    ; This is only temporary if going to LMM
                                        (0267) 
                                        (0268)     ;-----------------------------------------------
                                        (0269)     ; Set Power-related Trim & the AGND Bypass bit.
                                        (0270)     ;-----------------------------------------------
                                        (0271) 
                                        (0272) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
                                        (0273)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0274)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0275)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_5V_6MHZ, 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                        (0276)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                        (0277)   IF ( AGND_BYPASS )
                                        (0278)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0279)     ; The 5V trim has already been set, but we need to update the AGNDBYP
                                        (0280)     ; bit in the write-only BDG_TR register. Recalculate the register
                                        (0281)     ; value using the proper trim values.
                                        (0282)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0283)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                        (0284)   ENDIF
                                        (0285)  ENDIF
                                        (0286) ENDIF ; 5.0 V Operation
                                        (0287) 
                                        (0288) IF ( POWER_SETTING & POWER_SET_3V3)            ; *** 3.3 Volt operation   ***
                                        (0289)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0290)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0291)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_3V_6MHZ, 1, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                        (0292)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                        (0293)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                        (0294)  ENDIF
                                        (0295) ENDIF ; 3.3 Volt Operation
                                        (0296) 
0081: 55 F8 00 MOV   [vout+28],0x0      (0297)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
0084: 55 F9 00 MOV   [vout+29],0x0      (0298)     mov  [bSSC_KEYSP], 0
0087: 71 10    OR    F,0x10             
                                        (0299) 
                                        (0300)     ;---------------------------------------
                                        (0301)     ; Initialize Crystal Oscillator and PLL
                                        (0302)     ;---------------------------------------
                                        (0303) 
                                        (0304) IF ( SELECT_32K & WAIT_FOR_32K )
                                        (0305)     ; If the user has requested the External Crystal Oscillator (ECO) then turn it
                                        (0306)     ; on and wait for it to stabilize and the system to switch over to it. The PLL
                                        (0307)     ; is left off. Set the SleepTimer period is set to 1 sec to time the wait for
                                        (0308)     ; the ECO to stabilize.
                                        (0309)     ;
                                        (0310)     M8C_SetBank1
                                        (0311)     mov   reg[OSC_CR0], (SELECT_32K_JUST | OSC_CR0_SLEEP_1Hz | OSC_CR0_CPU_12MHz)
                                        (0312)     M8C_SetBank0
                                        (0313)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get a full second
                                        (0314)     or    reg[INT_MSK0], INT_MSK0_SLEEP   ; Enable latching of SleepTimer interrupt
                                        (0315)     mov   reg[INT_VC],   0                ; Clear all pending interrupts
                                        (0316) .WaitFor1s:
                                        (0317)     tst   reg[INT_CLR0], INT_MSK0_SLEEP   ; Test the SleepTimer Interrupt Status
                                        (0318)     jz   .WaitFor1s                       ; Interrupt will latch but will not dispatch
                                        (0319)                                           ;   since interrupts are not globally enabled
                                        (0320) ELSE ; !( SELECT_32K & WAIT_FOR_32K )
                                        (0321)     ; Either no ECO, or waiting for stable clock is to be done in main
                                        (0322)     M8C_SetBank1
0089: 62 E0 02 MOV   REG[0xE0],0x2      (0323)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
008C: 70 EF    AND   F,0xEF             
008E: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0324)     M8C_SetBank0
                                        (0325)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                        (0326) 
                                        (0327) ENDIF ;( SELECT_32K & WAIT_FOR_32K )
                                        (0328) 
                                        (0329) IF ( PLL_MODE )
                                        (0330)     ; Crystal is now fully operational (assuming WAIT_FOR_32K was enabled).
                                        (0331)     ; Now start up PLL if selected, and wait 16 msec for it to stabilize.
                                        (0332)     ;
                                        (0333)     M8C_SetBank1
                                        (0334)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_3MHz)
                                        (0335)     M8C_SetBank0
                                        (0336)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get full period
                                        (0337)     mov   reg[INT_VC], 0                  ; Clear all pending interrupts
                                        (0338) 
                                        (0339) .WaitFor16ms:
                                        (0340)     tst   reg[INT_CLR0],INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                        (0341)     jz   .WaitFor16ms
                                        (0342)     M8C_SetBank1                          ; continue boot at CPU Speed of SYSCLK/2
                                        (0343)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_12MHz)
                                        (0344)     M8C_SetBank0
                                        (0345) 
                                        (0346) IF      ( WAIT_FOR_32K )
                                        (0347) ELSE ; !( WAIT_FOR_32K )
                                        (0348)     ; Option settings (PLL-Yes, ECO-No) are incompatible - force a syntax error
                                        (0349)     ERROR_PSoC Disabling WAIT_FOR_32K requires that the PLL_Lock must be enabled in user code.
                                        (0350) ENDIF ;(WAIT_FOR_32K)
                                        (0351) ENDIF ;(PLL_MODE)
                                        (0352) 
                                        (0353)     ;------------------------
                                        (0354)     ; Close CT leakage path.
                                        (0355)     ;------------------------
0091: 62 71 05 MOV   REG[0x71],0x5      (0356)     mov   reg[ACB00CR0], 05h
0094: 62 75 05 MOV   REG[0x75],0x5      (0357)     mov   reg[ACB01CR0], 05h
0097: 62 79 05 MOV   REG[0x79],0x5      (0358)     mov   reg[ACB02CR0], 05h
009A: 62 7D 05 MOV   REG[0x7D],0x5      (0359)     mov   reg[ACB03CR0], 05h
009D: 62 D1 07 MOV   REG[0xD1],0x7      
                                        (0360) 
                                        (0361) 
                                        (0362) IF	(TOOLCHAIN & HITECH)
                                        (0363)     ;---------------------------------------------
                                        (0364)     ; HI-TECH initialization: Enter the Large Memory Model, if applicable
                                        (0365)     ;---------------------------------------------
                                        (0366) 	global		__Lstackps
                                        (0367) 	mov     a,low __Lstackps
                                        (0368) 	swap    a,sp
                                        (0369) 
                                        (0370) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0371)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                        (0372)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0373)     RAM_SETPAGE_CUR 0
                                        (0374)     RAM_SETPAGE_MVW 0
                                        (0375)     RAM_SETPAGE_MVR 0
                                        (0376)     IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                        (0377)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0378)     ELSE
                                        (0379)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0380)     ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0381) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0382) ELSE
                                        (0383)     ;---------------------------------------------
                                        (0384)     ; ImageCraft Enter the Large Memory Model, if applicable
                                        (0385)     ;---------------------------------------------
                                        (0386) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0387)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
00A0: 50 00    MOV   A,0x0              (0388)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
00A2: 4E       SWAP  SP,A               (0389)     swap  A, SP
00A3: 62 D3 07 MOV   REG[0xD3],0x7      
00A6: 62 D0 00 MOV   REG[0xD0],0x0      
00A9: 62 D5 00 MOV   REG[0xD5],0x0      
00AC: 62 D4 00 MOV   REG[0xD4],0x0      
                                        (0390)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0391)     RAM_SETPAGE_CUR 0
                                        (0392)     RAM_SETPAGE_MVW 0
                                        (0393)     RAM_SETPAGE_MVR 0
                                        (0394) 
                                        (0395)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
00AF: 71 C0    OR    F,0xC0             (0396)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0397)   ELSE
                                        (0398)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0399)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0400) ELSE
                                        (0401)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
                                        (0402)     swap  SP, A
                                        (0403) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0404) ENDIF ;	TOOLCHAIN
                                        (0405) 
                                        (0406)     ;-------------------------
                                        (0407)     ; Load Base Configuration
                                        (0408)     ;-------------------------
                                        (0409)     ; Load global parameter settings and load the user modules in the
                                        (0410)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                        (0411)     ; to minimize start up time; (2) We may still need to play with the
                                        (0412)     ; Sleep Timer.
                                        (0413)     ;
00B1: 7C 05 90 LCALL 0x0590             (0414)     lcall LoadConfigInit
                                        (0415) 
                                        (0416)     ;-----------------------------------
                                        (0417)     ; Initialize C Run-Time Environment
                                        (0418)     ;-----------------------------------
                                        (0419) IF ( C_LANGUAGE_SUPPORT )
                                        (0420) IF ( SYSTEM_SMALL_MEMORY_MODEL )
                                        (0421)     mov  A,0                           ; clear the 'bss' segment to zero
                                        (0422)     mov  [__r0],<__bss_start
                                        (0423) BssLoop:
                                        (0424)     cmp  [__r0],<__bss_end
                                        (0425)     jz   BssDone
                                        (0426)     mvi  [__r0],A
                                        (0427)     jmp  BssLoop
                                        (0428) BssDone:
                                        (0429)     mov  A,>__idata_start              ; copy idata to data segment
                                        (0430)     mov  X,<__idata_start
                                        (0431)     mov  [__r0],<__data_start
                                        (0432) IDataLoop:
                                        (0433)     cmp  [__r0],<__data_end
                                        (0434)     jz   C_RTE_Done
                                        (0435)     push A
                                        (0436)     romx
                                        (0437)     mvi  [__r0],A
                                        (0438)     pop  A
                                        (0439)     inc  X
                                        (0440)     adc  A,0
                                        (0441)     jmp  IDataLoop
                                        (0442) 
                                        (0443) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                        (0444) 
                                        (0445) IF ( SYSTEM_LARGE_MEMORY_MODEL )
00B4: 62 D0 00 MOV   REG[0xD0],0x0      (0446)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                        (0447)                                        ; to use the Virtual Register page.
                                        (0448) 
                                        (0449)     ; Dereference the constant (flash) pointer pXIData to access the start
                                        (0450)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                        (0451)     ; text segment and may have been relocated by the Code Compressor.
                                        (0452)     ;
00B7: 50 04    MOV   A,0x4              (0453)     mov   A, >__pXIData                ; Get the address of the flash
00B9: 57 49    MOV   X,0x49             (0454)     mov   X, <__pXIData                ;   pointer to the xidata area.
00BB: 08       PUSH  A                  (0455)     push  A
00BC: 28       ROMX                     (0456)     romx                               ; get the MSB of xidata's address
00BD: 53 8D    MOV   [__r0],A           (0457)     mov   [__r0], A
00BF: 18       POP   A                  (0458)     pop   A
00C0: 75       INC   X                  (0459)     inc   X
00C1: 09 00    ADC   A,0x0              (0460)     adc   A, 0
00C3: 28       ROMX                     (0461)     romx                               ; get the LSB of xidata's address
00C4: 4B       SWAP  A,X                (0462)     swap  A, X
00C5: 51 8D    MOV   A,[__r0]           (0463)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                        (0464)                                        ;   XIData structure list in flash
00C7: 80 04    JMP   0x00CC             (0465)     jmp   .AccessStruct
                                        (0466) 
                                        (0467)     ; Unpack one element in the xidata "structure list" that specifies the
                                        (0468)     ; values of C variables. Each structure contains 3 member elements.
                                        (0469)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                        (0470)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                        (0471)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                        (0472)     ; contains 0xFF. There are two formats for the struct depending on the
                                        (0473)     ; value in the second member element, an unsigned byte:
                                        (0474)     ; (1) If the value of the second element is non-zero, it represents
                                        (0475)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                        (0476)     ; third member of the struct is an array of bytes of length 'size' and
                                        (0477)     ; the bytes are copied to the block of RAM.
                                        (0478)     ; (2) If the value of the second element is zero, the block of RAM is
                                        (0479)     ; to be cleared to zero. In this case, the third member of the struct
                                        (0480)     ; is an unsigned byte containing the number of bytes to clear.
                                        (0481) 
                                        (0482) .AccessNextStructLoop:
00C9: 75       INC   X                  (0483)     inc   X                            ; pXIData++
00CA: 09 00    ADC   A,0x0              (0484)     adc   A, 0
00CC: 62 E3 00 MOV   REG[0xE3],0x0      
                                        (0485) .AccessStruct:                         ; Entry point for first block
                                        (0486)     ;
                                        (0487)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                        (0488)     ;
                                        (0489)     M8C_ClearWDT                       ; Clear the watchdog for long inits
00CF: 08       PUSH  A                  (0490)     push  A
00D0: 28       ROMX                     (0491)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
00D1: 60 D5    MOV   REG[0xD5],A        (0492)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
00D3: 74       INC   A                  (0493)     inc   A                            ; End of Struct List? (MSB==0xFF?)
00D4: A0 4B    JZ    0x0120             (0494)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
00D6: 18       POP   A                  (0495)     pop   A                            ; restore pXIData to [A,X]
00D7: 75       INC   X                  (0496)     inc   X                            ; pXIData++
00D8: 09 00    ADC   A,0x0              (0497)     adc   A, 0
00DA: 08       PUSH  A                  (0498)     push  A
00DB: 28       ROMX                     (0499)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
00DC: 53 8D    MOV   [__r0],A           (0500)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
00DE: 18       POP   A                  (0501)     pop   A                            ; restore pXIData to [A,X]
00DF: 75       INC   X                  (0502)     inc   X                            ; pXIData++ (point to size)
00E0: 09 00    ADC   A,0x0              (0503)     adc   A, 0
00E2: 08       PUSH  A                  (0504)     push  A
00E3: 28       ROMX                     (0505)     romx                               ; Get the size (CPU.A <- *pXIData)
00E4: A0 1C    JZ    0x0101             (0506)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
00E6: 53 8C    MOV   [__r1],A           (0507)     mov   [__r1], A                    ;             else downcount in __r1
00E8: 18       POP   A                  (0508)     pop   A                            ; restore pXIData to [A,X]
                                        (0509) 
                                        (0510) .CopyNextByteLoop:
                                        (0511)     ; For each byte in the structure's array member, copy from flash to RAM.
                                        (0512)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
                                        (0513)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
                                        (0514)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0515)     ;
00E9: 75       INC   X                  (0516)     inc   X                            ; pXIData++ (point to next data byte)
00EA: 09 00    ADC   A,0x0              (0517)     adc   A, 0
00EC: 08       PUSH  A                  (0518)     push  A
00ED: 28       ROMX                     (0519)     romx                               ; Get the data value (CPU.A <- *pXIData)
00EE: 3F 8D    MVI   [__r0],A           (0520)     mvi   [__r0], A                    ; Transfer the data to RAM
00F0: 47 8D FF TST   [__r0],0xFF        (0521)     tst   [__r0], 0xff                 ; Check for page crossing
00F3: B0 06    JNZ   0x00FA             (0522)     jnz   .CopyLoopTail                ;   No crossing, keep going
00F5: 5D D5    MOV   A,REG[0xD5]        (0523)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
00F7: 74       INC   A                  (0524)     inc   A
00F8: 60 D5    MOV   REG[0xD5],A        (0525)     mov   reg[ MVW_PP], A
                                        (0526) .CopyLoopTail:
00FA: 18       POP   A                  (0527)     pop   A                            ; restore pXIData to [A,X]
00FB: 7A 8C    DEC   [__r1]             (0528)     dec   [__r1]                       ; End of this array in flash?
00FD: BF EB    JNZ   0x00E9             (0529)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
00FF: 8F C9    JMP   0x00C9             (0530)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
                                        (0531) 
                                        (0532) .ClearRAMBlockToZero:
0101: 18       POP   A                  (0533)     pop   A                            ; restore pXIData to [A,X]
0102: 75       INC   X                  (0534)     inc   X                            ; pXIData++ (point to next data byte)
0103: 09 00    ADC   A,0x0              (0535)     adc   A, 0
0105: 08       PUSH  A                  (0536)     push  A
0106: 28       ROMX                     (0537)     romx                               ; Get the run length (CPU.A <- *pXIData)
0107: 53 8C    MOV   [__r1],A           (0538)     mov   [__r1], A                    ; Initialize downcounter
0109: 50 00    MOV   A,0x0              (0539)     mov   A, 0                         ; Initialize source data
                                        (0540) 
                                        (0541) .ClearRAMBlockLoop:
                                        (0542)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
                                        (0543)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0544)     ;
010B: 3F 8D    MVI   [__r0],A           (0545)     mvi   [__r0], A                    ; Clear a byte
010D: 47 8D FF TST   [__r0],0xFF        (0546)     tst   [__r0], 0xff                 ; Check for page crossing
0110: B0 08    JNZ   0x0119             (0547)     jnz   .ClearLoopTail               ;   No crossing, keep going
0112: 5D D5    MOV   A,REG[0xD5]        (0548)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
0114: 74       INC   A                  (0549)     inc   A
0115: 60 D5    MOV   REG[0xD5],A        (0550)     mov   reg[ MVW_PP], A
0117: 50 00    MOV   A,0x0              (0551)     mov   A, 0                         ; Restore the zero used for clearing
                                        (0552) .ClearLoopTail:
0119: 7A 8C    DEC   [__r1]             (0553)     dec   [__r1]                       ; Was this the last byte?
011B: BF EF    JNZ   0x010B             (0554)     jnz   .ClearRAMBlockLoop           ;   No,  continue
011D: 18       POP   A                  (0555)     pop   A                            ;   Yes, restore pXIData to [A,X] and
011E: 8F AA    JMP   0x00C9             (0556)     jmp   .AccessNextStructLoop        ;        initialize another RAM block
                                        (0557) 
                                        (0558) .C_RTE_WrapUp:
0120: 18       POP   A                  (0559)     pop   A                            ; balance stack
0121: 71 10    OR    F,0x10             
                                        (0560) 
                                        (0561) ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                                        (0562) 
                                        (0563) C_RTE_Done:
                                        (0564) 
                                        (0565) ENDIF ; C_LANGUAGE_SUPPORT
                                        (0566) 
                                        (0567)     ;-------------------------------
                                        (0568)     ; Voltage Stabilization for SMP
                                        (0569)     ;-------------------------------
                                        (0570) 
                                        (0571) IF ( POWER_SETTING & POWER_SET_5V0)    ; 5.0V Operation
                                        (0572) IF ( SWITCH_MODE_PUMP ^ 1 )            ; SMP is operational
                                        (0573)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0574)     ; When using the SMP at 5V, we must wait for Vdd to slew from 3.1V to
                                        (0575)     ; 5V before enabling the Precision Power-On Reset (PPOR).
                                        (0576)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0577)     or   reg[INT_MSK0],INT_MSK0_SLEEP
                                        (0578)     M8C_SetBank1
                                        (0579)     and   reg[OSC_CR0], ~OSC_CR0_SLEEP
                                        (0580)     or    reg[OSC_CR0],  OSC_CR0_SLEEP_512Hz
                                        (0581)     M8C_SetBank0
                                        (0582)     M8C_ClearWDTAndSleep                   ; Restart the sleep timer
                                        (0583)     mov   reg[INT_VC], 0                   ; Clear all pending interrupts
                                        (0584) .WaitFor2ms:
                                        (0585)     tst   reg[INT_CLR0], INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                        (0586)     jz   .WaitFor2ms                       ; Branch fails when 2 msec has passed
                                        (0587) ENDIF ; SMP is operational
                                        (0588) ENDIF ; 5.0V Operation
                                        (0589) 
                                        (0590)     ;-------------------------------
                                        (0591)     ; Set Power-On Reset (POR) Level
                                        (0592)     ;-------------------------------
                                        (0593) 
                                        (0594)     ;  The writes to the VLT_CR register below include setting the POR to VLT_CR_POR_HIGH,
                                        (0595)     ;  VLT_CR_POR_MID or VLT_CR_POR_LOW. Correctly setting this value is critical to the proper
                                        (0596)     ;  operation of the PSoC. The POR protects the M8C from mis-executing when Vdd falls low. These
                                        (0597)     ;  values should not be changed from the settings here. Failure to follow this instruction could 
                                        (0598)     ;  lead to corruption of PSoC flash.
                                        (0599) 
                                        (0600)     M8C_SetBank1
                                        (0601) 
                                        (0602) IF (POWER_SETTING & POWER_SET_5V0)          ; 5.0V Operation?
                                        (0603)  IF (POWER_SETTING & POWER_SET_SLOW_IMO)    ; and Slow Mode?
                                        (0604)  ELSE                                       ;    No, fast mode
                                        (0605)   IF ( CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz ) ;    As fast as 24MHz?
                                        (0606)                                             ;       no, set midpoint POR in user code, if desired
                                        (0607)   ELSE ; 24HMz                              ;
0123: 43 E3 20 OR    REG[0xE3],0x20     (0608)     or    reg[VLT_CR],  VLT_CR_POR_HIGH     ;      yes, highest POR trip point required
0126: 70 EF    AND   F,0xEF             
                                        (0609)   ENDIF ; 24MHz
                                        (0610)  ENDIF ; Slow Mode
                                        (0611) ENDIF ; 5.0V Operation
                                        (0612) 
                                        (0613)     M8C_SetBank0
                                        (0614) 
                                        (0615)     ;----------------------------
                                        (0616)     ; Wrap up and invoke "main"
                                        (0617)     ;----------------------------
                                        (0618) 
                                        (0619)     ; Disable the Sleep interrupt that was used for timing above.  In fact,
                                        (0620)     ; no interrupts should be enabled now, so may as well clear the register.
                                        (0621)     ;
0128: 62 E0 00 MOV   REG[0xE0],0x0      (0622)     mov  reg[INT_MSK0],0
012B: 71 10    OR    F,0x10             
                                        (0623) 
                                        (0624)     ; Everything has started OK. Now select requested CPU & sleep frequency.
                                        (0625)     ; And put decimator in full mode so it does not consume too much current.
                                        (0626)     ;
                                        (0627)     M8C_SetBank1
012D: 62 E0 03 MOV   REG[0xE0],0x3      (0628)     mov  reg[OSC_CR0],(SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
0130: 43 E7 80 OR    REG[0xE7],0x80     (0629)     or   reg[DEC_CR2],80h                    ; Put decimator in full mode
0133: 70 EF    AND   F,0xEF             
                                        (0630)     M8C_SetBank0
                                        (0631) 
                                        (0632)     ; Global Interrupt are NOT enabled, this should be done in main().
                                        (0633)     ; LVD is set but will not occur unless Global Interrupts are enabled.
                                        (0634)     ; Global Interrupts should be enabled as soon as possible in main().
                                        (0635)     ;
0135: 62 E2 00 MOV   REG[0xE2],0x0      (0636)     mov  reg[INT_VC],0             ; Clear any pending interrupts which may
                                        (0637)                                    ; have been set during the boot process.
                                        (0638) IF	(TOOLCHAIN & HITECH)
                                        (0639) 	ljmp  startup                  ; Jump to C compiler startup code
                                        (0640) ELSE
                                        (0641) IF ENABLE_LJMP_TO_MAIN
                                        (0642)     ljmp  _main                    ; goto main (no return)
                                        (0643) ELSE
0138: 7C 09 FC LCALL __UserModules_end|_main|__text_start|_main(0644)     lcall _main                    ; call main
                                        (0645) .Exit:
013B: 8F FF    JMP   0x013B             (0646)     jmp  .Exit                     ; Wait here after return till power-off or reset
                                        (0647) ENDIF
                                        (0648) ENDIF ; TOOLCHAIN
                                        (0649) 
                                        (0650)     ;---------------------------------
                                        (0651)     ; Library Access to Global Parms
                                        (0652)     ;---------------------------------
                                        (0653)     ;
                                        (0654)  bGetPowerSetting:
                                        (0655) _bGetPowerSetting:
                                        (0656)     ; Returns value of POWER_SETTING in the A register.
                                        (0657)     ; No inputs. No Side Effects.
                                        (0658)     ;
013D: 50 10    MOV   A,0x10             (0659)     mov   A, POWER_SETTING
013F: 7F       RET                      (0660)     ret
                                        (0661) 
                                        (0662) IF	(TOOLCHAIN & HITECH)
                                        (0663) ELSE
                                        (0664)     ;---------------------------------
                                        (0665)     ; Order Critical RAM & ROM AREAs
                                        (0666)     ;---------------------------------
                                        (0667)     ;  'TOP' is all that has been defined so far...
                                        (0668) 
                                        (0669)     ;  ROM AREAs for C CONST, static & global items
                                        (0670)     ;
                                        (0671)     AREA lit               (ROM, REL, CON)   ; 'const' definitions
                                        (0672)     AREA idata             (ROM, REL, CON)   ; Constants for initializing RAM
                                        (0673) __idata_start:
                                        (0674) 
                                        (0675)     AREA func_lit          (ROM, REL, CON)   ; Function Pointers
                                        (0676) __func_lit_start:
                                        (0677) 
                                        (0678) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0679)     ; We use the func_lit area to store a pointer to extended initialized
                                        (0680)     ; data (xidata) area that follows the text area. Func_lit isn't
                                        (0681)     ; relocated by the code compressor, but the text area may shrink and
                                        (0682)     ; that moves xidata around.
                                        (0683)     ;
                                        (0684) __pXIData:         word __text_end           ; ptr to extended idata
                                        (0685) ENDIF
                                        (0686) 
                                        (0687)     AREA psoc_config       (ROM, REL, CON)   ; Configuration Load & Unload
                                        (0688)     AREA UserModules       (ROM, REL, CON)   ; User Module APIs
                                        (0689) 
                                        (0690)     ; CODE segment for general use
                                        (0691)     ;
                                        (0692)     AREA text (ROM, REL, CON)
                                        (0693) __text_start:
                                        (0694) 
                                        (0695)     ; RAM area usage
                                        (0696)     ;
                                        (0697)     AREA data              (RAM, REL, CON)   ; initialized RAM
                                        (0698) __data_start:
                                        (0699) 
                                        (0700)     AREA virtual_registers (RAM, REL, CON)   ; Temp vars of C compiler
                                        (0701)     AREA InterruptRAM      (RAM, REL, CON)   ; Interrupts, on Page 0
                                        (0702)     AREA bss               (RAM, REL, CON)   ; general use
                                        (0703) __bss_start:
                                        (0704) 
                                        (0705) ENDIF ; TOOLCHAIN
                                        (0706) 
                                        (0707) ; end of file boot.asm
FILE: lib\psocconfigtbl.asm             (0001) ;  Generated by PSoC Designer 5.2.2551
048B: 70 EF    AND   F,0xEF             (0002) ;
                                        (0003) include "m8c.inc"
                                        (0004) ;  Personalization tables 
                                        (0005) export LoadConfigTBL_time_test_Bank1
                                        (0006) export LoadConfigTBL_time_test_Bank0
                                        (0007) export LoadConfigTBL_time_test_Ordered
                                        (0008) AREA lit(rom, rel)
                                        (0009) LoadConfigTBL_time_test_Bank0:
                                        (0010) ;  Instance name ADCINC_1, User Module ADCINC
                                        (0011) ;       Instance name ADCINC_1, Block Name ADC(ASC10)
                                        (0012) 	db		80h, 90h		;ADCINC_1_AtoDcr0(ASC10CR0)
                                        (0013) 	db		81h, 00h		;ADCINC_1_AtoDcr1(ASC10CR1)
                                        (0014) 	db		82h, 60h		;ADCINC_1_AtoDcr2(ASC10CR2)
                                        (0015) 	db		83h, f0h		;ADCINC_1_AtoDcr3(ASC10CR3)
                                        (0016) ;       Instance name ADCINC_1, Block Name PWM(DCB13)
                                        (0017) 	db		3fh, 00h		;ADCINC_1_PWMcr0(DCB13CR0)
                                        (0018) 	db		3dh, 00h		;ADCINC_1_PWMdr1(DCB13DR1)
                                        (0019) 	db		3eh, 01h		;ADCINC_1_PWMdr2(DCB13DR2)
                                        (0020) ;  Instance name AMUX4_1, User Module AMUX4
                                        (0021) ;  Instance name DigBuf_1, User Module DigBuf
                                        (0022) ;       Instance name DigBuf_1, Block Name DigBuf(DBB20)
                                        (0023) 	db		43h, 03h		;DigBuf_1_CONTROL_REG(DBB20CR0)
                                        (0024) 	db		41h, 00h		;DigBuf_1_DATA_1_REG(DBB20DR1)
                                        (0025) 	db		42h, 00h		;DigBuf_1_DATA_2_REG(DBB20DR2)
                                        (0026) ;  Instance name PGA_1, User Module PGA
                                        (0027) ;       Instance name PGA_1, Block Name GAIN(ACB00)
                                        (0028) 	db		71h, feh		;PGA_1_GAIN_CR0(ACB00CR0)
                                        (0029) 	db		72h, a1h		;PGA_1_GAIN_CR1(ACB00CR1)
                                        (0030) 	db		73h, 20h		;PGA_1_GAIN_CR2(ACB00CR2)
                                        (0031) 	db		70h, 00h		;PGA_1_GAIN_CR3(ACB00CR3)
                                        (0032) ;  Instance name PWM16_1, User Module PWM16
                                        (0033) ;       Instance name PWM16_1, Block Name PWM16_LSB(DBB00)
                                        (0034) 	db		23h, 00h		;PWM16_1_CONTROL_LSB_REG(DBB00CR0)
                                        (0035) 	db		21h, 80h		;PWM16_1_PERIOD_LSB_REG(DBB00DR1)
                                        (0036) 	db		22h, 40h		;PWM16_1_COMPARE_LSB_REG(DBB00DR2)
                                        (0037) ;       Instance name PWM16_1, Block Name PWM16_MSB(DBB01)
                                        (0038) 	db		27h, 00h		;PWM16_1_CONTROL_MSB_REG(DBB01CR0)
                                        (0039) 	db		25h, 0ch		;PWM16_1_PERIOD_MSB_REG(DBB01DR1)
                                        (0040) 	db		26h, 06h		;PWM16_1_COMPARE_MSB_REG(DBB01DR2)
                                        (0041) ;  Instance name PWM8_1, User Module PWM8
                                        (0042) ;       Instance name PWM8_1, Block Name PWM8(DBB10)
                                        (0043) 	db		33h, 00h		;PWM8_1_CONTROL_REG(DBB10CR0)
                                        (0044) 	db		31h, ffh		;PWM8_1_PERIOD_REG(DBB10DR1)
                                        (0045) 	db		32h, 0ah		;PWM8_1_COMPARE_REG(DBB10DR2)
                                        (0046) ;  Instance name PWM8_2, User Module PWM8
                                        (0047) ;       Instance name PWM8_2, Block Name PWM8(DBB21)
                                        (0048) 	db		47h, 00h		;PWM8_2_CONTROL_REG(DBB21CR0)
                                        (0049) 	db		45h, f0h		;PWM8_2_PERIOD_REG(DBB21DR1)
                                        (0050) 	db		46h, 0ah		;PWM8_2_COMPARE_REG(DBB21DR2)
                                        (0051) ;  Instance name TX8_1, User Module TX8
                                        (0052) ;       Instance name TX8_1, Block Name TX8(DCB23)
                                        (0053) 	db		4fh, 00h		;TX8_1_CONTROL_REG  (DCB23CR0)
                                        (0054) 	db		4dh, 00h		;TX8_1_TX_BUFFER_REG(DCB23DR1)
                                        (0055) 	db		4eh, 00h		;TX8_1_(DCB23DR2)
                                        (0056) ;  Instance name Timer16_1, User Module Timer16
                                        (0057) ;       Instance name Timer16_1, Block Name TIMER16_LSB(DCB02)
                                        (0058) 	db		2bh, 00h		;Timer16_1_CONTROL_LSB_REG(DCB02CR0)
                                        (0059) 	db		29h, 28h		;Timer16_1_PERIOD_LSB_REG(DCB02DR1)
                                        (0060) 	db		2ah, 14h		;Timer16_1_COMPARE_LSB_REG(DCB02DR2)
                                        (0061) ;       Instance name Timer16_1, Block Name TIMER16_MSB(DCB03)
                                        (0062) 	db		2fh, 04h		;Timer16_1_CONTROL_MSB_REG(DCB03CR0)
                                        (0063) 	db		2dh, 00h		;Timer16_1_PERIOD_MSB_REG(DCB03DR1)
                                        (0064) 	db		2eh, 00h		;Timer16_1_COMPARE_MSB_REG(DCB03DR2)
                                        (0065) ;  Instance name Timer16_2, User Module Timer16
                                        (0066) ;       Instance name Timer16_2, Block Name TIMER16_LSB(DBB11)
                                        (0067) 	db		37h, 00h		;Timer16_2_CONTROL_LSB_REG(DBB11CR0)
                                        (0068) 	db		35h, 00h		;Timer16_2_PERIOD_LSB_REG(DBB11DR1)
                                        (0069) 	db		36h, 00h		;Timer16_2_COMPARE_LSB_REG(DBB11DR2)
                                        (0070) ;       Instance name Timer16_2, Block Name TIMER16_MSB(DCB12)
                                        (0071) 	db		3bh, 04h		;Timer16_2_CONTROL_MSB_REG(DCB12CR0)
                                        (0072) 	db		39h, fah		;Timer16_2_PERIOD_MSB_REG(DCB12DR1)
                                        (0073) 	db		3ah, 00h		;Timer16_2_COMPARE_MSB_REG(DCB12DR2)
                                        (0074) ;  Global Register values Bank 0
                                        (0075) 	db		60h, 60h		; AnalogColumnInputSelect register (AMX_IN)
                                        (0076) 	db		66h, 00h		; AnalogComparatorControl1 register (CMP_CR1)
                                        (0077) 	db		63h, 15h		; AnalogReferenceControl register (ARF_CR)
                                        (0078) 	db		65h, 00h		; AnalogSyncControl register (ASY_CR)
                                        (0079) 	db		e6h, 01h		; DecimatorControl_0 register (DEC_CR0)
                                        (0080) 	db		e7h, 43h		; DecimatorControl_1 register (DEC_CR1)
                                        (0081) 	db		d6h, 00h		; I2CConfig register (I2C_CFG)
                                        (0082) 	db		b0h, 00h		; Row_0_InputMux register (RDI0RI)
                                        (0083) 	db		b1h, 00h		; Row_0_InputSync register (RDI0SYN)
                                        (0084) 	db		b2h, 00h		; Row_0_LogicInputAMux register (RDI0IS)
                                        (0085) 	db		b3h, 33h		; Row_0_LogicSelect_0 register (RDI0LT0)
                                        (0086) 	db		b4h, 33h		; Row_0_LogicSelect_1 register (RDI0LT1)
                                        (0087) 	db		b5h, 40h		; Row_0_OutputDrive_0 register (RDI0SRO0)
                                        (0088) 	db		b6h, 80h		; Row_0_OutputDrive_1 register (RDI0SRO1)
                                        (0089) 	db		b8h, 55h		; Row_1_InputMux register (RDI1RI)
                                        (0090) 	db		b9h, 00h		; Row_1_InputSync register (RDI1SYN)
                                        (0091) 	db		bah, 10h		; Row_1_LogicInputAMux register (RDI1IS)
                                        (0092) 	db		bbh, 33h		; Row_1_LogicSelect_0 register (RDI1LT0)
                                        (0093) 	db		bch, 33h		; Row_1_LogicSelect_1 register (RDI1LT1)
                                        (0094) 	db		bdh, 22h		; Row_1_OutputDrive_0 register (RDI1SRO0)
                                        (0095) 	db		beh, 00h		; Row_1_OutputDrive_1 register (RDI1SRO1)
                                        (0096) 	db		c0h, 10h		; Row_2_InputMux register (RDI2RI)
                                        (0097) 	db		c1h, 00h		; Row_2_InputSync register (RDI2SYN)
                                        (0098) 	db		c2h, 20h		; Row_2_LogicInputAMux register (RDI2IS)
                                        (0099) 	db		c3h, 33h		; Row_2_LogicSelect_0 register (RDI2LT0)
                                        (0100) 	db		c4h, 33h		; Row_2_LogicSelect_1 register (RDI3LT1)
                                        (0101) 	db		c5h, 10h		; Row_2_OutputDrive_0 register (RDI2SRO0)
                                        (0102) 	db		c6h, 12h		; Row_2_OutputDrive_1 register (RDI2SRO1)
                                        (0103) 	db		c8h, 55h		; Row_3_InputMux register (RDI3RI)
                                        (0104) 	db		c9h, 00h		; Row_3_InputSync register (RDI3SYN)
                                        (0105) 	db		cah, 30h		; Row_3_LogicInputAMux register (RDI3IS)
                                        (0106) 	db		cbh, 33h		; Row_3_LogicSelect_0 register (RDI3LT0)
                                        (0107) 	db		cch, 33h		; Row_3_LogicSelect_1 register (RDI3LT1)
                                        (0108) 	db		cdh, 00h		; Row_3_OutputDrive_0 register (RDI3SRO0)
                                        (0109) 	db		ceh, 00h		; Row_3_OutputDrive_1 register (RDI3SRO1)
                                        (0110) 	db		6ch, 00h		; TMP_DR0 register (TMP_DR0)
                                        (0111) 	db		6dh, 00h		; TMP_DR1 register (TMP_DR1)
                                        (0112) 	db		6eh, 00h		; TMP_DR2 register (TMP_DR2)
                                        (0113) 	db		6fh, 00h		; TMP_DR3 register (TMP_DR3)
                                        (0114) 	db		ffh
                                        (0115) LoadConfigTBL_time_test_Bank1:
                                        (0116) ;  Instance name ADCINC_1, User Module ADCINC
                                        (0117) ;       Instance name ADCINC_1, Block Name ADC(ASC10)
                                        (0118) ;       Instance name ADCINC_1, Block Name PWM(DCB13)
                                        (0119) 	db		3ch, 31h		;ADCINC_1_PWMfn(DCB13FN)
                                        (0120) 	db		3dh, 15h		;ADCINC_1_PWMsl(DCB13IN)
                                        (0121) 	db		3eh, 40h		;ADCINC_1_PWMos(DCB13OU)
                                        (0122) ;  Instance name AMUX4_1, User Module AMUX4
                                        (0123) ;  Instance name DigBuf_1, User Module DigBuf
                                        (0124) ;       Instance name DigBuf_1, Block Name DigBuf(DBB20)
                                        (0125) 	db		40h, 22h		;DigBuf_1_FUNC_REG(DBB20FN)
                                        (0126) 	db		41h, e0h		;DigBuf_1_INPUT_REG(DBA20IN)
                                        (0127) 	db		42h, 00h		;DigBuf_1_OUTPUT_REG(DBA20OU)
                                        (0128) ;  Instance name PGA_1, User Module PGA
                                        (0129) ;       Instance name PGA_1, Block Name GAIN(ACB00)
                                        (0130) ;  Instance name PWM16_1, User Module PWM16
                                        (0131) ;       Instance name PWM16_1, Block Name PWM16_LSB(DBB00)
                                        (0132) 	db		20h, 01h		;PWM16_1_FUNC_LSB_REG(DBB00FN)
                                        (0133) 	db		21h, 17h		;PWM16_1_INPUT_LSB_REG(DBB00IN)
                                        (0134) 	db		22h, 40h		;PWM16_1_OUTPUT_LSB_REG(DBB00OU)
                                        (0135) ;       Instance name PWM16_1, Block Name PWM16_MSB(DBB01)
                                        (0136) 	db		24h, 29h		;PWM16_1_FUNC_MSB_REG(DBB01FN)
                                        (0137) 	db		25h, 37h		;PWM16_1_INPUT_MSB_REG(DBB01IN)
                                        (0138) 	db		26h, 47h		;PWM16_1_OUTPUT_MSB_REG(DBB01OU)
                                        (0139) ;  Instance name PWM8_1, User Module PWM8
                                        (0140) ;       Instance name PWM8_1, Block Name PWM8(DBB10)
                                        (0141) 	db		30h, 21h		;PWM8_1_FUNC_REG(DBB10FN)
                                        (0142) 	db		31h, 17h		;PWM8_1_INPUT_REG(DBB10IN)
                                        (0143) 	db		32h, 44h		;PWM8_1_OUTPUT_REG(DBB10OU)
                                        (0144) ;  Instance name PWM8_2, User Module PWM8
                                        (0145) ;       Instance name PWM8_2, Block Name PWM8(DBB21)
                                        (0146) 	db		44h, 21h		;PWM8_2_FUNC_REG(DBB21FN)
                                        (0147) 	db		45h, 14h		;PWM8_2_INPUT_REG(DBB21IN)
                                        (0148) 	db		46h, 06h		;PWM8_2_OUTPUT_REG(DBB21OU)
                                        (0149) ;  Instance name TX8_1, User Module TX8
                                        (0150) ;       Instance name TX8_1, Block Name TX8(DCB23)
                                        (0151) 	db		4ch, 0dh		;TX8_1_FUNC_REG     (DCB23FN)
                                        (0152) 	db		4dh, 01h		;TX8_1_INPUT_REG    (DCB23IN)
                                        (0153) 	db		4eh, 47h		;TX8_1_OUTPUT_REG   (DCB23OU)
                                        (0154) ;  Instance name Timer16_1, User Module Timer16
                                        (0155) ;       Instance name Timer16_1, Block Name TIMER16_LSB(DCB02)
                                        (0156) 	db		28h, 00h		;Timer16_1_FUNC_LSB_REG(DCB02FN)
                                        (0157) 	db		29h, 17h		;Timer16_1_INPUT_LSB_REG(DCB02IN)
                                        (0158) 	db		2ah, 40h		;Timer16_1_OUTPUT_LSB_REG(DCB02OU)
                                        (0159) ;       Instance name Timer16_1, Block Name TIMER16_MSB(DCB03)
                                        (0160) 	db		2ch, 28h		;Timer16_1_FUNC_MSB_REG(DCB03FN)
                                        (0161) 	db		2dh, 37h		;Timer16_1_INPUT_MSB_REG(DCB03IN)
                                        (0162) 	db		2eh, 68h		;Timer16_1_OUTPUT_MSB_REG(DCB03OU)
                                        (0163) ;  Instance name Timer16_2, User Module Timer16
                                        (0164) ;       Instance name Timer16_2, Block Name TIMER16_LSB(DBB11)
                                        (0165) 	db		34h, 00h		;Timer16_2_FUNC_LSB_REG(DBB11FN)
                                        (0166) 	db		35h, 07h		;Timer16_2_INPUT_LSB_REG(DBB11IN)
                                        (0167) 	db		36h, 40h		;Timer16_2_OUTPUT_LSB_REG(DBB11OU)
                                        (0168) ;       Instance name Timer16_2, Block Name TIMER16_MSB(DCB12)
                                        (0169) 	db		38h, 20h		;Timer16_2_FUNC_MSB_REG(DCB12FN)
                                        (0170) 	db		39h, 37h		;Timer16_2_INPUT_MSB_REG(DCB12IN)
                                        (0171) 	db		3ah, 68h		;Timer16_2_OUTPUT_MSB_REG(DCB12OU)
                                        (0172) ;  Global Register values Bank 1
                                        (0173) 	db		61h, 00h		; AnalogClockSelect1 register (CLK_CR1)
                                        (0174) 	db		69h, 00h		; AnalogClockSelect2 register (CLK_CR2)
                                        (0175) 	db		60h, 00h		; AnalogColumnClockSelect register (CLK_CR0)
                                        (0176) 	db		62h, 00h		; AnalogIOControl_0 register (ABF_CR0)
                                        (0177) 	db		67h, 33h		; AnalogLUTControl0 register (ALT_CR0)
                                        (0178) 	db		68h, 33h		; AnalogLUTControl1 register (ALT_CR1)
                                        (0179) 	db		63h, 00h		; AnalogModulatorControl_0 register (AMD_CR0)
                                        (0180) 	db		66h, 00h		; AnalogModulatorControl_1 register (AMD_CR1)
                                        (0181) 	db		d1h, 00h		; GlobalDigitalInterconnect_Drive_Even_Input register (GDI_E_IN)
                                        (0182) 	db		d3h, 00h		; GlobalDigitalInterconnect_Drive_Even_Output register (GDI_E_OU)
                                        (0183) 	db		d0h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Input register (GDI_O_IN)
                                        (0184) 	db		d2h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Output register (GDI_O_OU)
                                        (0185) 	db		e1h, 2fh		; OscillatorControl_1 register (OSC_CR1)
                                        (0186) 	db		e2h, 00h		; OscillatorControl_2 register (OSC_CR2)
                                        (0187) 	db		dfh, 9bh		; OscillatorControl_3 register (OSC_CR3)
                                        (0188) 	db		deh, 00h		; OscillatorControl_4 register (OSC_CR4)
                                        (0189) 	db		ddh, 00h		; OscillatorGlobalBusEnableControl register (OSC_GO_EN)
                                        (0190) 	db		e7h, 48h		; Type2Decimator_Control register (DEC_CR2)
                                        (0191) 	db		ffh
                                        (0192) AREA psoc_config(rom, rel)
                                        (0193) LoadConfigTBL_time_test_Ordered:
                                        (0194) ;  Ordered Global Register values
                                        (0195) 	M8C_SetBank0
048D: 62 00 10 MOV   REG[0x0],0x10      (0196) 	mov	reg[00h], 10h		; Port_0_Data register (PRT0DR)
0490: 71 10    OR    F,0x10             
                                        (0197) 	M8C_SetBank1
0492: 62 00 D0 MOV   REG[0x0],0xD0      (0198) 	mov	reg[00h], d0h		; Port_0_DriveMode_0 register (PRT0DM0)
0495: 62 01 3F MOV   REG[0x1],0x3F      (0199) 	mov	reg[01h], 3fh		; Port_0_DriveMode_1 register (PRT0DM1)
0498: 70 EF    AND   F,0xEF             
                                        (0200) 	M8C_SetBank0
049A: 62 03 2F MOV   REG[0x3],0x2F      (0201) 	mov	reg[03h], 2fh		; Port_0_DriveMode_2 register (PRT0DM2)
049D: 62 02 00 MOV   REG[0x2],0x0       (0202) 	mov	reg[02h], 00h		; Port_0_GlobalSelect register (PRT0GS)
04A0: 71 10    OR    F,0x10             
                                        (0203) 	M8C_SetBank1
04A2: 62 02 00 MOV   REG[0x2],0x0       (0204) 	mov	reg[02h], 00h		; Port_0_IntCtrl_0 register (PRT0IC0)
04A5: 62 03 00 MOV   REG[0x3],0x0       (0205) 	mov	reg[03h], 00h		; Port_0_IntCtrl_1 register (PRT0IC1)
04A8: 70 EF    AND   F,0xEF             
                                        (0206) 	M8C_SetBank0
04AA: 62 01 00 MOV   REG[0x1],0x0       (0207) 	mov	reg[01h], 00h		; Port_0_IntEn register (PRT0IE)
04AD: 62 04 40 MOV   REG[0x4],0x40      (0208) 	mov	reg[04h], 40h		; Port_1_Data register (PRT1DR)
04B0: 71 10    OR    F,0x10             
                                        (0209) 	M8C_SetBank1
04B2: 62 04 D7 MOV   REG[0x4],0xD7      (0210) 	mov	reg[04h], d7h		; Port_1_DriveMode_0 register (PRT1DM0)
04B5: 62 05 68 MOV   REG[0x5],0x68      (0211) 	mov	reg[05h], 68h		; Port_1_DriveMode_1 register (PRT1DM1)
04B8: 70 EF    AND   F,0xEF             
                                        (0212) 	M8C_SetBank0
04BA: 62 07 28 MOV   REG[0x7],0x28      (0213) 	mov	reg[07h], 28h		; Port_1_DriveMode_2 register (PRT1DM2)
04BD: 62 06 83 MOV   REG[0x6],0x83      (0214) 	mov	reg[06h], 83h		; Port_1_GlobalSelect register (PRT1GS)
04C0: 71 10    OR    F,0x10             
                                        (0215) 	M8C_SetBank1
04C2: 62 06 40 MOV   REG[0x6],0x40      (0216) 	mov	reg[06h], 40h		; Port_1_IntCtrl_0 register (PRT1IC0)
04C5: 62 07 40 MOV   REG[0x7],0x40      (0217) 	mov	reg[07h], 40h		; Port_1_IntCtrl_1 register (PRT1IC1)
04C8: 70 EF    AND   F,0xEF             
                                        (0218) 	M8C_SetBank0
04CA: 62 05 40 MOV   REG[0x5],0x40      (0219) 	mov	reg[05h], 40h		; Port_1_IntEn register (PRT1IE)
04CD: 62 08 00 MOV   REG[0x8],0x0       (0220) 	mov	reg[08h], 00h		; Port_2_Data register (PRT2DR)
04D0: 71 10    OR    F,0x10             
                                        (0221) 	M8C_SetBank1
04D2: 62 08 7A MOV   REG[0x8],0x7A      (0222) 	mov	reg[08h], 7ah		; Port_2_DriveMode_0 register (PRT2DM0)
04D5: 62 09 85 MOV   REG[0x9],0x85      (0223) 	mov	reg[09h], 85h		; Port_2_DriveMode_1 register (PRT2DM1)
04D8: 70 EF    AND   F,0xEF             
                                        (0224) 	M8C_SetBank0
04DA: 62 0B 85 MOV   REG[0xB],0x85      (0225) 	mov	reg[0bh], 85h		; Port_2_DriveMode_2 register (PRT2DM2)
04DD: 62 0A 7A MOV   REG[0xA],0x7A      (0226) 	mov	reg[0ah], 7ah		; Port_2_GlobalSelect register (PRT2GS)
04E0: 71 10    OR    F,0x10             
                                        (0227) 	M8C_SetBank1
04E2: 62 0A 00 MOV   REG[0xA],0x0       (0228) 	mov	reg[0ah], 00h		; Port_2_IntCtrl_0 register (PRT2IC0)
04E5: 62 0B 00 MOV   REG[0xB],0x0       (0229) 	mov	reg[0bh], 00h		; Port_2_IntCtrl_1 register (PRT2IC1)
04E8: 70 EF    AND   F,0xEF             
                                        (0230) 	M8C_SetBank0
04EA: 62 09 00 MOV   REG[0x9],0x0       (0231) 	mov	reg[09h], 00h		; Port_2_IntEn register (PRT2IE)
04ED: 62 0C 00 MOV   REG[0xC],0x0       (0232) 	mov	reg[0ch], 00h		; Port_3_Data register (PRT3DR)
04F0: 71 10    OR    F,0x10             
                                        (0233) 	M8C_SetBank1
04F2: 62 0C 00 MOV   REG[0xC],0x0       (0234) 	mov	reg[0ch], 00h		; Port_3_DriveMode_0 register (PRT3DM0)
04F5: 62 0D 00 MOV   REG[0xD],0x0       (0235) 	mov	reg[0dh], 00h		; Port_3_DriveMode_1 register (PRT3DM1)
04F8: 70 EF    AND   F,0xEF             
                                        (0236) 	M8C_SetBank0
04FA: 62 0F 00 MOV   REG[0xF],0x0       (0237) 	mov	reg[0fh], 00h		; Port_3_DriveMode_2 register (PRT3DM2)
04FD: 62 0E 00 MOV   REG[0xE],0x0       (0238) 	mov	reg[0eh], 00h		; Port_3_GlobalSelect register (PRT3GS)
0500: 71 10    OR    F,0x10             
                                        (0239) 	M8C_SetBank1
0502: 62 0E 00 MOV   REG[0xE],0x0       (0240) 	mov	reg[0eh], 00h		; Port_3_IntCtrl_0 register (PRT3IC0)
0505: 62 0F 00 MOV   REG[0xF],0x0       (0241) 	mov	reg[0fh], 00h		; Port_3_IntCtrl_1 register (PRT3IC1)
0508: 70 EF    AND   F,0xEF             
                                        (0242) 	M8C_SetBank0
050A: 62 0D 00 MOV   REG[0xD],0x0       (0243) 	mov	reg[0dh], 00h		; Port_3_IntEn register (PRT3IE)
050D: 62 10 00 MOV   REG[0x10],0x0      (0244) 	mov	reg[10h], 00h		; Port_4_Data register (PRT4DR)
0510: 71 10    OR    F,0x10             
                                        (0245) 	M8C_SetBank1
0512: 62 10 00 MOV   REG[0x10],0x0      (0246) 	mov	reg[10h], 00h		; Port_4_DriveMode_0 register (PRT4DM0)
0515: 62 11 00 MOV   REG[0x11],0x0      (0247) 	mov	reg[11h], 00h		; Port_4_DriveMode_1 register (PRT4DM1)
0518: 70 EF    AND   F,0xEF             
                                        (0248) 	M8C_SetBank0
051A: 62 13 00 MOV   REG[0x13],0x0      (0249) 	mov	reg[13h], 00h		; Port_4_DriveMode_2 register (PRT4DM2)
051D: 62 12 00 MOV   REG[0x12],0x0      (0250) 	mov	reg[12h], 00h		; Port_4_GlobalSelect register (PRT4GS)
0520: 71 10    OR    F,0x10             
                                        (0251) 	M8C_SetBank1
0522: 62 12 00 MOV   REG[0x12],0x0      (0252) 	mov	reg[12h], 00h		; Port_4_IntCtrl_0 register (PRT4IC0)
0525: 62 13 00 MOV   REG[0x13],0x0      (0253) 	mov	reg[13h], 00h		; Port_4_IntCtrl_1 register (PRT4IC1)
0528: 70 EF    AND   F,0xEF             
                                        (0254) 	M8C_SetBank0
052A: 62 11 00 MOV   REG[0x11],0x0      (0255) 	mov	reg[11h], 00h		; Port_4_IntEn register (PRT4IE)
052D: 62 14 00 MOV   REG[0x14],0x0      (0256) 	mov	reg[14h], 00h		; Port_5_Data register (PRT5DR)
0530: 71 10    OR    F,0x10             
                                        (0257) 	M8C_SetBank1
0532: 62 14 00 MOV   REG[0x14],0x0      (0258) 	mov	reg[14h], 00h		; Port_5_DriveMode_0 register (PRT5DM0)
0535: 62 15 00 MOV   REG[0x15],0x0      (0259) 	mov	reg[15h], 00h		; Port_5_DriveMode_1 register (PRT5DM1)
0538: 70 EF    AND   F,0xEF             
                                        (0260) 	M8C_SetBank0
053A: 62 17 00 MOV   REG[0x17],0x0      (0261) 	mov	reg[17h], 00h		; Port_5_DriveMode_2 register (PRT5DM2)
053D: 62 16 00 MOV   REG[0x16],0x0      (0262) 	mov	reg[16h], 00h		; Port_5_GlobalSelect register (PRT5GS)
0540: 71 10    OR    F,0x10             
                                        (0263) 	M8C_SetBank1
0542: 62 16 00 MOV   REG[0x16],0x0      (0264) 	mov	reg[16h], 00h		; Port_5_IntCtrl_0 register (PRT5IC0)
0545: 62 17 00 MOV   REG[0x17],0x0      (0265) 	mov	reg[17h], 00h		; Port_5_IntCtrl_1 register (PRT5IC1)
0548: 70 EF    AND   F,0xEF             
                                        (0266) 	M8C_SetBank0
054A: 62 15 00 MOV   REG[0x15],0x0      (0267) 	mov	reg[15h], 00h		; Port_5_IntEn register (PRT5IE)
054D: 62 18 00 MOV   REG[0x18],0x0      (0268) 	mov	reg[18h], 00h		; Port_6_Data register (PRT6DR)
0550: 71 10    OR    F,0x10             
                                        (0269) 	M8C_SetBank1
0552: 62 18 00 MOV   REG[0x18],0x0      (0270) 	mov	reg[18h], 00h		; Port_6_DriveMode_0 register (PRT6DM0)
0555: 62 19 00 MOV   REG[0x19],0x0      (0271) 	mov	reg[19h], 00h		; Port_6_DriveMode_1 register (PRT6DM1)
0558: 70 EF    AND   F,0xEF             
                                        (0272) 	M8C_SetBank0
055A: 62 1B 00 MOV   REG[0x1B],0x0      (0273) 	mov	reg[1bh], 00h		; Port_6_DriveMode_2 register (PRT6DM2)
055D: 62 1A 00 MOV   REG[0x1A],0x0      (0274) 	mov	reg[1ah], 00h		; Port_6_GlobalSelect register (PRT6GS)
0560: 71 10    OR    F,0x10             
                                        (0275) 	M8C_SetBank1
0562: 62 1A 00 MOV   REG[0x1A],0x0      (0276) 	mov	reg[1ah], 00h		; Port_6_IntCtrl_0 register (PRT6IC0)
0565: 62 1B 00 MOV   REG[0x1B],0x0      (0277) 	mov	reg[1bh], 00h		; Port_6_IntCtrl_1 register (PRT6IC1)
0568: 70 EF    AND   F,0xEF             
                                        (0278) 	M8C_SetBank0
056A: 62 19 00 MOV   REG[0x19],0x0      (0279) 	mov	reg[19h], 00h		; Port_6_IntEn register (PRT6IE)
056D: 62 1C 00 MOV   REG[0x1C],0x0      (0280) 	mov	reg[1ch], 00h		; Port_7_Data register (PRT7DR)
0570: 71 10    OR    F,0x10             
                                        (0281) 	M8C_SetBank1
0572: 62 1C 00 MOV   REG[0x1C],0x0      (0282) 	mov	reg[1ch], 00h		; Port_7_DriveMode_0 register (PRT7DM0)
0575: 62 1D 00 MOV   REG[0x1D],0x0      (0283) 	mov	reg[1dh], 00h		; Port_7_DriveMode_1 register (PRT7DM1)
0578: 70 EF    AND   F,0xEF             
                                        (0284) 	M8C_SetBank0
057A: 62 1F 00 MOV   REG[0x1F],0x0      (0285) 	mov	reg[1fh], 00h		; Port_7_DriveMode_2 register (PRT7DM2)
057D: 62 1E 00 MOV   REG[0x1E],0x0      (0286) 	mov	reg[1eh], 00h		; Port_7_GlobalSelect register (PRT7GS)
0580: 71 10    OR    F,0x10             
                                        (0287) 	M8C_SetBank1
0582: 62 1E 00 MOV   REG[0x1E],0x0      (0288) 	mov	reg[1eh], 00h		; Port_7_IntCtrl_0 register (PRT7IC0)
0585: 62 1F 00 MOV   REG[0x1F],0x0      (0289) 	mov	reg[1fh], 00h		; Port_7_IntCtrl_1 register (PRT7IC1)
0588: 70 EF    AND   F,0xEF             
                                        (0290) 	M8C_SetBank0
058A: 62 1D 00 MOV   REG[0x1D],0x0      (0291) 	mov	reg[1dh], 00h		; Port_7_IntEn register (PRT7IE)
058D: 70 EF    AND   F,0xEF             
                                        (0292) 	M8C_SetBank0
058F: 7F       RET                      (0293) 	ret
                                        (0294) 
                                        (0295) 
                                        (0296) ; PSoC Configuration file trailer PsocConfig.asm
FILE: lib\psocconfig.asm                (0001) ;  Generated by PSoC Designer 5.2.2551
                                        (0002) ;
                                        (0003) ;==========================================================================
                                        (0004) ;  PSoCConfig.asm
                                        (0005) ;  @PSOC_VERSION
                                        (0006) ;
                                        (0007) ;  Version: 0.85
                                        (0008) ;  Revised: June 22, 2004
                                        (0009) ;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0010) ;
                                        (0011) ;  This file is generated by the Device Editor on Application Generation.
                                        (0012) ;  It contains code which loads the configuration data table generated in
                                        (0013) ;  the file PSoCConfigTBL.asm
                                        (0014) ;
                                        (0015) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                        (0016) ;  Edits to this file will not be preserved.
                                        (0017) ;==========================================================================
                                        (0018) ;
                                        (0019) include "m8c.inc"
                                        (0020) include "memory.inc"
                                        (0021) include "GlobalParams.inc"
                                        (0022) 
                                        (0023) export LoadConfigInit
                                        (0024) export _LoadConfigInit
                                        (0025) export LoadConfig_time_test
                                        (0026) export _LoadConfig_time_test
                                        (0027) 
                                        (0028) export NO_SHADOW
                                        (0029) export _NO_SHADOW
                                        (0030) 
                                        (0031) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                        (0032) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                        (0033) 
                                        (0034) AREA psoc_config(rom, rel)
                                        (0035) 
                                        (0036) ;---------------------------------------------------------------------------
                                        (0037) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                        (0038) ;                  parameters handled by boot code, like CPU speed). This
                                        (0039) ;                  function can be called from user code, but typically it
                                        (0040) ;                  is only called from boot.
                                        (0041) ;
                                        (0042) ;       INPUTS: None.
                                        (0043) ;      RETURNS: Nothing.
                                        (0044) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                        (0045) ;               In the large memory model currently only the page
                                        (0046) ;               pointer registers listed below are modified.  This does
                                        (0047) ;               not guarantee that in future implementations of this
                                        (0048) ;               function other page pointer registers will not be
                                        (0049) ;               modified.
                                        (0050) ;          
                                        (0051) ;               Page Pointer Registers Modified: 
                                        (0052) ;               CUR_PP
                                        (0053) ;
                                        (0054) _LoadConfigInit:
                                        (0055)  LoadConfigInit:
                                        (0056)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0057)     
0590: 7C 05 97 LCALL 0x0597             (0058) 	lcall	LoadConfig_time_test
0593: 7C 04 8B LCALL 0x048B             (0059) 	lcall	LoadConfigTBL_time_test_Ordered
                                        (0060) 
                                        (0061) 
                                        (0062)     RAM_EPILOGUE RAM_USE_CLASS_4
0596: 7F       RET                      (0063)     ret
                                        (0064) 
                                        (0065) ;---------------------------------------------------------------------------
                                        (0066) ; Load Configuration time_test
                                        (0067) ;
                                        (0068) ;    Load configuration registers for time_test.
                                        (0069) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                        (0070) ;
                                        (0071) ;       INPUTS: None.
                                        (0072) ;      RETURNS: Nothing.
                                        (0073) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                        (0074) ;               modified as may the Page Pointer registers!
                                        (0075) ;               In the large memory model currently only the page
                                        (0076) ;               pointer registers listed below are modified.  This does
                                        (0077) ;               not guarantee that in future implementations of this
                                        (0078) ;               function other page pointer registers will not be
                                        (0079) ;               modified.
                                        (0080) ;          
                                        (0081) ;               Page Pointer Registers Modified: 
                                        (0082) ;               CUR_PP
                                        (0083) ;
                                        (0084) _LoadConfig_time_test:
                                        (0085)  LoadConfig_time_test:
                                        (0086)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0087) 
0597: 10       PUSH  X                  (0088) 	push	x
0598: 70 EF    AND   F,0xEF             
                                        (0089)     M8C_SetBank0                    ; Force bank 0
059A: 50 00    MOV   A,0x0              (0090)     mov     a, 0                    ; Specify bank 0
059C: 67       ASR   A                  (0091)     asr     a                       ; Store in carry flag
                                        (0092)                                     ; Load bank 0 table:
059D: 50 01    MOV   A,0x1              (0093)     mov     A, >LoadConfigTBL_time_test_Bank0
059F: 57 CC    MOV   X,0xCC             (0094)     mov     X, <LoadConfigTBL_time_test_Bank0
05A1: 7C 05 B2 LCALL 0x05B2             (0095)     lcall   LoadConfig              ; Load the bank 0 values
                                        (0096) 
05A4: 50 01    MOV   A,0x1              (0097)     mov     a, 1                    ; Specify bank 1
05A6: 67       ASR   A                  (0098)     asr     a                       ; Store in carry flag
                                        (0099)                                     ; Load bank 1 table:
05A7: 50 02    MOV   A,0x2              (0100)     mov     A, >LoadConfigTBL_time_test_Bank1
05A9: 57 6D    MOV   X,0x6D             (0101)     mov     X, <LoadConfigTBL_time_test_Bank1
05AB: 7C 05 B2 LCALL 0x05B2             (0102)     lcall   LoadConfig              ; Load the bank 1 values
05AE: 70 EF    AND   F,0xEF             
                                        (0103) 
                                        (0104)     M8C_SetBank0                    ; Force return to bank 0
05B0: 20       POP   X                  (0105) 	pop		x
                                        (0106) 
                                        (0107)     RAM_EPILOGUE RAM_USE_CLASS_4
05B1: 7F       RET                      (0108)     ret
                                        (0109) 
                                        (0110) 
                                        (0111) 
                                        (0112) 
                                        (0113) ;---------------------------------------------------------------------------
                                        (0114) ; LoadConfig - Set IO registers as specified in ROM table of (address,value)
                                        (0115) ;              pairs. Terminate on address=0xFF.
                                        (0116) ;
                                        (0117) ;  INPUTS:  [A,X] points to the table to be loaded
                                        (0118) ;           Flag Register Carry bit encodes the Register Bank
                                        (0119) ;           (Carry=0 => Bank 0; Carry=1 => Bank 1)
                                        (0120) ;
                                        (0121) ;  RETURNS: nothing.
                                        (0122) ;
                                        (0123) ;  STACK FRAME:  X-4 I/O Bank 0/1 indicator
                                        (0124) ;                X-3 Temporary store for register address
                                        (0125) ;                X-2 LSB of config table address
                                        (0126) ;                X-1 MSB of config table address
                                        (0127) ;
                                        (0128) LoadConfig:
                                        (0129)     RAM_PROLOGUE RAM_USE_CLASS_2
05B2: 38 02    ADD   SP,0x2             (0130)     add     SP, 2                   ; Set up local vars
05B4: 10       PUSH  X                  (0131)     push    X                       ; Save config table address on stack
05B5: 08       PUSH  A                  (0132)     push    A
05B6: 4F       MOV   X,SP               (0133)     mov     X, SP
05B7: 56 FC 00 MOV   [X-4],0x0          (0134)     mov     [X-4], 0                ; Set default Destination to Bank 0
05BA: D0 04    JNC   0x05BF             (0135)     jnc     .BankSelectSaved        ; Carry says Bank 0 is OK
05BC: 56 FC 01 MOV   [X-4],0x1          (0136)     mov     [X-4], 1                ; No Carry: default to Bank 1
                                        (0137) .BankSelectSaved:
05BF: 18       POP   A                  (0138)     pop     A
05C0: 20       POP   X                  (0139)     pop     X
05C1: 70 EF    AND   F,0xEF             
05C3: 62 E3 00 MOV   REG[0xE3],0x0      
                                        (0140) 
                                        (0141) LoadConfigLp:
                                        (0142)     M8C_SetBank0                    ; Switch to bank 0
                                        (0143)     M8C_ClearWDT                    ; Clear the watchdog for long inits
05C6: 10       PUSH  X                  (0144)     push    X                       ; Preserve the config table address
05C7: 08       PUSH  A                  (0145)     push    A
05C8: 28       ROMX                     (0146)     romx                            ; Load register address from table
05C9: 39 FF    CMP   A,0xFF             (0147)     cmp     A, END_CONFIG_TABLE     ; End of table?
05CB: A0 1F    JZ    0x05EB             (0148)     jz      EndLoadConfig           ;   Yes, go wrap it up
05CD: 4F       MOV   X,SP               (0149)     mov     X, SP                   ;
05CE: 48 FC 01 TST   [X-4],0x1          (0150)     tst     [X-4], 1                ; Loading IO Bank 1?
05D1: A0 03    JZ    0x05D5             (0151)     jz      .IOBankNowSet           ;    No, Bank 0 is fine
05D3: 71 10    OR    F,0x10             
                                        (0152)     M8C_SetBank1                    ;   Yes, switch to Bank 1
                                        (0153) .IOBankNowSet:
05D5: 54 FD    MOV   [X-3],A            (0154)     mov     [X-3], A                ; Stash the register address
05D7: 18       POP   A                  (0155)     pop     A                       ; Retrieve the table address
05D8: 20       POP   X                  (0156)     pop     X
05D9: 75       INC   X                  (0157)     inc     X                       ; Advance to the data byte
05DA: 09 00    ADC   A,0x0              (0158)     adc     A, 0
05DC: 10       PUSH  X                  (0159)     push    X                       ; Save the config table address again
05DD: 08       PUSH  A                  (0160)     push    A
05DE: 28       ROMX                     (0161)     romx                            ; load config data from the table
05DF: 4F       MOV   X,SP               (0162)     mov     X, SP                   ; retrieve the register address
05E0: 59 FD    MOV   X,[X-3]            (0163)     mov     X, [X-3]
05E2: 61 00    MOV   REG[X+0x0],A       (0164)     mov     reg[X], A               ; Configure the register
05E4: 18       POP   A                  (0165)     pop     A                       ; retrieve the table address
05E5: 20       POP   X                  (0166)     pop     X
05E6: 75       INC   X                  (0167)     inc     X                       ; advance to next table entry
05E7: 09 00    ADC   A,0x0              (0168)     adc     A, 0
05E9: 8F D7    JMP   0x05C1             (0169)     jmp     LoadConfigLp            ; loop to configure another register
                                        (0170) EndLoadConfig:
05EB: 38 FC    ADD   SP,0xFC            (0171)     add     SP, -4
05ED: 70 3F    AND   F,0x3F             
05EF: 71 C0    OR    F,0xC0             
                                        (0172)     RAM_EPILOGUE RAM_USE_CLASS_2
05F1: 7F       RET                      (0173)     ret
                                        (0174) 
                                        (0175) AREA InterruptRAM(ram, rel)
                                        (0176) 
                                        (0177) NO_SHADOW:
                                        (0178) _NO_SHADOW:
FILE: lib\tx8_1int.asm                  (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: TX8_1INT.asm
                                        (0004) ;;   Version: 3.50, Updated on 2012/3/2 at 9:15:33
                                        (0005) ;;  Generated by PSoC Designer 5.2.2551
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION:  TX8 Interrupt Service Rountine.
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "memory.inc"
                                        (0015) include "TX8_1.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _TX8_1_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _TX8_1_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _TX8_1_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070)    
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom assembly code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    
                                        (0075)    ;---------------------------------------------------
                                        (0076)    ; Insert a lcall to a C function below this banner
                                        (0077)    ; and un-comment the lines between these banners
                                        (0078)    ;---------------------------------------------------
                                        (0079)    
                                        (0080)    ;PRESERVE_CPU_CONTEXT
                                        (0081)    ;lcall _My_C_Function
                                        (0082)    ;RESTORE_CPU_CONTEXT
                                        (0083)    
                                        (0084)    ;---------------------------------------------------
                                        (0085)    ; Insert a lcall to a C function above this banner
                                        (0086)    ; and un-comment the lines between these banners
                                        (0087)    ;---------------------------------------------------
                                        (0088)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0089) 
05F2: 7E       RETI                     (0090)    reti
                                        (0091) 
                                        (0092) 
                                        (0093) ; end of file TX8_1INT.asm
FILE: lib\tx8_1.asm                     (0001) ;;*****************************************************************************
05F3: 43 DF 08 OR    REG[0xDF],0x8      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: TX8_1.asm
                                        (0004) ;;   Version: 3.50, Updated on 2012/3/2 at 9:15:33
                                        (0005) ;;  Generated by PSoC Designer 5.2.2551
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: TX8 User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) ;-----------------------------------------------
                                        (0023) ; include instance specific register definitions
                                        (0024) ;-----------------------------------------------
                                        (0025) include "m8c.inc"
                                        (0026) include "memory.inc"
                                        (0027) include "TX8_1.inc"
                                        (0028) 
                                        (0029) area UserModules (ROM, REL)
                                        (0030) ;-----------------------------------------------
                                        (0031) ;  Global Symbols
                                        (0032) ;-----------------------------------------------
                                        (0033) export   TX8_1_SetTxIntMode
                                        (0034) export  _TX8_1_SetTxIntMode
                                        (0035) export   TX8_1_EnableInt
                                        (0036) export  _TX8_1_EnableInt
                                        (0037) export   TX8_1_DisableInt
                                        (0038) export  _TX8_1_DisableInt
                                        (0039) export   TX8_1_Start
                                        (0040) export  _TX8_1_Start
                                        (0041) export   TX8_1_Stop
                                        (0042) export  _TX8_1_Stop
                                        (0043) export   TX8_1_SendData
                                        (0044) export  _TX8_1_SendData
                                        (0045) export   TX8_1_bReadTxStatus
                                        (0046) export  _TX8_1_bReadTxStatus
                                        (0047) 
                                        (0048) // Old labels, will be removed in future release
                                        (0049) // Do Not Use.
                                        (0050) export   bTX8_1_ReadTxStatus
                                        (0051) export  _bTX8_1_ReadTxStatus
                                        (0052) 
                                        (0053) ;-----------------------------------------------
                                        (0054) ;  High Level TX functions
                                        (0055) ;-----------------------------------------------
                                        (0056) export  TX8_1_PutSHexByte
                                        (0057) export _TX8_1_PutSHexByte
                                        (0058) export  TX8_1_PutSHexInt
                                        (0059) export _TX8_1_PutSHexInt
                                        (0060) 
                                        (0061) export  TX8_1_CPutString
                                        (0062) export _TX8_1_CPutString
                                        (0063) export  TX8_1_PutString
                                        (0064) export _TX8_1_PutString
                                        (0065) export  TX8_1_PutChar
                                        (0066) export _TX8_1_PutChar
                                        (0067) export  TX8_1_Write
                                        (0068) export _TX8_1_Write
                                        (0069) export  TX8_1_CWrite
                                        (0070) export _TX8_1_CWrite
                                        (0071) export  TX8_1_PutCRLF
                                        (0072) export _TX8_1_PutCRLF 
                                        (0073) 
                                        (0074) ;-----------------------------------------------
                                        (0075) ;  EQUATES
                                        (0076) ;-----------------------------------------------
                                        (0077) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                        (0078) bfFUNCTION_REG_TX_INT_MODE_BIT:	equ 0x10	; the TX Int Mode bit
                                        (0079) 
                                        (0080) AREA UserModules (ROM, REL)
                                        (0081) 
                                        (0082) .SECTION
                                        (0083) ;-----------------------------------------------------------------------------
                                        (0084) ;  FUNCTION NAME: TX8_1_EnableInt
                                        (0085) ;
                                        (0086) ;  DESCRIPTION:
                                        (0087) ;     Enables this Transmitter's interrupt by setting the interrupt enable mask
                                        (0088) ;     bit associated with this User Module. Remember to call the global interrupt
                                        (0089) ;     enable function by using the macro: M8C_EnableGInt.
                                        (0090) ;
                                        (0091) ;-----------------------------------------------------------------------------
                                        (0092) ;
                                        (0093) ;  ARGUMENTS: none
                                        (0094) ;
                                        (0095) ;  RETURNS: none
                                        (0096) ;
                                        (0097) ;  SIDE EFFECTS:
                                        (0098) ;    The A and X registers may be modified by this or future implementations
                                        (0099) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0100) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0101) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0102) ;    functions.
                                        (0103) ;
                                        (0104)  TX8_1_EnableInt:
                                        (0105) _TX8_1_EnableInt:
                                        (0106)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0107)    M8C_EnableIntMask  TX8_1_INT_REG, TX8_1_bINT_MASK
                                        (0108)    RAM_EPILOGUE RAM_USE_CLASS_1
05F6: 7F       RET                      (0109)    ret
05F7: 41 DF F7 AND   REG[0xDF],0xF7     
                                        (0110) .ENDSECTION
                                        (0111) 
                                        (0112) .SECTION
                                        (0113) ;-----------------------------------------------------------------------------
                                        (0114) ;  FUNCTION NAME: TX8_1_DisableInt
                                        (0115) ;
                                        (0116) ;  DESCRIPTION:
                                        (0117) ;     Disables this TX8's interrupt by clearing the interrupt enable mask bit
                                        (0118) ;     associated with this User Module.
                                        (0119) ;
                                        (0120) ;-----------------------------------------------------------------------------
                                        (0121) ;
                                        (0122) ;  ARGUMENTS:  none
                                        (0123) ;
                                        (0124) ;  RETURNS:  none
                                        (0125) ;
                                        (0126) ;  SIDE EFFECTS:
                                        (0127) ;    The A and X registers may be modified by this or future implementations
                                        (0128) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0129) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0130) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0131) ;    functions.
                                        (0132) ;
                                        (0133)  TX8_1_DisableInt:
                                        (0134) _TX8_1_DisableInt:
                                        (0135)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0136)    M8C_DisableIntMask TX8_1_INT_REG, TX8_1_bINT_MASK
                                        (0137)    RAM_EPILOGUE RAM_USE_CLASS_1
05FA: 7F       RET                      (0138)    ret
05FB: 71 10    OR    F,0x10             
                                        (0139) .ENDSECTION
                                        (0140) 
                                        (0141) .SECTION
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) ;  FUNCTION NAME: TX8_1_SetTxIntMode(BYTE bTxIntMode)
                                        (0144) ;
                                        (0145) ;  DESCRIPTION:
                                        (0146) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                        (0147) ;
                                        (0148) ;  ARGUMENTS:
                                        (0149) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                        (0150) ;        Passed in the A register
                                        (0151) ;
                                        (0152) ;  RETURNS:
                                        (0153) ;     none.
                                        (0154) ;
                                        (0155) ;  SIDE EFFECTS:
                                        (0156) ;    The A and X registers may be modified by this or future implementations
                                        (0157) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0158) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0159) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0160) ;    functions.
                                        (0161) ;
                                        (0162) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0163) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                        (0164) ;     on TX register empty or TX transmit complete
                                        (0165) ;
                                        (0166)  TX8_1_SetTxIntMode:
                                        (0167) _TX8_1_SetTxIntMode:
                                        (0168)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0169)    M8C_SetBank1
05FD: 21 01    AND   A,0x1              (0170)    and   A, TX8_1_INT_MODE_TX_COMPLETE
05FF: A0 07    JZ    0x0607             (0171)    jz    .SetModeRegEmpty
0601: 43 4C 10 OR    REG[0x4C],0x10     (0172)    or    REG[TX8_1_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
0604: 70 EF    AND   F,0xEF             
                                        (0173)    M8C_SetBank0
                                        (0174)    RAM_EPILOGUE RAM_USE_CLASS_1
0606: 7F       RET                      (0175)    ret
                                        (0176) 
                                        (0177) .SetModeRegEmpty:
0607: 41 4C EF AND   REG[0x4C],0xEF     (0178)    and   REG[TX8_1_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
060A: 70 EF    AND   F,0xEF             
                                        (0179)    M8C_SetBank0
                                        (0180)    RAM_EPILOGUE RAM_USE_CLASS_1
060C: 7F       RET                      (0181)    ret
                                        (0182) .ENDSECTION
                                        (0183) 
                                        (0184) .SECTION
                                        (0185) ;-----------------------------------------------------------------------------
                                        (0186) ;  FUNCTION NAME: TX8_1_Start(BYTE bParity)
                                        (0187) ;
                                        (0188) ;  DESCRIPTION:
                                        (0189) ;     Sets the start bit and parity in the Control register of this user module.
                                        (0190) ;     The transmitter will begin transmitting if a byte has been written into the
                                        (0191) ;     transmit buffer.
                                        (0192) ;
                                        (0193) ;-----------------------------------------------------------------------------
                                        (0194) ;
                                        (0195) ;  ARGUMENTS:
                                        (0196) ;    BYTE bParity - parity of transmitted data.  Use defined masks.
                                        (0197) ;
                                        (0198) ;  RETURNS:  none
                                        (0199) ;
                                        (0200) ;  SIDE EFFECTS:
                                        (0201) ;    The A and X registers may be modified by this or future implementations
                                        (0202) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0203) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0204) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0205) ;    functions.
                                        (0206) ;
                                        (0207)  TX8_1_Start:
                                        (0208) _TX8_1_Start:
                                        (0209)    RAM_PROLOGUE RAM_USE_CLASS_1
060D: 29 01    OR    A,0x1              (0210)    or    A, bfCONTROL_REG_START_BIT
060F: 60 4F    MOV   REG[0x4F],A        (0211)    mov   REG[TX8_1_CONTROL_REG], A
                                        (0212)    RAM_EPILOGUE RAM_USE_CLASS_1
0611: 7F       RET                      (0213)    ret
                                        (0214) .ENDSECTION
                                        (0215) 
                                        (0216) .SECTION
                                        (0217) ;-----------------------------------------------------------------------------
                                        (0218) ;  FUNCTION NAME: TX8_1_Stop
                                        (0219) ;
                                        (0220) ;  DESCRIPTION:
                                        (0221) ;     Disables TX8 operation.
                                        (0222) ;
                                        (0223) ;-----------------------------------------------------------------------------
                                        (0224) ;
                                        (0225) ;  ARGUMENTS:  none
                                        (0226) ;
                                        (0227) ;  RETURNS:  none
                                        (0228) ;
                                        (0229) ;  SIDE EFFECTS:
                                        (0230) ;    The A and X registers may be modified by this or future implementations
                                        (0231) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0232) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0233) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0234) ;    functions.
                                        (0235) ;
                                        (0236)  TX8_1_Stop:
                                        (0237) _TX8_1_Stop:
                                        (0238)    RAM_PROLOGUE RAM_USE_CLASS_1
0612: 41 4F FE AND   REG[0x4F],0xFE     (0239)    and   REG[TX8_1_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                        (0240)    RAM_EPILOGUE RAM_USE_CLASS_1
0615: 7F       RET                      (0241)    ret
                                        (0242) .ENDSECTION
                                        (0243) 
                                        (0244) .SECTION
                                        (0245) ;-----------------------------------------------------------------------------
                                        (0246) ;  FUNCTION NAME: TX8_1_SendData
                                        (0247) ;
                                        (0248) ;  DESCRIPTION:
                                        (0249) ;     Sends one byte through serial port.
                                        (0250) ;
                                        (0251) ;-----------------------------------------------------------------------------
                                        (0252) ;
                                        (0253) ;  ARGUMENTS:
                                        (0254) ;     BYTE  TxData - data to transmit.
                                        (0255) ;
                                        (0256) ;  RETURNS:
                                        (0257) ;
                                        (0258) ;  SIDE EFFECTS:
                                        (0259) ;    The A and X registers may be modified by this or future implementations
                                        (0260) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0261) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0262) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0263) ;    functions.
                                        (0264) ;
                                        (0265)  TX8_1_SendData:
                                        (0266) _TX8_1_SendData:
                                        (0267)    RAM_PROLOGUE RAM_USE_CLASS_1
0616: 60 4D    MOV   REG[0x4D],A        (0268)    mov REG[TX8_1_TX_BUFFER_REG], A
                                        (0269)    RAM_EPILOGUE RAM_USE_CLASS_1
0618: 7F       RET                      (0270)    ret
                                        (0271) .ENDSECTION
                                        (0272) 
                                        (0273) .SECTION
                                        (0274) ;-----------------------------------------------------------------------------
                                        (0275) ;  FUNCTION NAME: TX8_1_bReadTxStatus
                                        (0276) ;
                                        (0277) ;  DESCRIPTION:
                                        (0278) ;     Reads the Tx Status bits in the Control/Status register.
                                        (0279) ;
                                        (0280) ;-----------------------------------------------------------------------------
                                        (0281) ;
                                        (0282) ;  ARGUMENTS:
                                        (0283) ;
                                        (0284) ;  RETURNS:
                                        (0285) ;     BYTE  bTxStatus - transmit status data.  Use the following defined bits
                                        (0286) ;                       masks: TX_COMPLETE and TX_BUFFER_EMPTY
                                        (0287) ;
                                        (0288) ;  SIDE EFFECTS:
                                        (0289) ;    The A and X registers may be modified by this or future implementations
                                        (0290) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0291) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0292) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0293) ;    functions.
                                        (0294) ;
                                        (0295)  TX8_1_bReadTxStatus:
                                        (0296) _TX8_1_bReadTxStatus:
                                        (0297)  bTX8_1_ReadTxStatus:
                                        (0298) _bTX8_1_ReadTxStatus:
                                        (0299)    RAM_PROLOGUE RAM_USE_CLASS_1
0619: 5D 4F    MOV   A,REG[0x4F]        (0300)    mov A,  REG[TX8_1_CONTROL_REG]
                                        (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
061B: 7F       RET                      (0302)    ret
                                        (0303) 
                                        (0304) .ENDSECTION
                                        (0305) 
                                        (0306) ;-----------------------------------------------------------------------------
                                        (0307) ;  FUNCTION NAME: TX8_1_PutSHexByte
                                        (0308) ;
                                        (0309) ;  DESCRIPTION:
                                        (0310) ;     Print a byte in Hex (two characters) to the UART Tx
                                        (0311) ;
                                        (0312) ;  ARGUMENTS:
                                        (0313) ;     A  => (BYTE) Data/char to be printed
                                        (0314) ;
                                        (0315) ;  RETURNS:
                                        (0316) ;     none.
                                        (0317) ;
                                        (0318) ;  SIDE EFFECTS:
                                        (0319) ;    The A and X registers may be modified by this or future implementations
                                        (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0323) ;    functions.
                                        (0324) ;
                                        (0325) .LITERAL
                                        (0326) TX8_1_HEX_STR:
                                        (0327)      DS    "0123456789ABCDEF"
                                        (0328) .ENDLITERAL
                                        (0329) 
                                        (0330) .SECTION
                                        (0331)  TX8_1_PutSHexByte:
                                        (0332) _TX8_1_PutSHexByte:
                                        (0333)     RAM_PROLOGUE RAM_USE_CLASS_1
062C: 08       PUSH  A                  (0334)     push  A                            ; Save lower nibble
062D: 67       ASR   A                  (0335)     asr   A                            ; Shift high nibble to right
062E: 67       ASR   A                  (0336)     asr   A
062F: 67       ASR   A                  (0337)     asr   A
0630: 67       ASR   A                  (0338)     asr   A
0631: 21 0F    AND   A,0xF              (0339)     and   A,0Fh                        ; Mask off nibble
0633: FF E7    INDEX 0x061C             (0340)     index TX8_1_HEX_STR                ; Get Hex value
0635: 90 0F    CALL  _TX8_1_PutChar     (0341)     call  TX8_1_PutChar                ; Write data to screen
0637: 18       POP   A                  (0342)     pop   A                            ; Restore value
0638: 21 0F    AND   A,0xF              (0343)     and   A,0Fh                        ; Mask off lower nibble
063A: FF E0    INDEX 0x061C             (0344)     index TX8_1_HEX_STR                ; Get Hex value
063C: 90 08    CALL  _TX8_1_PutChar     (0345)     call  TX8_1_PutChar                ; Write data to screen
                                        (0346)     RAM_EPILOGUE RAM_USE_CLASS_1
063E: 7F       RET                      (0347)     ret
                                        (0348) .ENDSECTION
                                        (0349) 
                                        (0350) .SECTION
                                        (0351) ;-----------------------------------------------------------------------------
                                        (0352) ;  FUNCTION NAME: TX8_1_PutSHexInt
                                        (0353) ;
                                        (0354) ;  DESCRIPTION:
                                        (0355) ;     Print an Int in Hex (four characters) to UART Tx
                                        (0356) ;
                                        (0357) ;  ARGUMENTS:
                                        (0358) ;     Pointer to string
                                        (0359) ;     A  => ASB of Int
                                        (0360) ;     X  => MSB of Int
                                        (0361) ;
                                        (0362) ;  RETURNS:
                                        (0363) ;     none.
                                        (0364) ;
                                        (0365) ;  SIDE EFFECTS:
                                        (0366) ;    The A and X registers may be modified by this or future implementations
                                        (0367) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0368) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0369) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0370) ;    functions.
                                        (0371) ;
                                        (0372)  TX8_1_PutSHexInt:
                                        (0373) _TX8_1_PutSHexInt:
                                        (0374)     RAM_PROLOGUE RAM_USE_CLASS_1
063F: 4B       SWAP  A,X                (0375)     swap  A,X
0640: 9F EA    CALL  _TX8_1_PutSHexByte (0376)     call  TX8_1_PutSHexByte            ; Print MSB
0642: 5B       MOV   A,X                (0377)     mov   A,X                          ; Move LSB into position
0643: 9F E7    CALL  _TX8_1_PutSHexByte (0378)     call  TX8_1_PutSHexByte            ; Print LSB
                                        (0379)     RAM_EPILOGUE RAM_USE_CLASS_1
0645: 7F       RET                      (0380)     ret
0646: 49 4F 10 TST   REG[0x4F],0x10     
0649: AF FC    JZ    _TX8_1_PutChar     
064B: 60 4D    MOV   REG[0x4D],A        
                                        (0381) .ENDSECTION
                                        (0382) 
                                        (0383) .SECTION
                                        (0384) ;-----------------------------------------------------------------------------
                                        (0385) ;  FUNCTION NAME: TX8_1_PutChar
                                        (0386) ;
                                        (0387) ;  DESCRIPTION:
                                        (0388) ;     Send character out through UART TX port.
                                        (0389) ;
                                        (0390) ;
                                        (0391) ;  ARGUMENTS:
                                        (0392) ;     A has Character to send to UART Tx Port
                                        (0393) ;
                                        (0394) ;  RETURNS:
                                        (0395) ;     none
                                        (0396) ;
                                        (0397) ;  SIDE EFFECTS:
                                        (0398) ;    The A and X registers may be modified by this or future implementations
                                        (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0402) ;    functions.
                                        (0403) ;
                                        (0404)    macro InLinePutChar( Source )
                                        (0405) .BufEmptyWaitLoop:
                                        (0406)    tst REG[TX8_1_CONTROL_REG], TX8_1_TX_BUFFER_EMPTY    ; Check Tx Status
                                        (0407)    jz  .BufEmptyWaitLoop
                                        (0408)    mov REG[TX8_1_TX_BUFFER_REG], @Source    ; Write data to Tx Port
                                        (0409)    endm
                                        (0410) 
                                        (0411) 
                                        (0412)  TX8_1_PutChar:
                                        (0413) _TX8_1_PutChar:
                                        (0414)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0415)    InLinePutChar A
                                        (0416)    RAM_EPILOGUE RAM_USE_CLASS_1
064D: 7F       RET                      (0417)    ret
064E: 70 BF    AND   F,0xBF             
0650: 60 D3    MOV   REG[0xD3],A        
                                        (0418) 
                                        (0419) .ENDSECTION
                                        (0420) 
                                        (0421) 
                                        (0422) ;-----------------------------------------------
                                        (0423) ;  High Level TX functions
                                        (0424) ;-----------------------------------------------
                                        (0425) 
                                        (0426) 
                                        (0427) .SECTION
                                        (0428) ;-----------------------------------------------------------------------------
                                        (0429) ;  FUNCTION NAME: TX8_1_PutString
                                        (0430) ;
                                        (0431) ;  DESCRIPTION:
                                        (0432) ;     Send String out through UART TX port.
                                        (0433) ;
                                        (0434) ;
                                        (0435) ;  ARGUMENTS:
                                        (0436) ;     Pointer to String
                                        (0437) ;     A has MSB of string address
                                        (0438) ;     X has LSB of string address
                                        (0439) ;
                                        (0440) ;  RETURNS:
                                        (0441) ;     none
                                        (0442) ;
                                        (0443) ;  SIDE EFFECTS:
                                        (0444) ;    The A and X registers may be modified by this or future implementations
                                        (0445) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0446) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0447) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0448) ;    functions.
                                        (0449) ;          
                                        (0450) ;    Currently only the page pointer registers listed below are modified: 
                                        (0451) ;          IDX_PP
                                        (0452) ;
                                        (0453)  TX8_1_PutString:
                                        (0454) _TX8_1_PutString:
                                        (0455)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0456)    RAM_SETPAGE_IDX A
                                        (0457) .PutStringLoop:
0652: 52 00    MOV   A,[X+0]            (0458)    mov   A,[X]                             ; Get value pointed to by X
0654: A0 06    JZ    0x065B             (0459)    jz    End_PutString                     ; Check for end of string
0656: 9F EE    CALL  _TX8_1_PutChar     (0460)    call  TX8_1_PutChar                      ; Send character to Tx port
0658: 75       INC   X                  (0461)    inc   X                                 ; Advance pointer to next character
0659: 8F F8    JMP   0x0652             (0462)    jmp   .PutStringLoop                     ; Get next character
065B: 70 3F    AND   F,0x3F             
065D: 71 C0    OR    F,0xC0             
                                        (0463) 
                                        (0464) End_PutString:
                                        (0465)    RAM_EPILOGUE RAM_USE_CLASS_3
065F: 7F       RET                      (0466)    ret
0660: 70 BF    AND   F,0xBF             
0662: 62 D3 07 MOV   REG[0xD3],0x7      
                                        (0467) .ENDSECTION
                                        (0468) 
                                        (0469) .SECTION
                                        (0470) ;-----------------------------------------------------------------------------
                                        (0471) ;  FUNCTION NAME: TX8_1_Write
                                        (0472) ;
                                        (0473) ;  DESCRIPTION:
                                        (0474) ;     Send String of length X to serial port
                                        (0475) ;
                                        (0476) ;
                                        (0477) ;  ARGUMENTS:
                                        (0478) ;     Pointer to String
                                        (0479) ;     [SP-5] Count of characters to send
                                        (0480) ;     [SP-4] has MSB of string address
                                        (0481) ;     [SP-3] has LSB of string address
                                        (0482) ;
                                        (0483) ;  RETURNS:
                                        (0484) ;     none
                                        (0485) ;
                                        (0486) ;  SIDE EFFECTS:
                                        (0487) ;    The A and X registers may be modified by this or future implementations
                                        (0488) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0489) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0490) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0491) ;    functions.
                                        (0492) ;          
                                        (0493) ;    Currently only the page pointer registers listed below are modified: 
                                        (0494) ;          IDX_PP
                                        (0495) ;
                                        (0496) CNT_LEN:    equ -5           ; Length of data to send
                                        (0497) STR_MSB:    equ -4           ; MSB pointer of string
                                        (0498) STR_LSB:    equ -3           ; LSB pointer of string
                                        (0499) 
                                        (0500)  TX8_1_Write:
                                        (0501) _TX8_1_Write:
                                        (0502)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0503)    RAM_SETPAGE_IDX2STK
0665: 4F       MOV   X,SP               (0504)    mov   X, SP
                                        (0505) 
                                        (0506) .NextByteLoop:
0666: 52 FB    MOV   A,[X-5]            (0507)    mov   A,[X+CNT_LEN]                     ; Get length of string to send
0668: A0 1A    JZ    0x0683             (0508)    jz    .End_Write
066A: 7B FB    DEC   [X-5]              (0509)    dec   [X+CNT_LEN]                       ; Decrement counter
                                        (0510) 
                                        (0511)    IF SYSTEM_LARGE_MEMORY_MODEL
066C: 52 FC    MOV   A,[X-4]            (0512)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
                                        (0513)    ENDIF
                                        (0514) 
066E: 59 FD    MOV   X,[X-3]            (0515)    mov   X,[X+STR_LSB]                     ; Get character to send
0670: 60 D3    MOV   REG[0xD3],A        
                                        (0516)    RAM_SETPAGE_IDX A                        ; switch index pages
0672: 52 00    MOV   A,[X+0]            (0517)    mov   A,[X]
0674: 49 4F 10 TST   REG[0x4F],0x10     
0677: AF FC    JZ    0x0674             
0679: 60 4D    MOV   REG[0x4D],A        
                                        (0518)    InLinePutChar A                          ; Send character to UART
067B: 4F       MOV   X,SP               (0519)    mov   X, SP
067C: 62 D3 07 MOV   REG[0xD3],0x7      
                                        (0520)    RAM_SETPAGE_IDX2STK
067F: 77 FD    INC   [X-3]              (0521)    inc   [X+STR_LSB]
0681: 8F E4    JMP   0x0666             (0522)    jmp   .NextByteLoop
0683: 70 3F    AND   F,0x3F             
0685: 71 C0    OR    F,0xC0             
                                        (0523) 
                                        (0524) .End_Write:
                                        (0525)    RAM_EPILOGUE RAM_USE_CLASS_3
0687: 7F       RET                      (0526)    ret
                                        (0527) .ENDSECTION
                                        (0528) 
                                        (0529) .SECTION
                                        (0530) ;-----------------------------------------------------------------------------
                                        (0531) ;  FUNCTION NAME: TX8_1_CWrite
                                        (0532) ;
                                        (0533) ;             WARNING WARNING NOT COMPLETE
                                        (0534) ;
                                        (0535) ;  DESCRIPTION:
                                        (0536) ;     Send String of length X to serial port
                                        (0537) ;
                                        (0538) ;  ARGUMENTS:
                                        (0539) ;     Pointer to String
                                        (0540) ;     [SP-6] MSB of Count of character to send
                                        (0541) ;     [SP-5] LSB of Count of character to send
                                        (0542) ;     [SP-4] has MSB of string address
                                        (0543) ;     [SP-3] has LSB of string address
                                        (0544) ;
                                        (0545) ;  RETURNS:
                                        (0546) ;     none
                                        (0547) ;
                                        (0548) ;  SIDE EFFECTS:
                                        (0549) ;    The A and X registers may be modified by this or future implementations
                                        (0550) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0551) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0552) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0553) ;    functions.
                                        (0554) ;
                                        (0555) CLEN_MSB:   equ -6           ; MSB Length of data to send
                                        (0556) CLEN_LSB:   equ -5           ; LSB Length of data to send
                                        (0557) CSTR_MSB:   equ -4           ; MSB pointer of string
                                        (0558) CSTR_LSB:   equ -3           ; LSB pointer of string
                                        (0559) 
                                        (0560)  TX8_1_CWrite:
                                        (0561) _TX8_1_CWrite:
                                        (0562)    RAM_PROLOGUE RAM_USE_CLASS_2
0688: 4F       MOV   X,SP               (0563)    mov   X,SP
                                        (0564) 
                                        (0565) .CW_Loop:
                                        (0566)                                              ; Check for zero counter
0689: 3D FA 00 CMP   [X-6],0x0          (0567)    cmp   [X+CLEN_MSB],0x00
068C: B0 06    JNZ   0x0693             (0568)    jnz   .CW_WRITEIT
068E: 3D FB 00 CMP   [X-5],0x0          (0569)    cmp   [X+CLEN_LSB],0x00
0691: A0 1D    JZ    0x06AF             (0570)    jz    .End_CWrite                         ; Leave if done
                                        (0571) 
                                        (0572) .CW_WRITEIT:                                 ; Save pointers
0693: 10       PUSH  X                  (0573)    push  X
0694: 52 FC    MOV   A,[X-4]            (0574)    mov   A,[X+CSTR_MSB]
0696: 59 FD    MOV   X,[X-3]            (0575)    mov   X,[X+CSTR_LSB]
0698: 28       ROMX                     (0576)    romx                                     ; Get character from ROM
0699: 49 4F 10 TST   REG[0x4F],0x10     
069C: AF FC    JZ    0x0699             
069E: 60 4D    MOV   REG[0x4D],A        
                                        (0577)    InLinePutChar A
06A0: 20       POP   X                  (0578)    pop   X
                                        (0579) 
06A1: 07 FD 01 ADD   [X-3],0x1          (0580)    add   [X+CSTR_LSB],1                     ; Increment the string pointer
06A4: 0F FC 00 ADC   [X-4],0x0          (0581)    adc   [X+CSTR_MSB],0
                                        (0582) 
                                        (0583)                                             ; Dec the counter
06A7: 17 FB 01 SUB   [X-5],0x1          (0584)    sub   [X+CLEN_LSB],0x01
06AA: 1F FA 00 SBB   [X-6],0x0          (0585)    sbb   [X+CLEN_MSB],0x00
                                        (0586) 
06AD: 8F DB    JMP   0x0689             (0587)    jmp   .CW_Loop
                                        (0588) 
                                        (0589) .End_CWrite:
                                        (0590)    RAM_EPILOGUE RAM_USE_CLASS_1
06AF: 7F       RET                      (0591)    ret
                                        (0592) .ENDSECTION
                                        (0593) 
                                        (0594) .SECTION
                                        (0595) ;-----------------------------------------------------------------------------
                                        (0596) ;  FUNCTION NAME: TX8_1_CPutString
                                        (0597) ;
                                        (0598) ;  DESCRIPTION:
                                        (0599) ;     Send String out through UART TX port.
                                        (0600) ;
                                        (0601) ;
                                        (0602) ;  ARGUMENTS:
                                        (0603) ;     Pointer to String
                                        (0604) ;     A has MSB of string address
                                        (0605) ;     X has LSB of string address
                                        (0606) ;
                                        (0607) ;  RETURNS:
                                        (0608) ;     none
                                        (0609) ;
                                        (0610) ;  SIDE EFFECTS:
                                        (0611) ;    The A and X registers may be modified by this or future implementations
                                        (0612) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0613) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0614) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0615) ;    functions.
                                        (0616) ;
                                        (0617)  TX8_1_CPutString:
                                        (0618) _TX8_1_CPutString:
                                        (0619)    RAM_PROLOGUE RAM_USE_CLASS_1   
06B0: 08       PUSH  A                  (0620)    push  A                                       ; Store ROM pointer
06B1: 10       PUSH  X                  (0621)    push  X
06B2: 28       ROMX                     (0622)    romx                                          ; Get character from ROM
06B3: A0 0B    JZ    0x06BF             (0623)    jz    .End_CPutString
06B5: 9F 8F    CALL  _TX8_1_PutChar     (0624)    call  TX8_1_PutChar                      ; Print character
06B7: 20       POP   X                  (0625)    pop   X
06B8: 18       POP   A                  (0626)    pop   A
06B9: 75       INC   X                  (0627)    inc   X                                       ; Inc LSB of pointer
06BA: DF F5    JNC   _TX8_1_CPutString  (0628)    jnc   TX8_1_CPutString                        ; Check for carry
06BC: 74       INC   A                  (0629)    inc   A                                       ; Inc MSB of pointer
06BD: 8F F2    JMP   _TX8_1_CPutString  (0630)    jmp   TX8_1_CPutString
                                        (0631) 
                                        (0632) 
                                        (0633) .End_CPutString:
06BF: 38 FE    ADD   SP,0xFE            (0634)    add   SP, -2
                                        (0635)    RAM_EPILOGUE RAM_USE_CLASS_1
06C1: 7F       RET                      (0636)    ret
                                        (0637) .ENDSECTION
                                        (0638) 
                                        (0639) .SECTION
                                        (0640) ;-----------------------------------------------------------------------------
                                        (0641) ;  FUNCTION NAME: TX8_1_PutCRLF
                                        (0642) ;
                                        (0643) ;  DESCRIPTION:
                                        (0644) ;     Send a CR and LF
                                        (0645) ;
                                        (0646) ;  ARGUMENTS:
                                        (0647) ;     none.
                                        (0648) ;
                                        (0649) ;  RETURNS:
                                        (0650) ;     none.
                                        (0651) ;
                                        (0652) ;  SIDE EFFECTS:
                                        (0653) ;    The A and X registers may be modified by this or future implementations
                                        (0654) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0655) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0656) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0657) ;    functions.
                                        (0658) ;
                                        (0659)  TX8_1_PutCRLF:
                                        (0660) _TX8_1_PutCRLF:
                                        (0661)    RAM_PROLOGUE RAM_USE_CLASS_1
06C2: 50 0D    MOV   A,0xD              (0662)    mov  A,0x0D                        ; Send CR
06C4: 9F 80    CALL  _TX8_1_PutChar     (0663)    call TX8_1_PutChar
06C6: 50 0A    MOV   A,0xA              (0664)    mov  A,0x0A                        ; Send LF
06C8: 9F 7C    CALL  _TX8_1_PutChar     (0665)    call TX8_1_PutChar
                                        (0666)    RAM_EPILOGUE RAM_USE_CLASS_1
06CA: 7F       RET                      (0667)    ret
                                        (0668) .ENDSECTION
                                        (0669) 
                                        (0670) ; End of File TX8_1.asm
FILE: lib\timer16_2.asm                 (0001) ;;*****************************************************************************
06CB: 43 E1 40 OR    REG[0xE1],0x40     (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: Timer16_2.asm
                                        (0004) ;;   Version: 2.6, Updated on 2012/3/2 at 9:15:25
                                        (0005) ;;  Generated by PSoC Designer 5.2.2551
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "Timer16_2.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  Timer16_2_EnableInt
                                        (0030) export _Timer16_2_EnableInt
                                        (0031) export  Timer16_2_DisableInt
                                        (0032) export _Timer16_2_DisableInt
                                        (0033) export  Timer16_2_Start
                                        (0034) export _Timer16_2_Start
                                        (0035) export  Timer16_2_Stop
                                        (0036) export _Timer16_2_Stop
                                        (0037) export  Timer16_2_WritePeriod
                                        (0038) export _Timer16_2_WritePeriod
                                        (0039) export  Timer16_2_WriteCompareValue
                                        (0040) export _Timer16_2_WriteCompareValue
                                        (0041) export  Timer16_2_wReadCompareValue
                                        (0042) export _Timer16_2_wReadCompareValue
                                        (0043) export  Timer16_2_wReadTimer
                                        (0044) export _Timer16_2_wReadTimer
                                        (0045) export  Timer16_2_wReadTimerSaveCV
                                        (0046) export _Timer16_2_wReadTimerSaveCV
                                        (0047) 
                                        (0048) ; The following functions are deprecated and subject to omission in future releases
                                        (0049) ;
                                        (0050) export  wTimer16_2_ReadCompareValue  ; deprecated
                                        (0051) export _wTimer16_2_ReadCompareValue  ; deprecated
                                        (0052) export  wTimer16_2_ReadTimer         ; deprecated
                                        (0053) export _wTimer16_2_ReadTimer         ; deprecated
                                        (0054) export  wTimer16_2_ReadTimerSaveCV   ; deprecated
                                        (0055) export _wTimer16_2_ReadTimerSaveCV   ; deprecated
                                        (0056) 
                                        (0057) export  wTimer16_2_ReadCounter       ; obsolete
                                        (0058) export _wTimer16_2_ReadCounter       ; obsolete
                                        (0059) export  wTimer16_2_CaptureCounter    ; obsolete
                                        (0060) export _wTimer16_2_CaptureCounter    ; obsolete
                                        (0061) 
                                        (0062) 
                                        (0063) AREA time_test_RAM (RAM,REL)
                                        (0064) 
                                        (0065) ;-----------------------------------------------
                                        (0066) ;  Constant Definitions
                                        (0067) ;-----------------------------------------------
                                        (0068) 
                                        (0069) 
                                        (0070) ;-----------------------------------------------
                                        (0071) ; Variable Allocation
                                        (0072) ;-----------------------------------------------
                                        (0073) 
                                        (0074) 
                                        (0075) AREA UserModules (ROM, REL)
                                        (0076) 
                                        (0077) .SECTION
                                        (0078) ;-----------------------------------------------------------------------------
                                        (0079) ;  FUNCTION NAME: Timer16_2_EnableInt
                                        (0080) ;
                                        (0081) ;  DESCRIPTION:
                                        (0082) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
                                        (0083) ;     associated with this User Module. This function has no effect until and
                                        (0084) ;     unless the global interrupts are enabled (for example by using the
                                        (0085) ;     macro M8C_EnableGInt).
                                        (0086) ;-----------------------------------------------------------------------------
                                        (0087) ;
                                        (0088) ;  ARGUMENTS:    None.
                                        (0089) ;  RETURNS:      Nothing.
                                        (0090) ;  SIDE EFFECTS: 
                                        (0091) ;    The A and X registers may be modified by this or future implementations
                                        (0092) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0093) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0094) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0095) ;    functions.
                                        (0096) ;
                                        (0097)  Timer16_2_EnableInt:
                                        (0098) _Timer16_2_EnableInt:
                                        (0099)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0100)    Timer16_2_EnableInt_M
                                        (0101)    RAM_EPILOGUE RAM_USE_CLASS_1
06CE: 7F       RET                      (0102)    ret
06CF: 41 E1 BF AND   REG[0xE1],0xBF     
                                        (0103) 
                                        (0104) .ENDSECTION
                                        (0105) 
                                        (0106) 
                                        (0107) .SECTION
                                        (0108) ;-----------------------------------------------------------------------------
                                        (0109) ;  FUNCTION NAME: Timer16_2_DisableInt
                                        (0110) ;
                                        (0111) ;  DESCRIPTION:
                                        (0112) ;     Disables this timer's interrupt by clearing the interrupt enable
                                        (0113) ;     mask bit associated with this User Module.
                                        (0114) ;-----------------------------------------------------------------------------
                                        (0115) ;
                                        (0116) ;  ARGUMENTS:    None
                                        (0117) ;  RETURNS:      Nothing
                                        (0118) ;  SIDE EFFECTS: 
                                        (0119) ;    The A and X registers may be modified by this or future implementations
                                        (0120) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0121) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0122) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0123) ;    functions.
                                        (0124) ;
                                        (0125)  Timer16_2_DisableInt:
                                        (0126) _Timer16_2_DisableInt:
                                        (0127)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0128)    Timer16_2_DisableInt_M
                                        (0129)    RAM_EPILOGUE RAM_USE_CLASS_1
06D2: 7F       RET                      (0130)    ret
06D3: 43 37 01 OR    REG[0x37],0x1      
                                        (0131) 
                                        (0132) .ENDSECTION
                                        (0133) 
                                        (0134) 
                                        (0135) .SECTION
                                        (0136) ;-----------------------------------------------------------------------------
                                        (0137) ;  FUNCTION NAME: Timer16_2_Start
                                        (0138) ;
                                        (0139) ;  DESCRIPTION:
                                        (0140) ;     Sets the start bit in the Control register of this user module.  The
                                        (0141) ;     timer will begin counting on the next input clock.
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) ;
                                        (0144) ;  ARGUMENTS:    None
                                        (0145) ;  RETURNS:      Nothing
                                        (0146) ;  SIDE EFFECTS: 
                                        (0147) ;    The A and X registers may be modified by this or future implementations
                                        (0148) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0149) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0150) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0151) ;    functions.
                                        (0152) ;
                                        (0153)  Timer16_2_Start:
                                        (0154) _Timer16_2_Start:
                                        (0155)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0156)    Timer16_2_Start_M
                                        (0157)    RAM_EPILOGUE RAM_USE_CLASS_1
06D6: 7F       RET                      (0158)    ret
06D7: 41 37 FE AND   REG[0x37],0xFE     
                                        (0159) 
                                        (0160) .ENDSECTION
                                        (0161) 
                                        (0162) 
                                        (0163) .SECTION
                                        (0164) ;-----------------------------------------------------------------------------
                                        (0165) ;  FUNCTION NAME: Timer16_2_Stop
                                        (0166) ;
                                        (0167) ;  DESCRIPTION:
                                        (0168) ;     Disables timer operation by clearing the start bit in the Control
                                        (0169) ;     register of the LSB block.
                                        (0170) ;-----------------------------------------------------------------------------
                                        (0171) ;
                                        (0172) ;  ARGUMENTS:    None
                                        (0173) ;  RETURNS:      Nothing
                                        (0174) ;  SIDE EFFECTS: 
                                        (0175) ;    The A and X registers may be modified by this or future implementations
                                        (0176) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0177) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0178) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0179) ;    functions.
                                        (0180) ;
                                        (0181)  Timer16_2_Stop:
                                        (0182) _Timer16_2_Stop:
                                        (0183)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0184)    Timer16_2_Stop_M
                                        (0185)    RAM_EPILOGUE RAM_USE_CLASS_1
06DA: 7F       RET                      (0186)    ret
                                        (0187) 
                                        (0188) .ENDSECTION
                                        (0189) 
                                        (0190) 
                                        (0191) .SECTION
                                        (0192) ;-----------------------------------------------------------------------------
                                        (0193) ;  FUNCTION NAME: Timer16_2_WritePeriod
                                        (0194) ;
                                        (0195) ;  DESCRIPTION:
                                        (0196) ;     Write the 16-bit period value into the Period register (DR1). If the
                                        (0197) ;     Timer user module is stopped, then this value will also be latched
                                        (0198) ;     into the Count register (DR0).
                                        (0199) ;-----------------------------------------------------------------------------
                                        (0200) ;
                                        (0201) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                        (0202) ;  RETURNS:   Nothing
                                        (0203) ;  SIDE EFFECTS:
                                        (0204) ;    The A and X registers may be modified by this or future implementations
                                        (0205) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0206) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0207) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0208) ;    functions.
                                        (0209) ;
                                        (0210)  Timer16_2_WritePeriod:
                                        (0211) _Timer16_2_WritePeriod:
                                        (0212)    RAM_PROLOGUE RAM_USE_CLASS_1
06DB: 60 35    MOV   REG[0x35],A        (0213)    mov   reg[Timer16_2_PERIOD_LSB_REG], A
06DD: 5B       MOV   A,X                (0214)    mov   A, X
06DE: 60 39    MOV   REG[0x39],A        (0215)    mov   reg[Timer16_2_PERIOD_MSB_REG], A
                                        (0216)    RAM_EPILOGUE RAM_USE_CLASS_1
06E0: 7F       RET                      (0217)    ret
                                        (0218) 
                                        (0219) .ENDSECTION
                                        (0220) 
                                        (0221) 
                                        (0222) .SECTION
                                        (0223) ;-----------------------------------------------------------------------------
                                        (0224) ;  FUNCTION NAME: Timer16_2_WriteCompareValue
                                        (0225) ;
                                        (0226) ;  DESCRIPTION:
                                        (0227) ;     Writes compare value into the Compare register (DR2).
                                        (0228) ;
                                        (0229) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                        (0230) ;           Compare register. (Call Timer16_2_Stop to disable).
                                        (0231) ;-----------------------------------------------------------------------------
                                        (0232) ;
                                        (0233) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
                                        (0234) ;  RETURNS:      Nothing
                                        (0235) ;  SIDE EFFECTS: 
                                        (0236) ;    The A and X registers may be modified by this or future implementations
                                        (0237) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0238) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0239) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0240) ;    functions.
                                        (0241) ;
                                        (0242)  Timer16_2_WriteCompareValue:
                                        (0243) _Timer16_2_WriteCompareValue:
                                        (0244)    RAM_PROLOGUE RAM_USE_CLASS_1
06E1: 60 36    MOV   REG[0x36],A        (0245)    mov   reg[Timer16_2_COMPARE_LSB_REG], A
06E3: 5B       MOV   A,X                (0246)    mov   A, X
06E4: 60 3A    MOV   REG[0x3A],A        (0247)    mov   reg[Timer16_2_COMPARE_MSB_REG], A
                                        (0248)    RAM_EPILOGUE RAM_USE_CLASS_1
06E6: 7F       RET                      (0249)    ret
                                        (0250) 
                                        (0251) .ENDSECTION
                                        (0252) 
                                        (0253) 
                                        (0254) .SECTION
                                        (0255) ;-----------------------------------------------------------------------------
                                        (0256) ;  FUNCTION NAME: Timer16_2_wReadCompareValue
                                        (0257) ;
                                        (0258) ;  DESCRIPTION:
                                        (0259) ;     Reads the Compare registers.
                                        (0260) ;-----------------------------------------------------------------------------
                                        (0261) ;
                                        (0262) ;  ARGUMENTS:    None
                                        (0263) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                        (0264) ;  SIDE EFFECTS: 
                                        (0265) ;    The A and X registers may be modified by this or future implementations
                                        (0266) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0267) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0268) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0269) ;    functions.
                                        (0270) ;
                                        (0271)  Timer16_2_wReadCompareValue:
                                        (0272) _Timer16_2_wReadCompareValue:
                                        (0273)  wTimer16_2_ReadCompareValue:                    ; this name deprecated
                                        (0274) _wTimer16_2_ReadCompareValue:                    ; this name deprecated
                                        (0275)    RAM_PROLOGUE RAM_USE_CLASS_1
06E7: 5D 3A    MOV   A,REG[0x3A]        (0276)    mov   A, reg[Timer16_2_COMPARE_MSB_REG]
06E9: 5C       MOV   X,A                (0277)    mov   X, A
06EA: 5D 36    MOV   A,REG[0x36]        (0278)    mov   A, reg[Timer16_2_COMPARE_LSB_REG]
                                        (0279)    RAM_EPILOGUE RAM_USE_CLASS_1
06EC: 7F       RET                      (0280)    ret
                                        (0281) 
                                        (0282) .ENDSECTION
                                        (0283) 
                                        (0284) 
                                        (0285) .SECTION
                                        (0286) ;-----------------------------------------------------------------------------
                                        (0287) ;  FUNCTION NAME: Timer16_2_wReadTimerSaveCV
                                        (0288) ;
                                        (0289) ;  DESCRIPTION:
                                        (0290) ;     Returns the value in the Count register (DR0), preserving the
                                        (0291) ;     value in the compare register (DR2).
                                        (0292) ;-----------------------------------------------------------------------------
                                        (0293) ;
                                        (0294) ;  ARGUMENTS: None
                                        (0295) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                        (0296) ;  SIDE EFFECTS:
                                        (0297) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                        (0298) ;     2) If enabled, Global interrupts are momentarily disabled.
                                        (0299) ;     3) The user module is stopped momentarily while the compare value is
                                        (0300) ;        restored.  This may cause the Count register to miss one or more
                                        (0301) ;        counts depending on the input clock speed.
                                        (0302) ;     4) The A and X registers may be modified by this or future implementations
                                        (0303) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0304) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0305) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0306) ;        functions.
                                        (0307) ;
                                        (0308) ;  THEORY of OPERATION:
                                        (0309) ;     1) Read and save the Compare register.
                                        (0310) ;     2) Read the Count register, causing its data to be latched into
                                        (0311) ;        the Compare register.
                                        (0312) ;     3) Read and save the Counter value, now in the Compare register,
                                        (0313) ;        to the buffer.
                                        (0314) ;     4) Disable global interrupts
                                        (0315) ;     5) Halt the timer
                                        (0316) ;     6) Restore the Compare register values
                                        (0317) ;     7) Start the Timer again
                                        (0318) ;     8) Restore global interrupt state
                                        (0319) ;
                                        (0320)  Timer16_2_wReadTimerSaveCV:
                                        (0321) _Timer16_2_wReadTimerSaveCV:
                                        (0322)  wTimer16_2_ReadTimerSaveCV:                     ; this name deprecated
                                        (0323) _wTimer16_2_ReadTimerSaveCV:                     ; this name deprecated
                                        (0324)  wTimer16_2_ReadCounter:                         ; this name deprecated
                                        (0325) _wTimer16_2_ReadCounter:                         ; this name deprecated
                                        (0326) 
                                        (0327) CpuFlags:      equ   0
                                        (0328) wCount_MSB:    equ   1
                                        (0329) wCount_LSB:    equ   2
                                        (0330) 
                                        (0331)    RAM_PROLOGUE RAM_USE_CLASS_2
06ED: 4F       MOV   X,SP               (0332)    mov   X, SP                                   ; X <- stack frame pointer
06EE: 38 03    ADD   SP,0x3             (0333)    add   SP, 3                                   ; Reserve space for flags, count
06F0: 5D 37    MOV   A,REG[0x37]        (0334)    mov   A, reg[Timer16_2_CONTROL_LSB_REG]       ; save the Control register
06F2: 08       PUSH  A                  (0335)    push  A
06F3: 5D 36    MOV   A,REG[0x36]        (0336)    mov   A, reg[Timer16_2_COMPARE_LSB_REG]       ; save the Compare register
06F5: 08       PUSH  A                  (0337)    push  A
06F6: 5D 3A    MOV   A,REG[0x3A]        (0338)    mov   A, reg[Timer16_2_COMPARE_MSB_REG]
06F8: 08       PUSH  A                  (0339)    push  A
06F9: 5D 34    MOV   A,REG[0x34]        (0340)    mov   A, reg[Timer16_2_COUNTER_LSB_REG]       ; synchronous copy DR2 <- DR0
                                        (0341)                                                  ; This may cause an interrupt!
06FB: 5D 3A    MOV   A,REG[0x3A]        (0342)    mov   A, reg[Timer16_2_COMPARE_MSB_REG]       ; Now grab DR2 (DR0) and save
06FD: 54 01    MOV   [X+1],A            (0343)    mov   [X+wCount_MSB], A
06FF: 5D 36    MOV   A,REG[0x36]        (0344)    mov   A, reg[Timer16_2_COMPARE_LSB_REG]
0701: 54 02    MOV   [X+2],A            (0345)    mov   [X+wCount_LSB], A
0703: 50 00    MOV   A,0x0              (0346)    mov   A, 0                                    ; Guess the global interrupt state
0705: 49 F7 01 TST   REG[0xF7],0x1      (0347)    tst   reg[CPU_F], FLAG_GLOBAL_IE              ; Currently Disabled?
0708: A0 03    JZ    0x070C             (0348)    jz    .SetupStatusFlag                        ;   Yes, guess was correct
070A: 50 01    MOV   A,0x1              (0349)    mov   A, FLAG_GLOBAL_IE                       ;    No, modify our guess
                                        (0350) .SetupStatusFlag:                                ; and ...
070C: 54 00    MOV   [X+0],A            (0351)    mov   [X+CpuFlags], A                         ;   StackFrame[0] <- Flag Reg image
070E: 70 FE    AND   F,0xFE             
0710: 41 37 FE AND   REG[0x37],0xFE     
                                        (0352)    M8C_DisableGInt                               ; Disable interrupts globally
                                        (0353)    Timer16_2_Stop_M                              ; Disable (stop) the timer
0713: 18       POP   A                  (0354)    pop   A                                       ; Restore the Compare register
0714: 60 3A    MOV   REG[0x3A],A        (0355)    mov   reg[Timer16_2_COMPARE_MSB_REG], A
0716: 18       POP   A                  (0356)    pop   A
0717: 60 36    MOV   REG[0x36],A        (0357)    mov   reg[Timer16_2_COMPARE_LSB_REG], A
0719: 18       POP   A                  (0358)    pop   A                                       ; restore start state of the timer
071A: 60 37    MOV   REG[0x37],A        (0359)    mov   reg[Timer16_2_CONTROL_LSB_REG], A
071C: 18       POP   A                  (0360)    pop   A                                       ; Return result stored in stack frame
071D: 20       POP   X                  (0361)    pop   X
071E: 70 3F    AND   F,0x3F             
0720: 71 C0    OR    F,0xC0             
                                        (0362)    RAM_EPILOGUE RAM_USE_CLASS_2
0722: 7E       RETI                     (0363)    reti                                          ; Flag Reg <- StackFrame[0]
                                        (0364) 
                                        (0365) .ENDSECTION
                                        (0366) 
                                        (0367) 
                                        (0368) .SECTION
                                        (0369) ;-----------------------------------------------------------------------------
                                        (0370) ;  FUNCTION NAME: Timer16_2_wReadTimer
                                        (0371) ;
                                        (0372) ;  DESCRIPTION:
                                        (0373) ;     Performs a software capture of the Count register.  A synchronous
                                        (0374) ;     read of the Count register is performed.  The timer is NOT stopped.
                                        (0375) ;
                                        (0376) ;     WARNING - this will cause loss of data in the Compare register.
                                        (0377) ;-----------------------------------------------------------------------------
                                        (0378) ;
                                        (0379) ;  ARGUMENTS:    None
                                        (0380) ;  RETURNS:      fastcall16 WORD wCount, (value of DR0 in the X & A registers)
                                        (0381) ;  SIDE EFFECTS:
                                        (0382) ;    May cause an interrupt.
                                        (0383) ;
                                        (0384) ;    The A and X registers may be modified by this or future implementations
                                        (0385) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0386) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0387) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0388) ;    functions.
                                        (0389) ;
                                        (0390) ;  THEORY of OPERATION:
                                        (0391) ;     1) Read the Count register - this causes the count value to be
                                        (0392) ;        latched into the Compare registers.
                                        (0393) ;     2) Read and return the Count register values from the Compare
                                        (0394) ;        registers into the return buffer.
                                        (0395) ;
                                        (0396)  Timer16_2_wReadTimer:
                                        (0397) _Timer16_2_wReadTimer:
                                        (0398)  wTimer16_2_ReadTimer:                           ; this name deprecated
                                        (0399) _wTimer16_2_ReadTimer:                           ; this name deprecated
                                        (0400)  wTimer16_2_CaptureCounter:                      ; this name deprecated
                                        (0401) _wTimer16_2_CaptureCounter:                      ; this name deprecated
                                        (0402) 
                                        (0403)    RAM_PROLOGUE RAM_USE_CLASS_1
0723: 5D 34    MOV   A,REG[0x34]        (0404)    mov   A, reg[Timer16_2_COUNTER_LSB_REG]       ; synchronous copy DR2 <- DR0
                                        (0405)                                                  ; This may cause an interrupt!
                                        (0406) 
0725: 5D 3A    MOV   A,REG[0x3A]        (0407)    mov   A, reg[Timer16_2_COMPARE_MSB_REG]       ; Return DR2 (actually DR0)
0727: 5C       MOV   X,A                (0408)    mov   X, A
0728: 5D 36    MOV   A,REG[0x36]        (0409)    mov   A, reg[Timer16_2_COMPARE_LSB_REG]
                                        (0410)    RAM_EPILOGUE RAM_USE_CLASS_1
072A: 7F       RET                      (0411)    ret
                                        (0412) 
                                        (0413) .ENDSECTION
                                        (0414) 
                                        (0415) ; End of File Timer16_2.asm
FILE: lib\timer16_1int.asm              (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: Timer16_1INT.asm
                                        (0004) ;;   Version: 2.6, Updated on 2012/3/2 at 9:15:25
                                        (0005) ;;  Generated by PSoC Designer 5.2.2551
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Timer16 Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "memory.inc"
                                        (0015) include "Timer16_1.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _Timer16_1_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _Timer16_1_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _Timer16_1_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070)    
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom assembly code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    
                                        (0075)    ;---------------------------------------------------
                                        (0076)    ; Insert a lcall to a C function below this banner
                                        (0077)    ; and un-comment the lines between these banners
                                        (0078)    ;---------------------------------------------------
                                        (0079)    
                                        (0080)    ;PRESERVE_CPU_CONTEXT
072B: 7D 0D 84 LJMP  _My_t16_1_isr      (0081)    ljmp _My_t16_1_isr
                                        (0082)    ;RESTORE_CPU_CONTEXT
                                        (0083)    
                                        (0084)    ;---------------------------------------------------
                                        (0085)    ; Insert a lcall to a C function above this banner
                                        (0086)    ; and un-comment the lines between these banners
                                        (0087)    ;---------------------------------------------------
                                        (0088)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0089) 
072E: 7E       RETI                     (0090)    reti
                                        (0091) 
                                        (0092) 
                                        (0093) ; end of file Timer16_1INT.asm
FILE: lib\timer16_1.asm                 (0001) ;;*****************************************************************************
072F: 43 E1 08 OR    REG[0xE1],0x8      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: Timer16_1.asm
                                        (0004) ;;   Version: 2.6, Updated on 2012/3/2 at 9:15:25
                                        (0005) ;;  Generated by PSoC Designer 5.2.2551
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "Timer16_1.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  Timer16_1_EnableInt
                                        (0030) export _Timer16_1_EnableInt
                                        (0031) export  Timer16_1_DisableInt
                                        (0032) export _Timer16_1_DisableInt
                                        (0033) export  Timer16_1_Start
                                        (0034) export _Timer16_1_Start
                                        (0035) export  Timer16_1_Stop
                                        (0036) export _Timer16_1_Stop
                                        (0037) export  Timer16_1_WritePeriod
                                        (0038) export _Timer16_1_WritePeriod
                                        (0039) export  Timer16_1_WriteCompareValue
                                        (0040) export _Timer16_1_WriteCompareValue
                                        (0041) export  Timer16_1_wReadCompareValue
                                        (0042) export _Timer16_1_wReadCompareValue
                                        (0043) export  Timer16_1_wReadTimer
                                        (0044) export _Timer16_1_wReadTimer
                                        (0045) export  Timer16_1_wReadTimerSaveCV
                                        (0046) export _Timer16_1_wReadTimerSaveCV
                                        (0047) 
                                        (0048) ; The following functions are deprecated and subject to omission in future releases
                                        (0049) ;
                                        (0050) export  wTimer16_1_ReadCompareValue  ; deprecated
                                        (0051) export _wTimer16_1_ReadCompareValue  ; deprecated
                                        (0052) export  wTimer16_1_ReadTimer         ; deprecated
                                        (0053) export _wTimer16_1_ReadTimer         ; deprecated
                                        (0054) export  wTimer16_1_ReadTimerSaveCV   ; deprecated
                                        (0055) export _wTimer16_1_ReadTimerSaveCV   ; deprecated
                                        (0056) 
                                        (0057) export  wTimer16_1_ReadCounter       ; obsolete
                                        (0058) export _wTimer16_1_ReadCounter       ; obsolete
                                        (0059) export  wTimer16_1_CaptureCounter    ; obsolete
                                        (0060) export _wTimer16_1_CaptureCounter    ; obsolete
                                        (0061) 
                                        (0062) 
                                        (0063) AREA time_test_RAM (RAM,REL)
                                        (0064) 
                                        (0065) ;-----------------------------------------------
                                        (0066) ;  Constant Definitions
                                        (0067) ;-----------------------------------------------
                                        (0068) 
                                        (0069) 
                                        (0070) ;-----------------------------------------------
                                        (0071) ; Variable Allocation
                                        (0072) ;-----------------------------------------------
                                        (0073) 
                                        (0074) 
                                        (0075) AREA UserModules (ROM, REL)
                                        (0076) 
                                        (0077) .SECTION
                                        (0078) ;-----------------------------------------------------------------------------
                                        (0079) ;  FUNCTION NAME: Timer16_1_EnableInt
                                        (0080) ;
                                        (0081) ;  DESCRIPTION:
                                        (0082) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
                                        (0083) ;     associated with this User Module. This function has no effect until and
                                        (0084) ;     unless the global interrupts are enabled (for example by using the
                                        (0085) ;     macro M8C_EnableGInt).
                                        (0086) ;-----------------------------------------------------------------------------
                                        (0087) ;
                                        (0088) ;  ARGUMENTS:    None.
                                        (0089) ;  RETURNS:      Nothing.
                                        (0090) ;  SIDE EFFECTS: 
                                        (0091) ;    The A and X registers may be modified by this or future implementations
                                        (0092) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0093) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0094) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0095) ;    functions.
                                        (0096) ;
                                        (0097)  Timer16_1_EnableInt:
                                        (0098) _Timer16_1_EnableInt:
                                        (0099)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0100)    Timer16_1_EnableInt_M
                                        (0101)    RAM_EPILOGUE RAM_USE_CLASS_1
0732: 7F       RET                      (0102)    ret
0733: 41 E1 F7 AND   REG[0xE1],0xF7     
                                        (0103) 
                                        (0104) .ENDSECTION
                                        (0105) 
                                        (0106) 
                                        (0107) .SECTION
                                        (0108) ;-----------------------------------------------------------------------------
                                        (0109) ;  FUNCTION NAME: Timer16_1_DisableInt
                                        (0110) ;
                                        (0111) ;  DESCRIPTION:
                                        (0112) ;     Disables this timer's interrupt by clearing the interrupt enable
                                        (0113) ;     mask bit associated with this User Module.
                                        (0114) ;-----------------------------------------------------------------------------
                                        (0115) ;
                                        (0116) ;  ARGUMENTS:    None
                                        (0117) ;  RETURNS:      Nothing
                                        (0118) ;  SIDE EFFECTS: 
                                        (0119) ;    The A and X registers may be modified by this or future implementations
                                        (0120) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0121) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0122) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0123) ;    functions.
                                        (0124) ;
                                        (0125)  Timer16_1_DisableInt:
                                        (0126) _Timer16_1_DisableInt:
                                        (0127)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0128)    Timer16_1_DisableInt_M
                                        (0129)    RAM_EPILOGUE RAM_USE_CLASS_1
0736: 7F       RET                      (0130)    ret
0737: 43 2B 01 OR    REG[0x2B],0x1      
                                        (0131) 
                                        (0132) .ENDSECTION
                                        (0133) 
                                        (0134) 
                                        (0135) .SECTION
                                        (0136) ;-----------------------------------------------------------------------------
                                        (0137) ;  FUNCTION NAME: Timer16_1_Start
                                        (0138) ;
                                        (0139) ;  DESCRIPTION:
                                        (0140) ;     Sets the start bit in the Control register of this user module.  The
                                        (0141) ;     timer will begin counting on the next input clock.
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) ;
                                        (0144) ;  ARGUMENTS:    None
                                        (0145) ;  RETURNS:      Nothing
                                        (0146) ;  SIDE EFFECTS: 
                                        (0147) ;    The A and X registers may be modified by this or future implementations
                                        (0148) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0149) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0150) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0151) ;    functions.
                                        (0152) ;
                                        (0153)  Timer16_1_Start:
                                        (0154) _Timer16_1_Start:
                                        (0155)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0156)    Timer16_1_Start_M
                                        (0157)    RAM_EPILOGUE RAM_USE_CLASS_1
073A: 7F       RET                      (0158)    ret
073B: 41 2B FE AND   REG[0x2B],0xFE     
                                        (0159) 
                                        (0160) .ENDSECTION
                                        (0161) 
                                        (0162) 
                                        (0163) .SECTION
                                        (0164) ;-----------------------------------------------------------------------------
                                        (0165) ;  FUNCTION NAME: Timer16_1_Stop
                                        (0166) ;
                                        (0167) ;  DESCRIPTION:
                                        (0168) ;     Disables timer operation by clearing the start bit in the Control
                                        (0169) ;     register of the LSB block.
                                        (0170) ;-----------------------------------------------------------------------------
                                        (0171) ;
                                        (0172) ;  ARGUMENTS:    None
                                        (0173) ;  RETURNS:      Nothing
                                        (0174) ;  SIDE EFFECTS: 
                                        (0175) ;    The A and X registers may be modified by this or future implementations
                                        (0176) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0177) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0178) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0179) ;    functions.
                                        (0180) ;
                                        (0181)  Timer16_1_Stop:
                                        (0182) _Timer16_1_Stop:
                                        (0183)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0184)    Timer16_1_Stop_M
                                        (0185)    RAM_EPILOGUE RAM_USE_CLASS_1
073E: 7F       RET                      (0186)    ret
                                        (0187) 
                                        (0188) .ENDSECTION
                                        (0189) 
                                        (0190) 
                                        (0191) .SECTION
                                        (0192) ;-----------------------------------------------------------------------------
                                        (0193) ;  FUNCTION NAME: Timer16_1_WritePeriod
                                        (0194) ;
                                        (0195) ;  DESCRIPTION:
                                        (0196) ;     Write the 16-bit period value into the Period register (DR1). If the
                                        (0197) ;     Timer user module is stopped, then this value will also be latched
                                        (0198) ;     into the Count register (DR0).
                                        (0199) ;-----------------------------------------------------------------------------
                                        (0200) ;
                                        (0201) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                        (0202) ;  RETURNS:   Nothing
                                        (0203) ;  SIDE EFFECTS:
                                        (0204) ;    The A and X registers may be modified by this or future implementations
                                        (0205) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0206) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0207) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0208) ;    functions.
                                        (0209) ;
                                        (0210)  Timer16_1_WritePeriod:
                                        (0211) _Timer16_1_WritePeriod:
                                        (0212)    RAM_PROLOGUE RAM_USE_CLASS_1
073F: 60 29    MOV   REG[0x29],A        (0213)    mov   reg[Timer16_1_PERIOD_LSB_REG], A
0741: 5B       MOV   A,X                (0214)    mov   A, X
0742: 60 2D    MOV   REG[0x2D],A        (0215)    mov   reg[Timer16_1_PERIOD_MSB_REG], A
                                        (0216)    RAM_EPILOGUE RAM_USE_CLASS_1
0744: 7F       RET                      (0217)    ret
                                        (0218) 
                                        (0219) .ENDSECTION
                                        (0220) 
                                        (0221) 
                                        (0222) .SECTION
                                        (0223) ;-----------------------------------------------------------------------------
                                        (0224) ;  FUNCTION NAME: Timer16_1_WriteCompareValue
                                        (0225) ;
                                        (0226) ;  DESCRIPTION:
                                        (0227) ;     Writes compare value into the Compare register (DR2).
                                        (0228) ;
                                        (0229) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                        (0230) ;           Compare register. (Call Timer16_1_Stop to disable).
                                        (0231) ;-----------------------------------------------------------------------------
                                        (0232) ;
                                        (0233) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
                                        (0234) ;  RETURNS:      Nothing
                                        (0235) ;  SIDE EFFECTS: 
                                        (0236) ;    The A and X registers may be modified by this or future implementations
                                        (0237) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0238) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0239) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0240) ;    functions.
                                        (0241) ;
                                        (0242)  Timer16_1_WriteCompareValue:
                                        (0243) _Timer16_1_WriteCompareValue:
                                        (0244)    RAM_PROLOGUE RAM_USE_CLASS_1
0745: 60 2A    MOV   REG[0x2A],A        (0245)    mov   reg[Timer16_1_COMPARE_LSB_REG], A
0747: 5B       MOV   A,X                (0246)    mov   A, X
0748: 60 2E    MOV   REG[0x2E],A        (0247)    mov   reg[Timer16_1_COMPARE_MSB_REG], A
                                        (0248)    RAM_EPILOGUE RAM_USE_CLASS_1
074A: 7F       RET                      (0249)    ret
                                        (0250) 
                                        (0251) .ENDSECTION
                                        (0252) 
                                        (0253) 
                                        (0254) .SECTION
                                        (0255) ;-----------------------------------------------------------------------------
                                        (0256) ;  FUNCTION NAME: Timer16_1_wReadCompareValue
                                        (0257) ;
                                        (0258) ;  DESCRIPTION:
                                        (0259) ;     Reads the Compare registers.
                                        (0260) ;-----------------------------------------------------------------------------
                                        (0261) ;
                                        (0262) ;  ARGUMENTS:    None
                                        (0263) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                        (0264) ;  SIDE EFFECTS: 
                                        (0265) ;    The A and X registers may be modified by this or future implementations
                                        (0266) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0267) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0268) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0269) ;    functions.
                                        (0270) ;
                                        (0271)  Timer16_1_wReadCompareValue:
                                        (0272) _Timer16_1_wReadCompareValue:
                                        (0273)  wTimer16_1_ReadCompareValue:                    ; this name deprecated
                                        (0274) _wTimer16_1_ReadCompareValue:                    ; this name deprecated
                                        (0275)    RAM_PROLOGUE RAM_USE_CLASS_1
074B: 5D 2E    MOV   A,REG[0x2E]        (0276)    mov   A, reg[Timer16_1_COMPARE_MSB_REG]
074D: 5C       MOV   X,A                (0277)    mov   X, A
074E: 5D 2A    MOV   A,REG[0x2A]        (0278)    mov   A, reg[Timer16_1_COMPARE_LSB_REG]
                                        (0279)    RAM_EPILOGUE RAM_USE_CLASS_1
0750: 7F       RET                      (0280)    ret
                                        (0281) 
                                        (0282) .ENDSECTION
                                        (0283) 
                                        (0284) 
                                        (0285) .SECTION
                                        (0286) ;-----------------------------------------------------------------------------
                                        (0287) ;  FUNCTION NAME: Timer16_1_wReadTimerSaveCV
                                        (0288) ;
                                        (0289) ;  DESCRIPTION:
                                        (0290) ;     Returns the value in the Count register (DR0), preserving the
                                        (0291) ;     value in the compare register (DR2).
                                        (0292) ;-----------------------------------------------------------------------------
                                        (0293) ;
                                        (0294) ;  ARGUMENTS: None
                                        (0295) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                        (0296) ;  SIDE EFFECTS:
                                        (0297) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                        (0298) ;     2) If enabled, Global interrupts are momentarily disabled.
                                        (0299) ;     3) The user module is stopped momentarily while the compare value is
                                        (0300) ;        restored.  This may cause the Count register to miss one or more
                                        (0301) ;        counts depending on the input clock speed.
                                        (0302) ;     4) The A and X registers may be modified by this or future implementations
                                        (0303) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0304) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0305) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0306) ;        functions.
                                        (0307) ;
                                        (0308) ;  THEORY of OPERATION:
                                        (0309) ;     1) Read and save the Compare register.
                                        (0310) ;     2) Read the Count register, causing its data to be latched into
                                        (0311) ;        the Compare register.
                                        (0312) ;     3) Read and save the Counter value, now in the Compare register,
                                        (0313) ;        to the buffer.
                                        (0314) ;     4) Disable global interrupts
                                        (0315) ;     5) Halt the timer
                                        (0316) ;     6) Restore the Compare register values
                                        (0317) ;     7) Start the Timer again
                                        (0318) ;     8) Restore global interrupt state
                                        (0319) ;
                                        (0320)  Timer16_1_wReadTimerSaveCV:
                                        (0321) _Timer16_1_wReadTimerSaveCV:
                                        (0322)  wTimer16_1_ReadTimerSaveCV:                     ; this name deprecated
                                        (0323) _wTimer16_1_ReadTimerSaveCV:                     ; this name deprecated
                                        (0324)  wTimer16_1_ReadCounter:                         ; this name deprecated
                                        (0325) _wTimer16_1_ReadCounter:                         ; this name deprecated
                                        (0326) 
                                        (0327) CpuFlags:      equ   0
                                        (0328) wCount_MSB:    equ   1
                                        (0329) wCount_LSB:    equ   2
                                        (0330) 
                                        (0331)    RAM_PROLOGUE RAM_USE_CLASS_2
0751: 4F       MOV   X,SP               (0332)    mov   X, SP                                   ; X <- stack frame pointer
0752: 38 03    ADD   SP,0x3             (0333)    add   SP, 3                                   ; Reserve space for flags, count
0754: 5D 2B    MOV   A,REG[0x2B]        (0334)    mov   A, reg[Timer16_1_CONTROL_LSB_REG]       ; save the Control register
0756: 08       PUSH  A                  (0335)    push  A
0757: 5D 2A    MOV   A,REG[0x2A]        (0336)    mov   A, reg[Timer16_1_COMPARE_LSB_REG]       ; save the Compare register
0759: 08       PUSH  A                  (0337)    push  A
075A: 5D 2E    MOV   A,REG[0x2E]        (0338)    mov   A, reg[Timer16_1_COMPARE_MSB_REG]
075C: 08       PUSH  A                  (0339)    push  A
075D: 5D 28    MOV   A,REG[0x28]        (0340)    mov   A, reg[Timer16_1_COUNTER_LSB_REG]       ; synchronous copy DR2 <- DR0
                                        (0341)                                                  ; This may cause an interrupt!
075F: 5D 2E    MOV   A,REG[0x2E]        (0342)    mov   A, reg[Timer16_1_COMPARE_MSB_REG]       ; Now grab DR2 (DR0) and save
0761: 54 01    MOV   [X+1],A            (0343)    mov   [X+wCount_MSB], A
0763: 5D 2A    MOV   A,REG[0x2A]        (0344)    mov   A, reg[Timer16_1_COMPARE_LSB_REG]
0765: 54 02    MOV   [X+2],A            (0345)    mov   [X+wCount_LSB], A
0767: 50 00    MOV   A,0x0              (0346)    mov   A, 0                                    ; Guess the global interrupt state
0769: 49 F7 01 TST   REG[0xF7],0x1      (0347)    tst   reg[CPU_F], FLAG_GLOBAL_IE              ; Currently Disabled?
076C: A0 03    JZ    0x0770             (0348)    jz    .SetupStatusFlag                        ;   Yes, guess was correct
076E: 50 01    MOV   A,0x1              (0349)    mov   A, FLAG_GLOBAL_IE                       ;    No, modify our guess
                                        (0350) .SetupStatusFlag:                                ; and ...
0770: 54 00    MOV   [X+0],A            (0351)    mov   [X+CpuFlags], A                         ;   StackFrame[0] <- Flag Reg image
0772: 70 FE    AND   F,0xFE             
0774: 41 2B FE AND   REG[0x2B],0xFE     
                                        (0352)    M8C_DisableGInt                               ; Disable interrupts globally
                                        (0353)    Timer16_1_Stop_M                              ; Disable (stop) the timer
0777: 18       POP   A                  (0354)    pop   A                                       ; Restore the Compare register
0778: 60 2E    MOV   REG[0x2E],A        (0355)    mov   reg[Timer16_1_COMPARE_MSB_REG], A
077A: 18       POP   A                  (0356)    pop   A
077B: 60 2A    MOV   REG[0x2A],A        (0357)    mov   reg[Timer16_1_COMPARE_LSB_REG], A
077D: 18       POP   A                  (0358)    pop   A                                       ; restore start state of the timer
077E: 60 2B    MOV   REG[0x2B],A        (0359)    mov   reg[Timer16_1_CONTROL_LSB_REG], A
0780: 18       POP   A                  (0360)    pop   A                                       ; Return result stored in stack frame
0781: 20       POP   X                  (0361)    pop   X
0782: 70 3F    AND   F,0x3F             
0784: 71 C0    OR    F,0xC0             
                                        (0362)    RAM_EPILOGUE RAM_USE_CLASS_2
0786: 7E       RETI                     (0363)    reti                                          ; Flag Reg <- StackFrame[0]
                                        (0364) 
                                        (0365) .ENDSECTION
                                        (0366) 
                                        (0367) 
                                        (0368) .SECTION
                                        (0369) ;-----------------------------------------------------------------------------
                                        (0370) ;  FUNCTION NAME: Timer16_1_wReadTimer
                                        (0371) ;
                                        (0372) ;  DESCRIPTION:
                                        (0373) ;     Performs a software capture of the Count register.  A synchronous
                                        (0374) ;     read of the Count register is performed.  The timer is NOT stopped.
                                        (0375) ;
                                        (0376) ;     WARNING - this will cause loss of data in the Compare register.
                                        (0377) ;-----------------------------------------------------------------------------
                                        (0378) ;
                                        (0379) ;  ARGUMENTS:    None
                                        (0380) ;  RETURNS:      fastcall16 WORD wCount, (value of DR0 in the X & A registers)
                                        (0381) ;  SIDE EFFECTS:
                                        (0382) ;    May cause an interrupt.
                                        (0383) ;
                                        (0384) ;    The A and X registers may be modified by this or future implementations
                                        (0385) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0386) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0387) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0388) ;    functions.
                                        (0389) ;
                                        (0390) ;  THEORY of OPERATION:
                                        (0391) ;     1) Read the Count register - this causes the count value to be
                                        (0392) ;        latched into the Compare registers.
                                        (0393) ;     2) Read and return the Count register values from the Compare
                                        (0394) ;        registers into the return buffer.
                                        (0395) ;
                                        (0396)  Timer16_1_wReadTimer:
                                        (0397) _Timer16_1_wReadTimer:
                                        (0398)  wTimer16_1_ReadTimer:                           ; this name deprecated
                                        (0399) _wTimer16_1_ReadTimer:                           ; this name deprecated
                                        (0400)  wTimer16_1_CaptureCounter:                      ; this name deprecated
                                        (0401) _wTimer16_1_CaptureCounter:                      ; this name deprecated
                                        (0402) 
                                        (0403)    RAM_PROLOGUE RAM_USE_CLASS_1
0787: 5D 28    MOV   A,REG[0x28]        (0404)    mov   A, reg[Timer16_1_COUNTER_LSB_REG]       ; synchronous copy DR2 <- DR0
                                        (0405)                                                  ; This may cause an interrupt!
                                        (0406) 
0789: 5D 2E    MOV   A,REG[0x2E]        (0407)    mov   A, reg[Timer16_1_COMPARE_MSB_REG]       ; Return DR2 (actually DR0)
078B: 5C       MOV   X,A                (0408)    mov   X, A
078C: 5D 2A    MOV   A,REG[0x2A]        (0409)    mov   A, reg[Timer16_1_COMPARE_LSB_REG]
                                        (0410)    RAM_EPILOGUE RAM_USE_CLASS_1
078E: 7F       RET                      (0411)    ret
                                        (0412) 
                                        (0413) .ENDSECTION
                                        (0414) 
                                        (0415) ; End of File Timer16_1.asm
FILE: lib\pwm8_2.asm                    (0001) ;;*****************************************************************************
078F: 43 DF 02 OR    REG[0xDF],0x2      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: PWM8_2.asm
                                        (0004) ;;   Version: 2.60, Updated on 2012/3/2 at 9:15:10
                                        (0005) ;;  Generated by PSoC Designer 5.2.2551
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM8 User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "PWM8_2.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  PWM8_2_EnableInt
                                        (0030) export _PWM8_2_EnableInt
                                        (0031) export  PWM8_2_DisableInt
                                        (0032) export _PWM8_2_DisableInt
                                        (0033) export  PWM8_2_Start
                                        (0034) export _PWM8_2_Start
                                        (0035) export  PWM8_2_Stop
                                        (0036) export _PWM8_2_Stop
                                        (0037) export  PWM8_2_WritePeriod
                                        (0038) export _PWM8_2_WritePeriod
                                        (0039) export  PWM8_2_WritePulseWidth
                                        (0040) export _PWM8_2_WritePulseWidth
                                        (0041) export  PWM8_2_bReadPulseWidth
                                        (0042) export _PWM8_2_bReadPulseWidth
                                        (0043) export  PWM8_2_bReadCounter
                                        (0044) export _PWM8_2_bReadCounter
                                        (0045) 
                                        (0046) ; The following functions are deprecated and subject to omission in future releases
                                        (0047) ;
                                        (0048) export  bPWM8_2_ReadPulseWidth    ; deprecated
                                        (0049) export _bPWM8_2_ReadPulseWidth    ; deprecated
                                        (0050) export  bPWM8_2_ReadCounter       ; deprecated
                                        (0051) export _bPWM8_2_ReadCounter       ; deprecated
                                        (0052) 
                                        (0053) 
                                        (0054) AREA time_test_RAM (RAM,REL)
                                        (0055) 
                                        (0056) ;-----------------------------------------------
                                        (0057) ;  Constant Definitions
                                        (0058) ;-----------------------------------------------
                                        (0059) 
                                        (0060) INPUT_REG_NULL:                equ 0x00    ; Clear the input register
                                        (0061) 
                                        (0062) 
                                        (0063) ;-----------------------------------------------
                                        (0064) ; Variable Allocation
                                        (0065) ;-----------------------------------------------
                                        (0066) 
                                        (0067) 
                                        (0068) AREA UserModules (ROM, REL)
                                        (0069) 
                                        (0070) .SECTION
                                        (0071) ;-----------------------------------------------------------------------------
                                        (0072) ;  FUNCTION NAME: PWM8_2_EnableInt
                                        (0073) ;
                                        (0074) ;  DESCRIPTION:
                                        (0075) ;     Enables this PWM's interrupt by setting the interrupt enable mask bit
                                        (0076) ;     associated with this User Module. This function has no effect until and
                                        (0077) ;     unless the global interrupts are enabled (for example by using the
                                        (0078) ;     macro M8C_EnableGInt).
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ;
                                        (0081) ;  ARGUMENTS:    None.
                                        (0082) ;  RETURNS:      Nothing.
                                        (0083) ;  SIDE EFFECTS:
                                        (0084) ;    The A and X registers may be modified by this or future implementations
                                        (0085) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0086) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0087) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0088) ;    functions.
                                        (0089) ;
                                        (0090)  PWM8_2_EnableInt:
                                        (0091) _PWM8_2_EnableInt:
                                        (0092)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0093)    PWM8_2_EnableInt_M
                                        (0094)    RAM_EPILOGUE RAM_USE_CLASS_1
0792: 7F       RET                      (0095)    ret
0793: 41 DF FD AND   REG[0xDF],0xFD     
                                        (0096) 
                                        (0097) 
                                        (0098) .ENDSECTION
                                        (0099) 
                                        (0100) .SECTION
                                        (0101) ;-----------------------------------------------------------------------------
                                        (0102) ;  FUNCTION NAME: PWM8_2_DisableInt
                                        (0103) ;
                                        (0104) ;  DESCRIPTION:
                                        (0105) ;     Disables this PWM's interrupt by clearing the interrupt enable
                                        (0106) ;     mask bit associated with this User Module.
                                        (0107) ;-----------------------------------------------------------------------------
                                        (0108) ;
                                        (0109) ;  ARGUMENTS:    None
                                        (0110) ;  RETURNS:      Nothing
                                        (0111) ;  SIDE EFFECTS:
                                        (0112) ;    The A and X registers may be modified by this or future implementations
                                        (0113) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0114) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0115) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0116) ;    functions.
                                        (0117) ;
                                        (0118)  PWM8_2_DisableInt:
                                        (0119) _PWM8_2_DisableInt:
                                        (0120)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0121)    PWM8_2_DisableInt_M
                                        (0122)    RAM_EPILOGUE RAM_USE_CLASS_1
0796: 7F       RET                      (0123)    ret
0797: 43 47 01 OR    REG[0x47],0x1      
                                        (0124) 
                                        (0125) 
                                        (0126) .ENDSECTION
                                        (0127) 
                                        (0128) .SECTION
                                        (0129) ;-----------------------------------------------------------------------------
                                        (0130) ;  FUNCTION NAME: PWM8_2_Start
                                        (0131) ;
                                        (0132) ;  DESCRIPTION:
                                        (0133) ;     Sets the start bit in the Control register of this user module.  The
                                        (0134) ;     PWM will begin counting on the next input clock as soon as the
                                        (0135) ;     enable input is asserted high.
                                        (0136) ;-----------------------------------------------------------------------------
                                        (0137) ;
                                        (0138) ;  ARGUMENTS:    None
                                        (0139) ;  RETURNS:      Nothing
                                        (0140) ;  SIDE EFFECTS:
                                        (0141) ;    The A and X registers may be modified by this or future implementations
                                        (0142) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0143) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0144) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0145) ;    functions.
                                        (0146) ;
                                        (0147)  PWM8_2_Start:
                                        (0148) _PWM8_2_Start:
                                        (0149)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0150)    PWM8_2_Start_M
                                        (0151)    RAM_EPILOGUE RAM_USE_CLASS_1
079A: 7F       RET                      (0152)    ret
079B: 41 47 FE AND   REG[0x47],0xFE     
                                        (0153) 
                                        (0154) 
                                        (0155) .ENDSECTION
                                        (0156) 
                                        (0157) .SECTION
                                        (0158) ;-----------------------------------------------------------------------------
                                        (0159) ;  FUNCTION NAME: PWM8_2_Stop
                                        (0160) ;
                                        (0161) ;  DESCRIPTION:
                                        (0162) ;     Disables PWM operation by clearing the start bit in the Control
                                        (0163) ;     register.
                                        (0164) ;-----------------------------------------------------------------------------
                                        (0165) ;
                                        (0166) ;  ARGUMENTS:    None
                                        (0167) ;  RETURNS:      Nothing
                                        (0168) ;  SIDE EFFECTS:
                                        (0169) ;    The A and X registers may be modified by this or future implementations
                                        (0170) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0171) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0172) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0173) ;    functions.
                                        (0174) ;
                                        (0175)  PWM8_2_Stop:
                                        (0176) _PWM8_2_Stop:
                                        (0177)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0178)    PWM8_2_Stop_M
                                        (0179)    RAM_EPILOGUE RAM_USE_CLASS_1
079E: 7F       RET                      (0180)    ret
                                        (0181) 
                                        (0182) 
                                        (0183) .ENDSECTION
                                        (0184) 
                                        (0185) .SECTION
                                        (0186) ;-----------------------------------------------------------------------------
                                        (0187) ;  FUNCTION NAME: PWM8_2_WritePeriod
                                        (0188) ;
                                        (0189) ;  DESCRIPTION:
                                        (0190) ;     Write the 8-bit period value into the Period register (DR1).
                                        (0191) ;-----------------------------------------------------------------------------
                                        (0192) ;
                                        (0193) ;  ARGUMENTS: fastcall16 BYTE bPeriodValue (passed in A)
                                        (0194) ;  RETURNS:   Nothing
                                        (0195) ;  SIDE EFFECTS:
                                        (0196) ;    If the PWM user module is stopped, then this value will also be
                                        (0197) ;    latched into the Count register (DR0).
                                        (0198) ;    
                                        (0199) ;    The A and X registers may be modified by this or future implementations
                                        (0200) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0201) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0202) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0203) ;    functions.
                                        (0204) ;
                                        (0205)  PWM8_2_WritePeriod:
                                        (0206) _PWM8_2_WritePeriod:
                                        (0207)    RAM_PROLOGUE RAM_USE_CLASS_1
079F: 60 45    MOV   REG[0x45],A        (0208)    mov   reg[PWM8_2_PERIOD_REG], A
                                        (0209)    RAM_EPILOGUE RAM_USE_CLASS_1
07A1: 7F       RET                      (0210)    ret
                                        (0211) 
                                        (0212) 
                                        (0213) .ENDSECTION
                                        (0214) 
                                        (0215) .SECTION
                                        (0216) ;-----------------------------------------------------------------------------
                                        (0217) ;  FUNCTION NAME: PWM8_2_WritePulseWidth
                                        (0218) ;
                                        (0219) ;  DESCRIPTION:
                                        (0220) ;     Writes compare value into the Compare register (DR2).
                                        (0221) ;-----------------------------------------------------------------------------
                                        (0222) ;
                                        (0223) ;  ARGUMENTS:    fastcall16 BYTE bCompareValue (passed in A)
                                        (0224) ;  RETURNS:      Nothing
                                        (0225) ;  SIDE EFFECTS:
                                        (0226) ;    The A and X registers may be modified by this or future implementations
                                        (0227) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0228) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0229) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0230) ;    functions.
                                        (0231) ;
                                        (0232)  PWM8_2_WritePulseWidth:
                                        (0233) _PWM8_2_WritePulseWidth:
                                        (0234)    RAM_PROLOGUE RAM_USE_CLASS_1
07A2: 60 46    MOV   REG[0x46],A        (0235)    mov   reg[PWM8_2_COMPARE_REG], A
                                        (0236)    RAM_EPILOGUE RAM_USE_CLASS_1
07A4: 7F       RET                      (0237)    ret
                                        (0238) 
                                        (0239) 
                                        (0240) .ENDSECTION
                                        (0241) 
                                        (0242) .SECTION
                                        (0243) ;-----------------------------------------------------------------------------
                                        (0244) ;  FUNCTION NAME: PWM8_2_bReadPulseWidth
                                        (0245) ;
                                        (0246) ;  DESCRIPTION:
                                        (0247) ;     Reads the Compare register.
                                        (0248) ;-----------------------------------------------------------------------------
                                        (0249) ;
                                        (0250) ;  ARGUMENTS:    None
                                        (0251) ;  RETURNS:      fastcall16 BYTE bCompareValue (value of DR2 in the A register)
                                        (0252) ;  SIDE EFFECTS:
                                        (0253) ;    The A and X registers may be modified by this or future implementations
                                        (0254) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0255) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0256) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0257) ;    functions.
                                        (0258) ;
                                        (0259)  PWM8_2_bReadPulseWidth:
                                        (0260) _PWM8_2_bReadPulseWidth:
                                        (0261)  bPWM8_2_ReadPulseWidth:                         ; this name deprecated
                                        (0262) _bPWM8_2_ReadPulseWidth:                         ; this name deprecated
                                        (0263)    RAM_PROLOGUE RAM_USE_CLASS_1
07A5: 5D 46    MOV   A,REG[0x46]        (0264)    mov   A, reg[PWM8_2_COMPARE_REG]
                                        (0265)    RAM_EPILOGUE RAM_USE_CLASS_1
07A7: 7F       RET                      (0266)    ret
                                        (0267) 
                                        (0268) 
                                        (0269) .ENDSECTION
                                        (0270) 
                                        (0271) .SECTION
                                        (0272) ;-----------------------------------------------------------------------------
                                        (0273) ;  FUNCTION NAME: PWM8_2_bReadCounter
                                        (0274) ;
                                        (0275) ;  DESCRIPTION:
                                        (0276) ;     Returns the value in the Count register (DR0), preserving the value in
                                        (0277) ;     the compare register (DR2). Interrupts are prevented during the transfer
                                        (0278) ;     from the Count to the Compare registers by holding the clock low in
                                        (0279) ;     the PSoC block.
                                        (0280) ;-----------------------------------------------------------------------------
                                        (0281) ;
                                        (0282) ;  ARGUMENTS: None
                                        (0283) ;  RETURNS:   fastcall16 BYTE bCount (value of DR0 in the A register)
                                        (0284) ;  SIDE EFFECTS:
                                        (0285) ;     1) The user module is stopped momentarily and one or more counts may be missed.
                                        (0286) ;     2) The A and X registers may be modified by this or future implementations
                                        (0287) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0288) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0289) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0290) ;        functions.
                                        (0291) ;
                                        (0292)  PWM8_2_bReadCounter:
                                        (0293) _PWM8_2_bReadCounter:
                                        (0294)  bPWM8_2_ReadCounter:                            ; this name deprecated
                                        (0295) _bPWM8_2_ReadCounter:                            ; this name deprecated
                                        (0296) 
                                        (0297)    bOrigCompareValue:      EQU   0               ; Frame offset to temp Compare store
                                        (0298)    bOrigClockSetting:      EQU   1               ; Frame offset to temp Input   store
                                        (0299)    wCounter:               EQU   2               ; Frame offset to temp Count   store
                                        (0300)    STACK_FRAME_SIZE:       EQU   3               ; max stack frame size is 3 bytes
                                        (0301) 
                                        (0302)    RAM_PROLOGUE RAM_USE_CLASS_2
07A8: 4F       MOV   X,SP               (0303)    mov   X, SP                                   ; X <- stack frame pointer
07A9: 5D 46    MOV   A,REG[0x46]        (0304)    mov   A, reg[PWM8_2_COMPARE_REG]              ; Save the Compare register on the stack
07AB: 08       PUSH  A                  (0305)    push  A                                       ;
07AC: 41 47 FE AND   REG[0x47],0xFE     
07AF: 71 10    OR    F,0x10             
                                        (0306)    PWM8_2_Stop_M                                 ; Disable (stop) the PWM
                                        (0307)    M8C_SetBank1                                  ;
07B1: 5D 45    MOV   A,REG[0x45]        (0308)    mov   A, reg[PWM8_2_INPUT_REG]                ; save the clock input setting
07B3: 08       PUSH  A                  (0309)    push  A                                       ;   on the stack (now 2 bytes) and ...
                                        (0310)                                                  ;   hold the clock low:
07B4: 62 45 00 MOV   REG[0x45],0x0      (0311)    mov   reg[PWM8_2_INPUT_REG], INPUT_REG_NULL
07B7: 70 EF    AND   F,0xEF             
                                        (0312)    M8C_SetBank0
                                        (0313)                                                  ; Extract the Count via DR2 register
07B9: 5D 44    MOV   A,REG[0x44]        (0314)    mov   A, reg[PWM8_2_COUNTER_REG]              ; DR2 <- DR0
07BB: 5D 46    MOV   A,REG[0x46]        (0315)    mov   A, reg[PWM8_2_COMPARE_REG]              ; Stash the Count on the stack
07BD: 08       PUSH  A                  (0316)    push  A                                       ;  -stack frame is now 3 bytes
07BE: 52 00    MOV   A,[X+0]            (0317)    mov   A, [X+bOrigCompareValue]                ; Restore the Compare register
07C0: 60 46    MOV   REG[0x46],A        (0318)    mov   reg[PWM8_2_COMPARE_REG], A
07C2: 71 10    OR    F,0x10             
                                        (0319)    M8C_SetBank1                                  ; Restore the PWM operation:
07C4: 52 01    MOV   A,[X+1]            (0320)    mov   A, [X+bOrigClockSetting]                ;   First, the clock setting...
07C6: 60 45    MOV   REG[0x45],A        (0321)    mov   reg[PWM8_2_INPUT_REG], A                ;
07C8: 70 EF    AND   F,0xEF             
07CA: 43 47 01 OR    REG[0x47],0x1      
                                        (0322)    M8C_SetBank0                                  ;
                                        (0323)    PWM8_2_Start_M                                ;   then re-enable the PWM.
07CD: 18       POP   A                  (0324)    pop   A                                       ; Setup the return value
07CE: 38 FE    ADD   SP,0xFE            (0325)    ADD   SP, -(STACK_FRAME_SIZE-1)               ; Zap remainder of stack frame
07D0: 70 3F    AND   F,0x3F             
07D2: 71 C0    OR    F,0xC0             
                                        (0326)    RAM_EPILOGUE RAM_USE_CLASS_2
07D4: 7F       RET                      (0327)    ret
                                        (0328) 
                                        (0329) .ENDSECTION
                                        (0330) 
                                        (0331) ; End of File PWM8_2.asm
FILE: lib\pwm8_1int.asm                 (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: PWM8_1INT.asm
                                        (0004) ;;   Version: 2.60, Updated on 2012/3/2 at 9:15:10
                                        (0005) ;;  Generated by PSoC Designer 5.2.2551
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM8 Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "PWM8_1.inc"
                                        (0015) include "memory.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _PWM8_1_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _PWM8_1_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _PWM8_1_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070)    
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom assembly code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    
                                        (0075)    ;---------------------------------------------------
                                        (0076)    ; Insert a lcall to a C function below this banner
                                        (0077)    ; and un-comment the lines between these banners
                                        (0078)    ;---------------------------------------------------
                                        (0079)    
                                        (0080)    ;PRESERVE_CPU_CONTEXT
                                        (0081)    ;lcall _My_C_Function
                                        (0082)    ;RESTORE_CPU_CONTEXT
                                        (0083)    
                                        (0084)    ;---------------------------------------------------
                                        (0085)    ; Insert a lcall to a C function above this banner
                                        (0086)    ; and un-comment the lines between these banners
                                        (0087)    ;---------------------------------------------------
                                        (0088)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0089) 
07D5: 7E       RETI                     (0090)    reti
                                        (0091) 
                                        (0092) 
                                        (0093) ; end of file PWM8_1INT.asm
FILE: lib\pwm8_1.asm                    (0001) ;;*****************************************************************************
07D6: 43 E1 10 OR    REG[0xE1],0x10     (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: PWM8_1.asm
                                        (0004) ;;   Version: 2.60, Updated on 2012/3/2 at 9:15:10
                                        (0005) ;;  Generated by PSoC Designer 5.2.2551
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM8 User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "PWM8_1.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  PWM8_1_EnableInt
                                        (0030) export _PWM8_1_EnableInt
                                        (0031) export  PWM8_1_DisableInt
                                        (0032) export _PWM8_1_DisableInt
                                        (0033) export  PWM8_1_Start
                                        (0034) export _PWM8_1_Start
                                        (0035) export  PWM8_1_Stop
                                        (0036) export _PWM8_1_Stop
                                        (0037) export  PWM8_1_WritePeriod
                                        (0038) export _PWM8_1_WritePeriod
                                        (0039) export  PWM8_1_WritePulseWidth
                                        (0040) export _PWM8_1_WritePulseWidth
                                        (0041) export  PWM8_1_bReadPulseWidth
                                        (0042) export _PWM8_1_bReadPulseWidth
                                        (0043) export  PWM8_1_bReadCounter
                                        (0044) export _PWM8_1_bReadCounter
                                        (0045) 
                                        (0046) ; The following functions are deprecated and subject to omission in future releases
                                        (0047) ;
                                        (0048) export  bPWM8_1_ReadPulseWidth    ; deprecated
                                        (0049) export _bPWM8_1_ReadPulseWidth    ; deprecated
                                        (0050) export  bPWM8_1_ReadCounter       ; deprecated
                                        (0051) export _bPWM8_1_ReadCounter       ; deprecated
                                        (0052) 
                                        (0053) 
                                        (0054) AREA time_test_RAM (RAM,REL)
                                        (0055) 
                                        (0056) ;-----------------------------------------------
                                        (0057) ;  Constant Definitions
                                        (0058) ;-----------------------------------------------
                                        (0059) 
                                        (0060) INPUT_REG_NULL:                equ 0x00    ; Clear the input register
                                        (0061) 
                                        (0062) 
                                        (0063) ;-----------------------------------------------
                                        (0064) ; Variable Allocation
                                        (0065) ;-----------------------------------------------
                                        (0066) 
                                        (0067) 
                                        (0068) AREA UserModules (ROM, REL)
                                        (0069) 
                                        (0070) .SECTION
                                        (0071) ;-----------------------------------------------------------------------------
                                        (0072) ;  FUNCTION NAME: PWM8_1_EnableInt
                                        (0073) ;
                                        (0074) ;  DESCRIPTION:
                                        (0075) ;     Enables this PWM's interrupt by setting the interrupt enable mask bit
                                        (0076) ;     associated with this User Module. This function has no effect until and
                                        (0077) ;     unless the global interrupts are enabled (for example by using the
                                        (0078) ;     macro M8C_EnableGInt).
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ;
                                        (0081) ;  ARGUMENTS:    None.
                                        (0082) ;  RETURNS:      Nothing.
                                        (0083) ;  SIDE EFFECTS:
                                        (0084) ;    The A and X registers may be modified by this or future implementations
                                        (0085) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0086) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0087) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0088) ;    functions.
                                        (0089) ;
                                        (0090)  PWM8_1_EnableInt:
                                        (0091) _PWM8_1_EnableInt:
                                        (0092)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0093)    PWM8_1_EnableInt_M
                                        (0094)    RAM_EPILOGUE RAM_USE_CLASS_1
07D9: 7F       RET                      (0095)    ret
07DA: 41 E1 EF AND   REG[0xE1],0xEF     
                                        (0096) 
                                        (0097) 
                                        (0098) .ENDSECTION
                                        (0099) 
                                        (0100) .SECTION
                                        (0101) ;-----------------------------------------------------------------------------
                                        (0102) ;  FUNCTION NAME: PWM8_1_DisableInt
                                        (0103) ;
                                        (0104) ;  DESCRIPTION:
                                        (0105) ;     Disables this PWM's interrupt by clearing the interrupt enable
                                        (0106) ;     mask bit associated with this User Module.
                                        (0107) ;-----------------------------------------------------------------------------
                                        (0108) ;
                                        (0109) ;  ARGUMENTS:    None
                                        (0110) ;  RETURNS:      Nothing
                                        (0111) ;  SIDE EFFECTS:
                                        (0112) ;    The A and X registers may be modified by this or future implementations
                                        (0113) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0114) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0115) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0116) ;    functions.
                                        (0117) ;
                                        (0118)  PWM8_1_DisableInt:
                                        (0119) _PWM8_1_DisableInt:
                                        (0120)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0121)    PWM8_1_DisableInt_M
                                        (0122)    RAM_EPILOGUE RAM_USE_CLASS_1
07DD: 7F       RET                      (0123)    ret
07DE: 43 33 01 OR    REG[0x33],0x1      
                                        (0124) 
                                        (0125) 
                                        (0126) .ENDSECTION
                                        (0127) 
                                        (0128) .SECTION
                                        (0129) ;-----------------------------------------------------------------------------
                                        (0130) ;  FUNCTION NAME: PWM8_1_Start
                                        (0131) ;
                                        (0132) ;  DESCRIPTION:
                                        (0133) ;     Sets the start bit in the Control register of this user module.  The
                                        (0134) ;     PWM will begin counting on the next input clock as soon as the
                                        (0135) ;     enable input is asserted high.
                                        (0136) ;-----------------------------------------------------------------------------
                                        (0137) ;
                                        (0138) ;  ARGUMENTS:    None
                                        (0139) ;  RETURNS:      Nothing
                                        (0140) ;  SIDE EFFECTS:
                                        (0141) ;    The A and X registers may be modified by this or future implementations
                                        (0142) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0143) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0144) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0145) ;    functions.
                                        (0146) ;
                                        (0147)  PWM8_1_Start:
                                        (0148) _PWM8_1_Start:
                                        (0149)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0150)    PWM8_1_Start_M
                                        (0151)    RAM_EPILOGUE RAM_USE_CLASS_1
07E1: 7F       RET                      (0152)    ret
07E2: 41 33 FE AND   REG[0x33],0xFE     
                                        (0153) 
                                        (0154) 
                                        (0155) .ENDSECTION
                                        (0156) 
                                        (0157) .SECTION
                                        (0158) ;-----------------------------------------------------------------------------
                                        (0159) ;  FUNCTION NAME: PWM8_1_Stop
                                        (0160) ;
                                        (0161) ;  DESCRIPTION:
                                        (0162) ;     Disables PWM operation by clearing the start bit in the Control
                                        (0163) ;     register.
                                        (0164) ;-----------------------------------------------------------------------------
                                        (0165) ;
                                        (0166) ;  ARGUMENTS:    None
                                        (0167) ;  RETURNS:      Nothing
                                        (0168) ;  SIDE EFFECTS:
                                        (0169) ;    The A and X registers may be modified by this or future implementations
                                        (0170) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0171) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0172) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0173) ;    functions.
                                        (0174) ;
                                        (0175)  PWM8_1_Stop:
                                        (0176) _PWM8_1_Stop:
                                        (0177)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0178)    PWM8_1_Stop_M
                                        (0179)    RAM_EPILOGUE RAM_USE_CLASS_1
07E5: 7F       RET                      (0180)    ret
                                        (0181) 
                                        (0182) 
                                        (0183) .ENDSECTION
                                        (0184) 
                                        (0185) .SECTION
                                        (0186) ;-----------------------------------------------------------------------------
                                        (0187) ;  FUNCTION NAME: PWM8_1_WritePeriod
                                        (0188) ;
                                        (0189) ;  DESCRIPTION:
                                        (0190) ;     Write the 8-bit period value into the Period register (DR1).
                                        (0191) ;-----------------------------------------------------------------------------
                                        (0192) ;
                                        (0193) ;  ARGUMENTS: fastcall16 BYTE bPeriodValue (passed in A)
                                        (0194) ;  RETURNS:   Nothing
                                        (0195) ;  SIDE EFFECTS:
                                        (0196) ;    If the PWM user module is stopped, then this value will also be
                                        (0197) ;    latched into the Count register (DR0).
                                        (0198) ;    
                                        (0199) ;    The A and X registers may be modified by this or future implementations
                                        (0200) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0201) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0202) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0203) ;    functions.
                                        (0204) ;
                                        (0205)  PWM8_1_WritePeriod:
                                        (0206) _PWM8_1_WritePeriod:
                                        (0207)    RAM_PROLOGUE RAM_USE_CLASS_1
07E6: 60 31    MOV   REG[0x31],A        (0208)    mov   reg[PWM8_1_PERIOD_REG], A
                                        (0209)    RAM_EPILOGUE RAM_USE_CLASS_1
07E8: 7F       RET                      (0210)    ret
                                        (0211) 
                                        (0212) 
                                        (0213) .ENDSECTION
                                        (0214) 
                                        (0215) .SECTION
                                        (0216) ;-----------------------------------------------------------------------------
                                        (0217) ;  FUNCTION NAME: PWM8_1_WritePulseWidth
                                        (0218) ;
                                        (0219) ;  DESCRIPTION:
                                        (0220) ;     Writes compare value into the Compare register (DR2).
                                        (0221) ;-----------------------------------------------------------------------------
                                        (0222) ;
                                        (0223) ;  ARGUMENTS:    fastcall16 BYTE bCompareValue (passed in A)
                                        (0224) ;  RETURNS:      Nothing
                                        (0225) ;  SIDE EFFECTS:
                                        (0226) ;    The A and X registers may be modified by this or future implementations
                                        (0227) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0228) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0229) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0230) ;    functions.
                                        (0231) ;
                                        (0232)  PWM8_1_WritePulseWidth:
                                        (0233) _PWM8_1_WritePulseWidth:
                                        (0234)    RAM_PROLOGUE RAM_USE_CLASS_1
07E9: 60 32    MOV   REG[0x32],A        (0235)    mov   reg[PWM8_1_COMPARE_REG], A
                                        (0236)    RAM_EPILOGUE RAM_USE_CLASS_1
07EB: 7F       RET                      (0237)    ret
                                        (0238) 
                                        (0239) 
                                        (0240) .ENDSECTION
                                        (0241) 
                                        (0242) .SECTION
                                        (0243) ;-----------------------------------------------------------------------------
                                        (0244) ;  FUNCTION NAME: PWM8_1_bReadPulseWidth
                                        (0245) ;
                                        (0246) ;  DESCRIPTION:
                                        (0247) ;     Reads the Compare register.
                                        (0248) ;-----------------------------------------------------------------------------
                                        (0249) ;
                                        (0250) ;  ARGUMENTS:    None
                                        (0251) ;  RETURNS:      fastcall16 BYTE bCompareValue (value of DR2 in the A register)
                                        (0252) ;  SIDE EFFECTS:
                                        (0253) ;    The A and X registers may be modified by this or future implementations
                                        (0254) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0255) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0256) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0257) ;    functions.
                                        (0258) ;
                                        (0259)  PWM8_1_bReadPulseWidth:
                                        (0260) _PWM8_1_bReadPulseWidth:
                                        (0261)  bPWM8_1_ReadPulseWidth:                         ; this name deprecated
                                        (0262) _bPWM8_1_ReadPulseWidth:                         ; this name deprecated
                                        (0263)    RAM_PROLOGUE RAM_USE_CLASS_1
07EC: 5D 32    MOV   A,REG[0x32]        (0264)    mov   A, reg[PWM8_1_COMPARE_REG]
                                        (0265)    RAM_EPILOGUE RAM_USE_CLASS_1
07EE: 7F       RET                      (0266)    ret
                                        (0267) 
                                        (0268) 
                                        (0269) .ENDSECTION
                                        (0270) 
                                        (0271) .SECTION
                                        (0272) ;-----------------------------------------------------------------------------
                                        (0273) ;  FUNCTION NAME: PWM8_1_bReadCounter
                                        (0274) ;
                                        (0275) ;  DESCRIPTION:
                                        (0276) ;     Returns the value in the Count register (DR0), preserving the value in
                                        (0277) ;     the compare register (DR2). Interrupts are prevented during the transfer
                                        (0278) ;     from the Count to the Compare registers by holding the clock low in
                                        (0279) ;     the PSoC block.
                                        (0280) ;-----------------------------------------------------------------------------
                                        (0281) ;
                                        (0282) ;  ARGUMENTS: None
                                        (0283) ;  RETURNS:   fastcall16 BYTE bCount (value of DR0 in the A register)
                                        (0284) ;  SIDE EFFECTS:
                                        (0285) ;     1) The user module is stopped momentarily and one or more counts may be missed.
                                        (0286) ;     2) The A and X registers may be modified by this or future implementations
                                        (0287) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0288) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0289) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0290) ;        functions.
                                        (0291) ;
                                        (0292)  PWM8_1_bReadCounter:
                                        (0293) _PWM8_1_bReadCounter:
                                        (0294)  bPWM8_1_ReadCounter:                            ; this name deprecated
                                        (0295) _bPWM8_1_ReadCounter:                            ; this name deprecated
                                        (0296) 
                                        (0297)    bOrigCompareValue:      EQU   0               ; Frame offset to temp Compare store
                                        (0298)    bOrigClockSetting:      EQU   1               ; Frame offset to temp Input   store
                                        (0299)    wCounter:               EQU   2               ; Frame offset to temp Count   store
                                        (0300)    STACK_FRAME_SIZE:       EQU   3               ; max stack frame size is 3 bytes
                                        (0301) 
                                        (0302)    RAM_PROLOGUE RAM_USE_CLASS_2
07EF: 4F       MOV   X,SP               (0303)    mov   X, SP                                   ; X <- stack frame pointer
07F0: 5D 32    MOV   A,REG[0x32]        (0304)    mov   A, reg[PWM8_1_COMPARE_REG]              ; Save the Compare register on the stack
07F2: 08       PUSH  A                  (0305)    push  A                                       ;
07F3: 41 33 FE AND   REG[0x33],0xFE     
07F6: 71 10    OR    F,0x10             
                                        (0306)    PWM8_1_Stop_M                                 ; Disable (stop) the PWM
                                        (0307)    M8C_SetBank1                                  ;
07F8: 5D 31    MOV   A,REG[0x31]        (0308)    mov   A, reg[PWM8_1_INPUT_REG]                ; save the clock input setting
07FA: 08       PUSH  A                  (0309)    push  A                                       ;   on the stack (now 2 bytes) and ...
                                        (0310)                                                  ;   hold the clock low:
07FB: 62 31 00 MOV   REG[0x31],0x0      (0311)    mov   reg[PWM8_1_INPUT_REG], INPUT_REG_NULL
07FE: 70 EF    AND   F,0xEF             
                                        (0312)    M8C_SetBank0
                                        (0313)                                                  ; Extract the Count via DR2 register
0800: 5D 30    MOV   A,REG[0x30]        (0314)    mov   A, reg[PWM8_1_COUNTER_REG]              ; DR2 <- DR0
0802: 5D 32    MOV   A,REG[0x32]        (0315)    mov   A, reg[PWM8_1_COMPARE_REG]              ; Stash the Count on the stack
0804: 08       PUSH  A                  (0316)    push  A                                       ;  -stack frame is now 3 bytes
0805: 52 00    MOV   A,[X+0]            (0317)    mov   A, [X+bOrigCompareValue]                ; Restore the Compare register
0807: 60 32    MOV   REG[0x32],A        (0318)    mov   reg[PWM8_1_COMPARE_REG], A
0809: 71 10    OR    F,0x10             
                                        (0319)    M8C_SetBank1                                  ; Restore the PWM operation:
080B: 52 01    MOV   A,[X+1]            (0320)    mov   A, [X+bOrigClockSetting]                ;   First, the clock setting...
080D: 60 31    MOV   REG[0x31],A        (0321)    mov   reg[PWM8_1_INPUT_REG], A                ;
080F: 70 EF    AND   F,0xEF             
0811: 43 33 01 OR    REG[0x33],0x1      
                                        (0322)    M8C_SetBank0                                  ;
                                        (0323)    PWM8_1_Start_M                                ;   then re-enable the PWM.
0814: 18       POP   A                  (0324)    pop   A                                       ; Setup the return value
0815: 38 FE    ADD   SP,0xFE            (0325)    ADD   SP, -(STACK_FRAME_SIZE-1)               ; Zap remainder of stack frame
0817: 70 3F    AND   F,0x3F             
0819: 71 C0    OR    F,0xC0             
                                        (0326)    RAM_EPILOGUE RAM_USE_CLASS_2
081B: 7F       RET                      (0327)    ret
                                        (0328) 
                                        (0329) .ENDSECTION
                                        (0330) 
                                        (0331) ; End of File PWM8_1.asm
FILE: lib\pwm16_1int.asm                (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: PWM16_1INT.asm
                                        (0004) ;;   Version: 2.5, Updated on 2012/3/2 at 9:15:9
                                        (0005) ;;  Generated by PSoC Designer 5.2.2551
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM16 Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "PWM16_1.inc"
                                        (0015) include "memory.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _PWM16_1_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _PWM16_1_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _PWM16_1_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070)    
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom assembly code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    
                                        (0075)    ;---------------------------------------------------
                                        (0076)    ; Insert a lcall to a C function below this banner
                                        (0077)    ; and un-comment the lines between these banners
                                        (0078)    ;---------------------------------------------------
                                        (0079)    
                                        (0080)    ;PRESERVE_CPU_CONTEXT
081C: 7D 0D 95 LJMP  _My_16_pwm_isr     (0081)    ljmp _My_16_pwm_isr
                                        (0082)    ;RESTORE_CPU_CONTEXT
                                        (0083)    
                                        (0084)    ;---------------------------------------------------
                                        (0085)    ; Insert a lcall to a C function above this banner
                                        (0086)    ; and un-comment the lines between these banners
                                        (0087)    ;---------------------------------------------------
                                        (0088)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0089) 
081F: 7E       RETI                     (0090)    reti
                                        (0091) 
                                        (0092) 
                                        (0093) ; end of file PWM16_1INT.asm
FILE: lib\pwm16_1.asm                   (0001) ;;*****************************************************************************
0820: 43 E1 02 OR    REG[0xE1],0x2      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: PWM16_1.asm
                                        (0004) ;;   Version: 2.5, Updated on 2012/3/2 at 9:15:9
                                        (0005) ;;  Generated by PSoC Designer 5.2.2551
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM16 User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "PWM16_1.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  PWM16_1_EnableInt
                                        (0030) export _PWM16_1_EnableInt
                                        (0031) export  PWM16_1_DisableInt
                                        (0032) export _PWM16_1_DisableInt
                                        (0033) export  PWM16_1_Start
                                        (0034) export _PWM16_1_Start
                                        (0035) export  PWM16_1_Stop
                                        (0036) export _PWM16_1_Stop
                                        (0037) export  PWM16_1_WritePeriod
                                        (0038) export _PWM16_1_WritePeriod
                                        (0039) export  PWM16_1_WritePulseWidth
                                        (0040) export _PWM16_1_WritePulseWidth
                                        (0041) export  PWM16_1_wReadPulseWidth
                                        (0042) export _PWM16_1_wReadPulseWidth
                                        (0043) export  PWM16_1_wReadCounter
                                        (0044) export _PWM16_1_wReadCounter
                                        (0045) 
                                        (0046) ; The following functions are deprecated and subject to omission in future releases
                                        (0047) ;
                                        (0048) export  wPWM16_1_ReadPulseWidth    ; deprecated
                                        (0049) export _wPWM16_1_ReadPulseWidth    ; deprecated
                                        (0050) export  wPWM16_1_ReadCounter       ; deprecated
                                        (0051) export _wPWM16_1_ReadCounter       ; deprecated
                                        (0052) 
                                        (0053) 
                                        (0054) AREA time_test_RAM (RAM,REL)
                                        (0055) 
                                        (0056) ;-----------------------------------------------
                                        (0057) ;  Constant Definitions
                                        (0058) ;-----------------------------------------------
                                        (0059) 
                                        (0060) INPUT_REG_NULL:                equ 0x00    ; Clear the input register
                                        (0061) 
                                        (0062) 
                                        (0063) ;-----------------------------------------------
                                        (0064) ; Variable Allocation
                                        (0065) ;-----------------------------------------------
                                        (0066) 
                                        (0067) 
                                        (0068) AREA UserModules (ROM, REL)
                                        (0069) 
                                        (0070) .SECTION
                                        (0071) ;-----------------------------------------------------------------------------
                                        (0072) ;  FUNCTION NAME: PWM16_1_EnableInt
                                        (0073) ;
                                        (0074) ;  DESCRIPTION:
                                        (0075) ;     Enables this PWM's interrupt by setting the interrupt enable mask bit
                                        (0076) ;     associated with this User Module. This function has no effect until and
                                        (0077) ;     unless the global interrupts are enabled (for example by using the
                                        (0078) ;     macro M8C_EnableGInt).
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ;
                                        (0081) ;  ARGUMENTS:    None.
                                        (0082) ;  RETURNS:      Nothing.
                                        (0083) ;  SIDE EFFECTS: 
                                        (0084) ;    The A and X registers may be modified by this or future implementations
                                        (0085) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0086) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0087) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0088) ;    functions.
                                        (0089) ;
                                        (0090)  PWM16_1_EnableInt:
                                        (0091) _PWM16_1_EnableInt:
                                        (0092)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0093)    PWM16_1_EnableInt_M
                                        (0094)    RAM_EPILOGUE RAM_USE_CLASS_1
0823: 7F       RET                      (0095)    ret
0824: 41 E1 FD AND   REG[0xE1],0xFD     
                                        (0096) 
                                        (0097) 
                                        (0098) .ENDSECTION
                                        (0099) 
                                        (0100) .SECTION
                                        (0101) ;-----------------------------------------------------------------------------
                                        (0102) ;  FUNCTION NAME: PWM16_1_DisableInt
                                        (0103) ;
                                        (0104) ;  DESCRIPTION:
                                        (0105) ;     Disables this PWM's interrupt by clearing the interrupt enable
                                        (0106) ;     mask bit associated with this User Module.
                                        (0107) ;-----------------------------------------------------------------------------
                                        (0108) ;
                                        (0109) ;  ARGUMENTS:    None
                                        (0110) ;  RETURNS:      Nothing
                                        (0111) ;  SIDE EFFECTS:
                                        (0112) ;    The A and X registers may be modified by this or future implementations
                                        (0113) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0114) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0115) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0116) ;    functions.
                                        (0117) ;
                                        (0118)  PWM16_1_DisableInt:
                                        (0119) _PWM16_1_DisableInt:
                                        (0120)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0121)    PWM16_1_DisableInt_M
                                        (0122)    RAM_EPILOGUE RAM_USE_CLASS_1
0827: 7F       RET                      (0123)    ret
0828: 43 23 01 OR    REG[0x23],0x1      
                                        (0124) 
                                        (0125) 
                                        (0126) .ENDSECTION
                                        (0127) 
                                        (0128) .SECTION
                                        (0129) ;-----------------------------------------------------------------------------
                                        (0130) ;  FUNCTION NAME: PWM16_1_Start
                                        (0131) ;
                                        (0132) ;  DESCRIPTION:
                                        (0133) ;     Sets the start bit in the Control register of this user module.  The
                                        (0134) ;     PWM will begin counting on the next input clock as soon as the
                                        (0135) ;     enable input is asserted high.
                                        (0136) ;-----------------------------------------------------------------------------
                                        (0137) ;
                                        (0138) ;  ARGUMENTS:    None
                                        (0139) ;  RETURNS:      Nothing
                                        (0140) ;  SIDE EFFECTS:
                                        (0141) ;    The A and X registers may be modified by this or future implementations
                                        (0142) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0143) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0144) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0145) ;    functions.
                                        (0146) ;
                                        (0147)  PWM16_1_Start:
                                        (0148) _PWM16_1_Start:
                                        (0149)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0150)    PWM16_1_Start_M
                                        (0151)    RAM_EPILOGUE RAM_USE_CLASS_1
082B: 7F       RET                      (0152)    ret
082C: 41 23 FE AND   REG[0x23],0xFE     
                                        (0153) 
                                        (0154) 
                                        (0155) .ENDSECTION
                                        (0156) 
                                        (0157) .SECTION
                                        (0158) ;-----------------------------------------------------------------------------
                                        (0159) ;  FUNCTION NAME: PWM16_1_Stop
                                        (0160) ;
                                        (0161) ;  DESCRIPTION:
                                        (0162) ;     Disables PWM operation by clearing the start bit in the Control
                                        (0163) ;     register of the LSB block.
                                        (0164) ;-----------------------------------------------------------------------------
                                        (0165) ;
                                        (0166) ;  ARGUMENTS:    None
                                        (0167) ;  RETURNS:      Nothing
                                        (0168) ;  SIDE EFFECTS:
                                        (0169) ;    The A and X registers may be modified by this or future implementations
                                        (0170) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0171) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0172) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0173) ;    functions.
                                        (0174) ;
                                        (0175)  PWM16_1_Stop:
                                        (0176) _PWM16_1_Stop:
                                        (0177)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0178)    PWM16_1_Stop_M
                                        (0179)    RAM_EPILOGUE RAM_USE_CLASS_1
082F: 7F       RET                      (0180)    ret
                                        (0181) 
                                        (0182) 
                                        (0183) .ENDSECTION
                                        (0184) 
                                        (0185) .SECTION
                                        (0186) ;-----------------------------------------------------------------------------
                                        (0187) ;  FUNCTION NAME: PWM16_1_WritePeriod
                                        (0188) ;
                                        (0189) ;  DESCRIPTION:
                                        (0190) ;     Write the 16-bit period value into the Period register (DR1).
                                        (0191) ;-----------------------------------------------------------------------------
                                        (0192) ;
                                        (0193) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                        (0194) ;  RETURNS:   Nothing
                                        (0195) ;  SIDE EFFECTS:
                                        (0196) ;    If the PWM user module is stopped, then this value will also be
                                        (0197) ;    latched into the Count registers (DR0).
                                        (0198) ;    
                                        (0199) ;    The A and X registers may be modified by this or future implementations
                                        (0200) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0201) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0202) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0203) ;    functions.
                                        (0204) ;
                                        (0205)  PWM16_1_WritePeriod:
                                        (0206) _PWM16_1_WritePeriod:
                                        (0207)    RAM_PROLOGUE RAM_USE_CLASS_1
0830: 60 21    MOV   REG[0x21],A        (0208)    mov   reg[PWM16_1_PERIOD_LSB_REG], A
0832: 5B       MOV   A,X                (0209)    mov   A, X
0833: 60 25    MOV   REG[0x25],A        (0210)    mov   reg[PWM16_1_PERIOD_MSB_REG], A
                                        (0211)    RAM_EPILOGUE RAM_USE_CLASS_1
0835: 7F       RET                      (0212)    ret
                                        (0213) 
                                        (0214) 
                                        (0215) .ENDSECTION
                                        (0216) 
                                        (0217) .SECTION
                                        (0218) ;-----------------------------------------------------------------------------
                                        (0219) ;  FUNCTION NAME: PWM16_1_WritePulseWidth
                                        (0220) ;
                                        (0221) ;  DESCRIPTION:
                                        (0222) ;     Writes the pulse width value into the Compare register (DR2).
                                        (0223) ;-----------------------------------------------------------------------------
                                        (0224) ;
                                        (0225) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
                                        (0226) ;  RETURNS:      Nothing
                                        (0227) ;  SIDE EFFECTS:
                                        (0228) ;    The A and X registers may be modified by this or future implementations
                                        (0229) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0230) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0231) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0232) ;    functions.
                                        (0233) ;
                                        (0234)  PWM16_1_WritePulseWidth:
                                        (0235) _PWM16_1_WritePulseWidth:
                                        (0236)    RAM_PROLOGUE RAM_USE_CLASS_1
0836: 60 22    MOV   REG[0x22],A        (0237)    mov   reg[PWM16_1_COMPARE_LSB_REG], A
0838: 5B       MOV   A,X                (0238)    mov   A, X
0839: 60 26    MOV   REG[0x26],A        (0239)    mov   reg[PWM16_1_COMPARE_MSB_REG], A
                                        (0240)    RAM_EPILOGUE RAM_USE_CLASS_1
083B: 7F       RET                      (0241)    ret
                                        (0242) 
                                        (0243) 
                                        (0244) .ENDSECTION
                                        (0245) 
                                        (0246) .SECTION
                                        (0247) ;-----------------------------------------------------------------------------
                                        (0248) ;  FUNCTION NAME: PWM16_1_wReadPulseWidth
                                        (0249) ;
                                        (0250) ;  DESCRIPTION:
                                        (0251) ;     Reads the Compare register.
                                        (0252) ;-----------------------------------------------------------------------------
                                        (0253) ;
                                        (0254) ;  ARGUMENTS:    None
                                        (0255) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                        (0256) ;  SIDE EFFECTS:
                                        (0257) ;    The A and X registers may be modified by this or future implementations
                                        (0258) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0259) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0260) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0261) ;    functions.
                                        (0262) ;
                                        (0263)  PWM16_1_wReadPulseWidth:
                                        (0264) _PWM16_1_wReadPulseWidth:
                                        (0265)  wPWM16_1_ReadPulseWidth:                        ; this name deprecated
                                        (0266) _wPWM16_1_ReadPulseWidth:                        ; this name deprecated
                                        (0267)    RAM_PROLOGUE RAM_USE_CLASS_1
083C: 5D 26    MOV   A,REG[0x26]        (0268)    mov   A, reg[PWM16_1_COMPARE_MSB_REG]
083E: 5C       MOV   X,A                (0269)    mov   X, A
083F: 5D 22    MOV   A,REG[0x22]        (0270)    mov   A, reg[PWM16_1_COMPARE_LSB_REG]
                                        (0271)    RAM_EPILOGUE RAM_USE_CLASS_1
0841: 7F       RET                      (0272)    ret
                                        (0273) 
                                        (0274) 
                                        (0275) .ENDSECTION
                                        (0276) 
                                        (0277) .SECTION
                                        (0278) ;-----------------------------------------------------------------------------
                                        (0279) ;  FUNCTION NAME: PWM16_1_wReadCounter
                                        (0280) ;
                                        (0281) ;  DESCRIPTION:
                                        (0282) ;     Returns the value in the Count register (DR0), preserving the value in
                                        (0283) ;     the compare register (DR2). Interrupts are prevented during the transfer
                                        (0284) ;     from the Count to the Compare register by holding the clock low in
                                        (0285) ;     the MSB PSoC block.
                                        (0286) ;-----------------------------------------------------------------------------
                                        (0287) ;
                                        (0288) ;  ARGUMENTS: None
                                        (0289) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                        (0290) ;  SIDE EFFECTS:
                                        (0291) ;     1) The user module is stopped momentarily and one or more counts may be missed.
                                        (0292) ;     2) The A and X registers may be modified by this or future implementations
                                        (0293) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0294) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0295) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0296) ;        functions.
                                        (0297) ;
                                        (0298)  PWM16_1_wReadCounter:
                                        (0299) _PWM16_1_wReadCounter:
                                        (0300)  wPWM16_1_ReadCounter:                           ; this name deprecated
                                        (0301) _wPWM16_1_ReadCounter:                           ; this name deprecated
                                        (0302) 
                                        (0303)    bOrigCompareValue:      EQU   0                  ; Frame offset to temp Compare store
                                        (0304)    bOrigClockSetting:      EQU   2                  ; Frame offset to temp Input   store
                                        (0305)    wCounter:               EQU   3                  ; Frame offset to temp Count   store
                                        (0306)    STACK_FRAME_SIZE:       EQU   5                  ; max stack frame size is 5 bytes
                                        (0307) 
                                        (0308)    RAM_PROLOGUE RAM_USE_CLASS_2
0842: 4F       MOV   X,SP               (0309)    mov   X, SP                                      ; X <-  stack frame pointer
0843: 5D 26    MOV   A,REG[0x26]        (0310)    mov   A, reg[PWM16_1_COMPARE_MSB_REG]         ; Save the Compare register on the stack
0845: 08       PUSH  A                  (0311)    push  A                                          ;
0846: 5D 22    MOV   A,REG[0x22]        (0312)    mov   A, reg[PWM16_1_COMPARE_LSB_REG]         ;
0848: 08       PUSH  A                  (0313)    push  A                                          ;  -stack frame now 2 bytes-
0849: 41 23 FE AND   REG[0x23],0xFE     
084C: 71 10    OR    F,0x10             
                                        (0314)    PWM16_1_Stop_M                                ; Disable the PWM function
                                        (0315)    M8C_SetBank1                                     ;
084E: 5D 21    MOV   A,REG[0x21]        (0316)    mov   A, reg[PWM16_1_INPUT_LSB_REG]           ; save the LSB clock input setting
0850: 08       PUSH  A                  (0317)    push  A                                          ;   on the stack (now 3 bytes) and ...
                                        (0318)                                                     ;   hold the clock low:
0851: 62 21 00 MOV   REG[0x21],0x0      (0319)    mov   reg[PWM16_1_INPUT_LSB_REG], INPUT_REG_NULL
0854: 70 EF    AND   F,0xEF             
                                        (0320)    M8C_SetBank0                                     ; Extract the Count via DR2 register
0856: 5D 24    MOV   A,REG[0x24]        (0321)    mov   A, reg[PWM16_1_COUNTER_MSB_REG]         ; DR2 <- DR0 (in the MSB block)
0858: 5D 26    MOV   A,REG[0x26]        (0322)    mov   A, reg[PWM16_1_COMPARE_MSB_REG]         ; Stash the Count MSB on the stack
085A: 08       PUSH  A                  (0323)    push  A                                          ;  -stack frame is now 4 bytes
085B: 5D 20    MOV   A,REG[0x20]        (0324)    mov   A, reg[PWM16_1_COUNTER_LSB_REG]         ; DR2 <- DR0 (in the LSB block)
085D: 5D 22    MOV   A,REG[0x22]        (0325)    mov   A, reg[PWM16_1_COMPARE_LSB_REG]         ; Stash the Count LSB on the stack
085F: 08       PUSH  A                  (0326)    push  A                                          ;   -stack frame is now 5 bytes-
0860: 52 00    MOV   A,[X+0]            (0327)    mov   A, [X+bOrigCompareValue]                   ; Restore the Compare MSB register
0862: 60 26    MOV   REG[0x26],A        (0328)    mov   reg[PWM16_1_COMPARE_MSB_REG], A         ;
0864: 52 01    MOV   A,[X+1]            (0329)    mov   A, [X+bOrigCompareValue+1]                 ; Restore the Compare LSB register
0866: 60 22    MOV   REG[0x22],A        (0330)    mov   reg[PWM16_1_COMPARE_LSB_REG], A         ;
0868: 71 10    OR    F,0x10             
                                        (0331)    M8C_SetBank1                                     ; ---Restore the PWM operation
086A: 52 02    MOV   A,[X+2]            (0332)    mov   A, [X+bOrigClockSetting]                   ; Grab the LSB clock setting...
086C: 60 21    MOV   REG[0x21],A        (0333)    mov   reg[PWM16_1_INPUT_LSB_REG], A           ;    and restore it
086E: 70 EF    AND   F,0xEF             
0870: 43 23 01 OR    REG[0x23],0x1      
                                        (0334)    M8C_SetBank0                                     ;
                                        (0335)    PWM16_1_Start_M                               ; Now re-enable the PWM function
0873: 18       POP   A                  (0336)    pop   A                                          ; Setup the return value
0874: 20       POP   X                  (0337)    pop   X                                          ;
0875: 38 FD    ADD   SP,0xFD            (0338)    ADD   SP, -(STACK_FRAME_SIZE-2)                  ; Zap remainder of stack frame
0877: 70 3F    AND   F,0x3F             
0879: 71 C0    OR    F,0xC0             
                                        (0339)    RAM_EPILOGUE RAM_USE_CLASS_2
087B: 7F       RET                      (0340)    ret
                                        (0341) 
                                        (0342) .ENDSECTION
                                        (0343) 
                                        (0344) ; End of File PWM16_1.asm
FILE: lib\pga_1.asm                     (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   PGA_1.asm  ( PGA )
                                        (0004) ;;  Version: 3.2, Updated on 2012/3/2 at 9:15:6
                                        (0005) ;;  Generated by PSoC Designer 5.2.2551
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION:  PGA User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) ;; -----------------------------------------------------------------
                                        (0023) ;;                         Register Definitions
                                        (0024) ;;
                                        (0025) ;; Uses 1 Continuous Time Block configured as shown.
                                        (0026) ;;
                                        (0027) ;; * For a Mask/Val pair, this indicates that the value is
                                        (0028) ;;   determined by the user either through config-time parameteriza-
                                        (0029) ;;   tion or run-time manipulation.
                                        (0030) ;;
                                        (0031) ;; BIT FIELD             Mask/Val Function
                                        (0032) ;; -----------------            -----   --------------------
                                        (0033) ;; GAIN_CR0.RES_RATIO_T2B       F0/*    User Parameter (by table)
                                        (0034) ;; GAIN_CR0.GAIN_ATTEN          08/*    Gain (by table)
                                        (0035) ;; GAIN_CR0.RES_SOURCE          04/1    Res source to output
                                        (0036) ;; GAIN_CR0.RES_REF             03/*    Res ref
                                        (0037) ;;
                                        (0038) ;; GAIN_CR1.A_OUT               80/*    User Parameter (Output bus)
                                        (0039) ;; GAIN_CR1.COMP_EN             40/0    Comparator bus disabled
                                        (0040) ;; GAIN_CR1.CT_NEG_INPUT_MUX    38/4    Neg mux to analog f.b. tap
                                        (0041) ;; GAIN_CR1.CT_POS_INPUT_MUX    07/*    Pos mux, typically to col. input mux
                                        (0042) ;;
                                        (0043) ;; GAIN_CR2.CP_COMP             80/0    Latch transparent on PH1
                                        (0044) ;; GAIN_CR2.CK_COMP             40/0    Latch transparent
                                        (0045) ;; GAIN_CR2.CC_COMP             20/1    Mode OP-AMP (not comparator)
                                        (0046) ;; GAIN_CR2.BYPASS_OBUS         1C/0    Bypass OFF
                                        (0047) ;; GAIN_CR2.PWR_SELECT          03/*    Power OFF (0h) at start-up
                                        (0048) ;;
                                        (0049) ;; --------------------------------------------------------------------
                                        (0050) 
                                        (0051) include "PGA_1.inc"
                                        (0052) include "m8c.inc"
                                        (0053) include "memory.inc"
                                        (0054) 
                                        (0055) 
                                        (0056) ;-----------------------------------------------
                                        (0057) ;  Global Symbols
                                        (0058) ;-----------------------------------------------
                                        (0059) export  PGA_1_Start
                                        (0060) export _PGA_1_Start
                                        (0061) export  PGA_1_SetPower
                                        (0062) export _PGA_1_SetPower
                                        (0063) 
                                        (0064) export  PGA_1_SetGain
                                        (0065) export _PGA_1_SetGain
                                        (0066) 
                                        (0067) export  PGA_1_Stop
                                        (0068) export _PGA_1_Stop
                                        (0069) 
                                        (0070) IF (PGA_1_AGNDBUFAPI)
                                        (0071) export  PGA_1_EnableAGNDBuffer
                                        (0072) export _PGA_1_EnableAGNDBuffer
                                        (0073) export  PGA_1_DisableAGNDBuffer
                                        (0074) export _PGA_1_DisableAGNDBuffer
                                        (0075) ENDIF
                                        (0076) 
                                        (0077) ;-----------------------------------------------
                                        (0078) ;  EQUATES
                                        (0079) ;-----------------------------------------------
                                        (0080) POWERMASK:     equ 03h
                                        (0081) GAINREGMASK:   equ f8h
                                        (0082) GAINMASK:      equ fCh
                                        (0083) HIGHGAIN:      equ 04h
                                        (0084) HIGHGAINMASK:  equ 18h
                                        (0085) EXGAIN:        equ 01h
                                        (0086) AGNDBUFMASK:   equ 20h
                                        (0087) 
                                        (0088) AREA UserModules (ROM, REL)
                                        (0089) .SECTION
                                        (0090) ;-----------------------------------------------------------------------------
                                        (0091) ;  FUNCTION NAME: PGA_1_Start
                                        (0092) ;  FUNCTION NAME: PGA_1_SetPower
                                        (0093) ;
                                        (0094) ;  DESCRIPTION:
                                        (0095) ;    Applies power setting to the module's PSoC block.
                                        (0096) ;-----------------------------------------------------------------------------
                                        (0097) ;
                                        (0098) ;  ARGUMENTS:
                                        (0099) ;  A  Contains the power settings 0=Off, 1=Low, 2=Med, and 3=High
                                        (0100) ;
                                        (0101) ;  RETURNS:  NA
                                        (0102) ;
                                        (0103) ;  SIDE EFFECTS:
                                        (0104) ;    The A and X registers may be modified by this or future implementations
                                        (0105) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0106) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0107) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0108) ;    functions.
                                        (0109) ;
                                        (0110)  PGA_1_Start:
                                        (0111) _PGA_1_Start:
                                        (0112)  PGA_1_SetPower:
                                        (0113) _PGA_1_SetPower:
                                        (0114) 
                                        (0115)    RAM_PROLOGUE RAM_USE_CLASS_2
087C: 21 03    AND   A,0x3              (0116)    and  A, POWERMASK                                 ; mask A to protect unchanged bits
087E: 4F       MOV   X,SP               (0117)    mov  X, SP                                        ; define temp store location
                                        (0118) ;
087F: 08       PUSH  A                  (0119)    push A                                            ; put power value in temp store
0880: 5D 73    MOV   A,REG[0x73]        (0120)    mov  A, reg[PGA_1_GAIN_CR2]                             ; read power value
0882: 21 FC    AND   A,0xFC             (0121)    and  A, ~POWERMASK                                ; clear power bits in A
0884: 2B 00    OR    A,[X+0]            (0122)    or   A, [X]                                       ; combine power value with balance of reg.
0886: 60 73    MOV   REG[0x73],A        (0123)    mov  reg[PGA_1_GAIN_CR2], A                        ; move complete value back to register
0888: 18       POP   A                  (0124)    pop  A
0889: 70 3F    AND   F,0x3F             
088B: 71 C0    OR    F,0xC0             
                                        (0125)    RAM_EPILOGUE RAM_USE_CLASS_2
088D: 7F       RET                      (0126)    ret
                                        (0127) .ENDSECTION
                                        (0128) 
                                        (0129) .SECTION
                                        (0130) ;-----------------------------------------------------------------------------
                                        (0131) ;  FUNCTION NAME: PGA_1_SetGain
                                        (0132) ;
                                        (0133) ;  DESCRIPTION:
                                        (0134) ;    This function sets the Gain/Atten of the amplifier.  Valid gain settings
                                        (0135) ;    are defined in the .inc file.
                                        (0136) ;
                                        (0137) ;-----------------------------------------------------------------------------
                                        (0138) ;
                                        (0139) ;  ARGUMENTS:
                                        (0140) ;    A  Contains gain settings.
                                        (0141) ;
                                        (0142) ;    Gain values shown are for example. (See .inc file for gain equates)
                                        (0143) ;
                                        (0144) ;  RETURNS:  NA
                                        (0145) ;
                                        (0146) ;  SIDE EFFECTS:
                                        (0147) ;    The A and X registers may be modified by this or future implementations
                                        (0148) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0149) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0150) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0151) ;    functions.
                                        (0152) ;
                                        (0153)  PGA_1_SetGain:
                                        (0154) _PGA_1_SetGain:
                                        (0155) 
                                        (0156)    RAM_PROLOGUE RAM_USE_CLASS_2
088E: 21 FC    AND   A,0xFC             (0157)    and  A, GAINMASK                                       ; mask A to protect unchanged bits
0890: 4F       MOV   X,SP               (0158)    mov  X, SP                                             ; define temp store location
                                        (0159) ;
0891: 08       PUSH  A                  (0160)    push A                                                 ; put gain value in temp store
0892: 5D 71    MOV   A,REG[0x71]        (0161)    mov  A, reg[PGA_1_GAIN_CR0]                             ; read mux settings
0894: 21 07    AND   A,0x7              (0162)    and  A, ~GAINREGMASK                                   ; clear gain bits in A
0896: 48 00 04 TST   [X+0],0x4          (0163)    tst  [X],HIGHGAIN                                      ; See if High Gain is set
0899: B0 0E    JNZ   0x08A8             (0164)    jnz  .SETHIGHGAIN
089B: 41 70 FE AND   REG[0x70],0xFE     (0165)    and  reg[PGA_1_GAIN_CR3],~EXGAIN                        ; Clear High Gain bit.
089E: 2B 00    OR    A,[X+0]            (0166)    or   A, [X]                                            ; combine gain value with balance of reg.
08A0: 60 71    MOV   REG[0x71],A        (0167)    mov  reg[PGA_1_GAIN_CR0], A                             ; move complete value back to register
08A2: 18       POP   A                  (0168)    pop  A
08A3: 70 3F    AND   F,0x3F             
08A5: 71 C0    OR    F,0xC0             
                                        (0169)    RAM_EPILOGUE RAM_USE_CLASS_2
08A7: 7F       RET                      (0170)    ret
                                        (0171) 
                                        (0172) .SETHIGHGAIN:
08A8: 27 00 18 AND   [X+0],0x18         (0173)    and  [X],HIGHGAINMASK                                  ; Make sure we have a valid high gain
08AB: 2B 00    OR    A,[X+0]            (0174)    or   A, [X]                                            ; combine gain value with balance of reg.
08AD: 60 71    MOV   REG[0x71],A        (0175)    mov  reg[PGA_1_GAIN_CR0], A                             ; move complete value back to register
08AF: 43 70 01 OR    REG[0x70],0x1      (0176)    or   reg[PGA_1_GAIN_CR3], EXGAIN                        ; Set High Gain bit.
08B2: 18       POP   A                  (0177)    pop  A
08B3: 70 3F    AND   F,0x3F             
08B5: 71 C0    OR    F,0xC0             
                                        (0178)    RAM_EPILOGUE RAM_USE_CLASS_2
08B7: 7F       RET                      (0179)    ret
                                        (0180) .ENDSECTION
                                        (0181) 
                                        (0182) .SECTION
                                        (0183) ;-----------------------------------------------------------------------------
                                        (0184) ;  FUNCTION NAME: PGA_1_Stop
                                        (0185) ;
                                        (0186) ;  DESCRIPTION:
                                        (0187) ;    Turns off the power to the amplifier.
                                        (0188) ;
                                        (0189) ;-----------------------------------------------------------------------------
                                        (0190) ;
                                        (0191) ;  ARGUMENTS: None
                                        (0192) ;
                                        (0193) ;  RETURNS:  NA
                                        (0194) ;
                                        (0195) ;  SIDE EFFECTS:
                                        (0196) ;    The A and X registers may be modified by this or future implementations
                                        (0197) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0198) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0199) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0200) ;    functions.
                                        (0201) ;
                                        (0202)  PGA_1_Stop:
                                        (0203) _PGA_1_Stop:
                                        (0204) 
                                        (0205)    RAM_PROLOGUE RAM_USE_CLASS_1
08B8: 41 73 FC AND   REG[0x73],0xFC     (0206)    and REG[PGA_1_GAIN_CR2], ~POWERMASK
                                        (0207)    RAM_EPILOGUE RAM_USE_CLASS_1
08BB: 7F       RET                      (0208)    ret
                                        (0209) .ENDSECTION
                                        (0210) 
                                        (0211) IF (PGA_1_AGNDBUFAPI)
                                        (0212) .SECTION
                                        (0213) ;-----------------------------------------------------------------------------
                                        (0214) ;  FUNCTION NAME: PGA_1_EnableAGNDBuffer
                                        (0215) ;
                                        (0216) ;  DESCRIPTION:
                                        (0217) ;    Turns on the AGND buffer power.
                                        (0218) ;
                                        (0219) ;-----------------------------------------------------------------------------
                                        (0220) ;
                                        (0221) ;  ARGUMENTS: None
                                        (0222) ;
                                        (0223) ;  RETURNS:  NA
                                        (0224) ;
                                        (0225) ;  SIDE EFFECTS:
                                        (0226) ;    The A and X registers may be modified by this or future implementations
                                        (0227) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0228) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0229) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0230) ;    functions.
                                        (0231) ;
                                        (0232)  PGA_1_EnableAGNDBuffer:
                                        (0233) _PGA_1_EnableAGNDBuffer:
                                        (0234)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0235)    and   reg[PGA_1_GAIN_CR3], ~AGNDBUFMASK
                                        (0236)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0237)    ret
                                        (0238) .ENDSECTION
                                        (0239) 
                                        (0240) .SECTION
                                        (0241) ;-----------------------------------------------------------------------------
                                        (0242) ;  FUNCTION NAME: PGA_1_DisableAGNDBuffer
                                        (0243) ;
                                        (0244) ;  DESCRIPTION:
                                        (0245) ;    Turns off the AGND buffer power.
                                        (0246) ;
                                        (0247) ;-----------------------------------------------------------------------------
                                        (0248) ;
                                        (0249) ;  ARGUMENTS: None
                                        (0250) ;
                                        (0251) ;  RETURNS:  NA
                                        (0252) ;
                                        (0253) ;  SIDE EFFECTS:
                                        (0254) ;    The A and X registers may be modified by this or future implementations
                                        (0255) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0256) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0257) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0258) ;    functions.
                                        (0259) ;
                                        (0260)  PGA_1_DisableAGNDBuffer:
                                        (0261) _PGA_1_DisableAGNDBuffer:
                                        (0262)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0263)    or    reg[PGA_1_GAIN_CR3], AGNDBUFMASK
                                        (0264)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0265)    ret
                                        (0266) .ENDSECTION
                                        (0267) ENDIF
                                        (0268) 
                                        (0269) ; End of File PGA_1.asm
FILE: lib\digbuf_1int.asm               (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: DigBuf_1INT.asm
                                        (0004) ;;   Version: 1.3, Updated on 2012/3/2 at 9:14:31
                                        (0005) ;;  Generated by PSoC Designer 5.2.2551
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: DigBuf Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "memory.inc"
                                        (0015) 
                                        (0016) ;-----------------------------------------------
                                        (0017) ;  Global Symbols
                                        (0018) ;-----------------------------------------------
                                        (0019) export  _DigBuf_1_ISR
                                        (0020) 
                                        (0021) 
                                        (0022) AREA InterruptRAM (RAM,REL,CON)
                                        (0023) 
                                        (0024) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0025) ;---------------------------------------------------
                                        (0026) ; Insert your custom declarations below this banner
                                        (0027) ;---------------------------------------------------
                                        (0028) 
                                        (0029) ;------------------------
                                        (0030) ; Includes
                                        (0031) ;------------------------
                                        (0032) 
                                        (0033) 	
                                        (0034) ;------------------------
                                        (0035) ;  Constant Definitions
                                        (0036) ;------------------------
                                        (0037) 
                                        (0038) 
                                        (0039) ;------------------------
                                        (0040) ; Variable Allocation
                                        (0041) ;------------------------
                                        (0042) 
                                        (0043) 
                                        (0044) ;---------------------------------------------------
                                        (0045) ; Insert your custom declarations above this banner
                                        (0046) ;---------------------------------------------------
                                        (0047) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0048) 
                                        (0049) 
                                        (0050) AREA UserModules (ROM, REL)
                                        (0051) 
                                        (0052) ;-----------------------------------------------------------------------------
                                        (0053) ;  FUNCTION NAME: _DigBuf_1_ISR
                                        (0054) ;
                                        (0055) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0056) ;
                                        (0057) ;-----------------------------------------------------------------------------
                                        (0058) ;
                                        (0059) 
                                        (0060) _DigBuf_1_ISR:
                                        (0061) 
                                        (0062)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0063)    ;---------------------------------------------------
                                        (0064)    ; Insert your custom assembly code below this banner
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ;   NOTE: interrupt service routines must preserve
                                        (0067)    ;   the values of the A and X CPU registers.
                                        (0068)    
                                        (0069)    ;---------------------------------------------------
                                        (0070)    ; Insert your custom assembly code above this banner
                                        (0071)    ;---------------------------------------------------
                                        (0072)    
                                        (0073)    ;---------------------------------------------------
                                        (0074)    ; Insert a lcall to a C function below this banner
                                        (0075)    ; and un-comment the lines between these banners
                                        (0076)    ;---------------------------------------------------
                                        (0077)    
                                        (0078)    ;PRESERVE_CPU_CONTEXT
08BC: 7D 0D 73 LJMP  _My_gpio_p2_6      (0079)    ljmp _My_gpio_p2_6
                                        (0080)    ;RESTORE_CPU_CONTEXT
                                        (0081)    
                                        (0082)    ;---------------------------------------------------
                                        (0083)    ; Insert a lcall to a C function above this banner
                                        (0084)    ; and un-comment the lines between these banners
                                        (0085)    ;---------------------------------------------------
                                        (0086)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0087) 
08BF: 7E       RETI                     (0088)    reti
                                        (0089) 
                                        (0090) 
                                        (0091) ; end of file DigBuf_1INT.asm
FILE: lib\digbuf_1.asm                  (0001) ;;*****************************************************************************
08C0: 43 DF 01 OR    REG[0xDF],0x1      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: DigBuf_1.asm
                                        (0004) ;;  Version: 1.3, Updated on 2012/3/2 at 9:14:31
                                        (0005) ;;  Generated by PSoC Designer 5.2.2551
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: DigitalBuffers User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "DigBuf_1.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  DigBuf_1_EnableInt
                                        (0030) export _DigBuf_1_EnableInt
                                        (0031) export  DigBuf_1_DisableInt
                                        (0032) export _DigBuf_1_DisableInt
                                        (0033) export  DigBuf_1_Start
                                        (0034) export _DigBuf_1_Start
                                        (0035) export  DigBuf_1_Stop
                                        (0036) export _DigBuf_1_Stop
                                        (0037) 
                                        (0038) AREA bss (RAM,REL)
                                        (0039) 
                                        (0040) ;-----------------------------------------------
                                        (0041) ;  Constant Definitions
                                        (0042) ;-----------------------------------------------
                                        (0043) 
                                        (0044) 
                                        (0045) ;-----------------------------------------------
                                        (0046) ; Variable Allocation
                                        (0047) ;-----------------------------------------------
                                        (0048) 
                                        (0049) 
                                        (0050) AREA UserModules (ROM, REL)
                                        (0051) 
                                        (0052) .SECTION
                                        (0053) ;-----------------------------------------------------------------------------
                                        (0054) ;  FUNCTION NAME: DigBuf_1_EnableInt
                                        (0055) ;
                                        (0056) ;  DESCRIPTION:
                                        (0057) ;     Enables the DigBuf's interrupt by setting the interrupt enable mask bit
                                        (0058) ;     associated with this User Module. This function has no effect until and
                                        (0059) ;     unless the global interrupts are enabled (for example by using the
                                        (0060) ;     macro M8C_EnableGInt).
                                        (0061) ;-----------------------------------------------------------------------------
                                        (0062) ;
                                        (0063) ;  ARGUMENTS:    None.
                                        (0064) ;  RETURNS:      Nothing.
                                        (0065) ;  SIDE EFFECTS:
                                        (0066) ;    The A and X registers may be modified by this or future implementations
                                        (0067) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0068) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0069) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0070) ;    functions.
                                        (0071) ;
                                        (0072)  DigBuf_1_EnableInt:
                                        (0073) _DigBuf_1_EnableInt:
                                        (0074)    RAM_PROLOGUE RAM_USE_CLASS_1   
                                        (0075)    DigBuf_1_EnableInt_M
                                        (0076)    RAM_EPILOGUE RAM_USE_CLASS_1
08C3: 7F       RET                      (0077)    ret
08C4: 41 DF FE AND   REG[0xDF],0xFE     
                                        (0078) 
                                        (0079) .ENDSECTION
                                        (0080) 
                                        (0081) .SECTION
                                        (0082) ;-----------------------------------------------------------------------------
                                        (0083) ;  FUNCTION NAME: DigBuf_1_DisableInt
                                        (0084) ;
                                        (0085) ;  DESCRIPTION:
                                        (0086) ;     Disables the DigBuf's interrupt by clearing the interrupt enable mask bit
                                        (0087) ;     associated with this User Module. 
                                        (0088) ;-----------------------------------------------------------------------------
                                        (0089) ;
                                        (0090) ;  ARGUMENTS:    None.
                                        (0091) ;  RETURNS:      Nothing.
                                        (0092) ;  SIDE EFFECTS:
                                        (0093) ;    The A and X registers may be modified by this or future implementations
                                        (0094) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0095) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0096) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0097) ;    functions.
                                        (0098) ;
                                        (0099)  DigBuf_1_DisableInt:
                                        (0100) _DigBuf_1_DisableInt:
                                        (0101)    RAM_PROLOGUE RAM_USE_CLASS_1   
                                        (0102)    DigBuf_1_DisableInt_M
                                        (0103)    RAM_EPILOGUE RAM_USE_CLASS_1
08C7: 7F       RET                      (0104)    ret
08C8: 43 43 01 OR    REG[0x43],0x1      
                                        (0105) 
                                        (0106) .ENDSECTION
                                        (0107) 
                                        (0108) .SECTION
                                        (0109) ;-----------------------------------------------------------------------------
                                        (0110) ;  FUNCTION NAME: DigBuf_1_Start
                                        (0111) ;
                                        (0112) ;  DESCRIPTION:
                                        (0113) ;     Starts the Digital Buffers within the block.
                                        (0114) ;-----------------------------------------------------------------------------
                                        (0115) ;
                                        (0116) ;  ARGUMENTS:    None
                                        (0117) ;  RETURNS:      Nothing
                                        (0118) ;  SIDE EFFECTS:
                                        (0119) ;    The A and X registers may be modified by this or future implementations
                                        (0120) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0121) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0122) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0123) ;    functions.
                                        (0124) ;
                                        (0125)  DigBuf_1_Start:
                                        (0126) _DigBuf_1_Start:
                                        (0127)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0128)    DigBuf_1_Start_M
                                        (0129)    RAM_EPILOGUE RAM_USE_CLASS_1
08CB: 7F       RET                      (0130)    ret
08CC: 41 43 FE AND   REG[0x43],0xFE     
                                        (0131) 
                                        (0132) .ENDSECTION
                                        (0133) 
                                        (0134) .SECTION
                                        (0135) ;-----------------------------------------------------------------------------
                                        (0136) ;  FUNCTION NAME: DigBuf_1_Stop
                                        (0137) ;
                                        (0138) ;  DESCRIPTION:
                                        (0139) ;     Stops the Digital Buffers within the block. The outputs are driven low.
                                        (0140) ;-----------------------------------------------------------------------------
                                        (0141) ;
                                        (0142) ;  ARGUMENTS:    None
                                        (0143) ;  RETURNS:      Nothing
                                        (0144) ;  SIDE EFFECTS:
                                        (0145) ;    The A and X registers may be modified by this or future implementations
                                        (0146) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0147) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0148) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0149) ;    functions.
                                        (0150) ;
                                        (0151)  DigBuf_1_Stop:
                                        (0152) _DigBuf_1_Stop:
                                        (0153)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0154)    DigBuf_1_Stop_M
                                        (0155)    RAM_EPILOGUE RAM_USE_CLASS_1
08CF: 7F       RET                      (0156)    ret
                                        (0157) 
                                        (0158) .ENDSECTION
                                        (0159) 
                                        (0160) 
                                        (0161) ; End of File DigBuf_1.asm
                                        (0162) 
                                        (0163) 
FILE: lib\amux4_1.asm                   (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   AMUX4_1.asm
                                        (0004) ;;  Version: 1.50, Updated on 2012/3/2 at 9:12:26
                                        (0005) ;;  Generated by PSoC Designer 5.2.2551
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: AMux4 User Module software implementation file devices.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) 
                                        (0023) include "AMUX4_1.inc"
                                        (0024) include "m8c.inc"
                                        (0025) include "memory.inc"
                                        (0026) 
                                        (0027) ;-----------------------------------------------
                                        (0028) ;  Global Symbols
                                        (0029) ;-----------------------------------------------
                                        (0030) export  AMUX4_1_InputSelect
                                        (0031) export _AMUX4_1_InputSelect
                                        (0032) 
                                        (0033) export  AMUX4_1_Start
                                        (0034) export _AMUX4_1_Start
                                        (0035) 
                                        (0036) export  AMUX4_1_Stop
                                        (0037) export _AMUX4_1_Stop
                                        (0038) 
                                        (0039) ;-----------------------------------------------
                                        (0040) ;  EQUATES
                                        (0041) ;-----------------------------------------------
                                        (0042) 
                                        (0043) MUXMASK:                     equ 03h
                                        (0044) 
                                        (0045) AREA UserModules (ROM, REL)
                                        (0046) .SECTION
                                        (0047) ;-----------------------------------------------------------------------------
                                        (0048) ;  FUNCTION NAME: AMUX4_1_InputSelect
                                        (0049) ;
                                        (0050) ;  DESCRIPTION:
                                        (0051) ;    Place the signal from one of four port0 pins on the Analog Column bus.
                                        (0052) ;
                                        (0053) ;-----------------------------------------------------------------------------
                                        (0054) ;
                                        (0055) ;  ARGUMENTS:
                                        (0056) ;    A contains the mux input control value
                                        (0057) ;
                                        (0058) ;      Input           Code
                                        (0059) ;   Mux input 0,1       00h
                                        (0060) ;   Mux input 2,3       01h
                                        (0061) ;   Mux input 4,5       02h
                                        (0062) ;   Mux input 6,7       03h
                                        (0063) ;
                                        (0064) ;  RETURNS: none
                                        (0065) ;
                                        (0066) ;  SIDE EFFECTS:
                                        (0067) ;    The A and X registers may be modified by this or future implementations
                                        (0068) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0069) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0070) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0071) ;    functions.
                                        (0072) ;
                                        (0073)  AMUX4_1_InputSelect:
                                        (0074) _AMUX4_1_InputSelect:
                                        (0075)     RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0076) 	
                                        (0077) IF (AMUX4_1_COL_COUNT)
                                        (0078) 	M8C_SetBank1      ; ACE_AMX_IN is in Bank 1
                                        (0079) ENDIF
                                        (0080) 	
08D0: 21 03    AND   A,0x3              (0081)     and  A, MUXMASK                    ; Mask off only valid port0 input bits
08D2: 57 00    MOV   X,0x0              (0082)     mov  X,AMUX4_1_MUX_COL
                                        (0083) .AMUX4_ShiftIt:                         ; Shift value to correct bit position for Mux
08D4: 79       DEC   X                  (0084)     dec  X
08D5: C0 05    JC    0x08DB             (0085)     jc   .AMUX4_SetIt
08D7: 64       ASL   A                  (0086)     asl  A
08D8: 64       ASL   A                  (0087)     asl  A
08D9: 8F FA    JMP   0x08D4             (0088)     jmp  .AMUX4_ShiftIt                ; Loop until bits shifted to 2 LSBs
                                        (0089) 
                                        (0090) .AMUX4_SetIt:
08DB: 4F       MOV   X,SP               (0091)     mov  X,SP                          ; Get current stack location
08DC: 08       PUSH  A                  (0092)     push A                             ; Save a to OR it to AMX_IN later	
                                        (0093) IF (AMUX4_1_COL_COUNT)
                                        (0094) 	mov  A, reg[ACE_AMX_IN]                 ; Get current value of mux control register    
                                        (0095) ELSE
08DD: 5D 60    MOV   A,REG[0x60]        (0096) 	mov  A, reg[AMX_IN]                 ; Get current value of mux control register
                                        (0097) ENDIF
08DF: 21 FC    AND   A,0xFC             (0098)     and  A,~AMUX4_1_MUX_MASK           ; Mask off the bits for this Mux
08E1: 2B 00    OR    A,[X+0]            (0099)     or   A,[X]                         ; OR in the mux control bits
                                        (0100) IF (AMUX4_1_COL_COUNT)
                                        (0101) 	mov  reg[ACE_AMX_IN], A                 ; Get current value of mux control register    
                                        (0102) ELSE
08E3: 60 60    MOV   REG[0x60],A        (0103) 	mov  reg[AMX_IN], A                 ; Write out mux value to mux control register
                                        (0104) ENDIF	
08E5: 18       POP   A                  (0105)     pop  A                             ; Restore the stack
08E6: 70 3F    AND   F,0x3F             
08E8: 71 C0    OR    F,0xC0             
                                        (0106) 	
                                        (0107) IF (AMUX4_1_COL_COUNT)
                                        (0108) 	M8C_SetBank0
                                        (0109) ENDIF
                                        (0110)     RAM_EPILOGUE RAM_USE_CLASS_2
08EA: 7F       RET                      (0111)     ret
                                        (0112) .ENDSECTION
                                        (0113) 
                                        (0114) .SECTION
                                        (0115) ;-----------------------------------------------------------------------------
                                        (0116) ;  FUNCTION NAME: AMUX4_1_Start
                                        (0117) ;
                                        (0118) ;  DESCRIPTION:
                                        (0119) ;   This function does nothing at this time.  It is only here for
                                        (0120) ;   future compatibility.
                                        (0121) ;
                                        (0122) ;-----------------------------------------------------------------------------
                                        (0123) ;
                                        (0124) ;  ARGUMENTS: none
                                        (0125) ;
                                        (0126) ;  RETURNS: none
                                        (0127) ;
                                        (0128) ;  SIDE EFFECTS:
                                        (0129) ;    The A and X registers may be modified by this or future implementations
                                        (0130) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0131) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0132) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0133) ;    functions.
                                        (0134) ;
                                        (0135)  AMUX4_1_Start:
                                        (0136) _AMUX4_1_Start:
                                        (0137)     RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0138)     RAM_EPILOGUE RAM_USE_CLASS_1
08EB: 7F       RET                      (0139)     ret
                                        (0140) .ENDSECTION
                                        (0141) 
                                        (0142) .SECTION
                                        (0143) ;-----------------------------------------------------------------------------
                                        (0144) ;  FUNCTION NAME: AMUX4_1_Stop
                                        (0145) ;
                                        (0146) ;  DESCRIPTION:
                                        (0147) ;   This function does nothing at this time.  It is only here for
                                        (0148) ;   future compatibility.
                                        (0149) ;
                                        (0150) ;-----------------------------------------------------------------------------
                                        (0151) ;
                                        (0152) ;  ARGUMENTS:  none
                                        (0153) ;
                                        (0154) ;  RETURNS: none
                                        (0155) ;
                                        (0156) ;  SIDE EFFECTS:
                                        (0157) ;    The A and X registers may be modified by this or future implementations
                                        (0158) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0159) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0160) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0161) ;    functions.
                                        (0162) ;
                                        (0163)  AMUX4_1_Stop:
                                        (0164) _AMUX4_1_Stop:
                                        (0165)     RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0166)     RAM_EPILOGUE RAM_USE_CLASS_1
08EC: 7F       RET                      (0167)     ret
                                        (0168) .ENDSECTION
                                        (0169) ; End of File AMUX4_1.asm
FILE: lib\adcinc_1int.asm               (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: ADCINC_1INT.asm
                                        (0004) ;;  Version: 1.20, Updated on 2012/3/2 at 9:12:19
                                        (0005) ;;
                                        (0006) ;;  DESCRIPTION: Assembler interrupt service routine for the ADCINC
                                        (0007) ;;               A/D Converter User Module. This code works for both the
                                        (0008) ;;               first and second-order modulator topologies.
                                        (0009) ;;-----------------------------------------------------------------------------
                                        (0010) ;;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0011) ;;*****************************************************************************
                                        (0012) ;;*****************************************************************************
                                        (0013) 
                                        (0014) include "m8c.inc"
                                        (0015) include "memory.inc"
                                        (0016) include "ADCINC_1.inc"
                                        (0017) 
                                        (0018) 
                                        (0019) ;-----------------------------------------------
                                        (0020) ;  Global Symbols
                                        (0021) ;-----------------------------------------------
                                        (0022) 
                                        (0023) export _ADCINC_1_ADConversion_ISR
                                        (0024) 
                                        (0025) export _ADCINC_1_iResult
                                        (0026) export  ADCINC_1_iResult
                                        (0027) export _ADCINC_1_fStatus
                                        (0028) export  ADCINC_1_fStatus
                                        (0029) export _ADCINC_1_bState
                                        (0030) export  ADCINC_1_bState
                                        (0031) export _ADCINC_1_fMode
                                        (0032) export  ADCINC_1_fMode
                                        (0033) export _ADCINC_1_bNumSamples
                                        (0034) export  ADCINC_1_bNumSamples
                                        (0035) 
                                        (0036) ;-----------------------------------------------
                                        (0037) ; Variable Allocation
                                        (0038) ;-----------------------------------------------
                                        (0039) AREA InterruptRAM(RAM,REL)
                                        (0040)  ADCINC_1_iResult:
                                        (0041) _ADCINC_1_iResult:                         BLK  2 ;Calculated answer
                                        (0042)   iTemp:                                   BLK  2 ;internal temp storage
                                        (0043)  ADCINC_1_fStatus:
                                        (0044) _ADCINC_1_fStatus:                         BLK  1 ;ADC Status
                                        (0045)  ADCINC_1_bState:
                                        (0046) _ADCINC_1_bState:                          BLK  1 ;State value of ADC count
                                        (0047)  ADCINC_1_fMode:
                                        (0048) _ADCINC_1_fMode:                           BLK  1 ;Integrate and reset mode.
                                        (0049)  ADCINC_1_bNumSamples:
                                        (0050) _ADCINC_1_bNumSamples:                     BLK  1 ;Number of samples to take.
                                        (0051) 
                                        (0052) ;-----------------------------------------------
                                        (0053) ;  EQUATES
                                        (0054) ;-----------------------------------------------
                                        (0055) 
                                        (0056) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0057) ;---------------------------------------------------
                                        (0058) ; Insert your custom declarations below this banner
                                        (0059) ;---------------------------------------------------
                                        (0060) 
                                        (0061) ;------------------------
                                        (0062) ;  Constant Definitions
                                        (0063) ;------------------------
                                        (0064) 
                                        (0065) 
                                        (0066) ;------------------------
                                        (0067) ; Variable Allocation
                                        (0068) ;------------------------
                                        (0069) 
                                        (0070) 
                                        (0071) ;---------------------------------------------------
                                        (0072) ; Insert your custom declarations above this banner
                                        (0073) ;---------------------------------------------------
                                        (0074) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0075) 
                                        (0076) 
                                        (0077) AREA UserModules (ROM, REL)
                                        (0078) 
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ;  FUNCTION NAME: _ADCINC_1_ADConversion_ISR
                                        (0081) ;
                                        (0082) ;  DESCRIPTION: Perform final filter operations to produce output samples.
                                        (0083) ;
                                        (0084) ;-----------------------------------------------------------------------------
                                        (0085) ;
                                        (0086) ;    The decimation rate is established by the PWM interrupt. Four timer
                                        (0087) ;    clocks elapse for each modulator output (decimator input) since the
                                        (0088) ;    phi1/phi2 generator divides by 4. This means the timer period and thus
                                        (0089) ;    it's interrupt must equal 4 times the actual decimation rate.  The
                                        (0090) ;    decimator is ru  for 2^(#bits-6).
                                        (0091) ;
                                        (0092) _ADCINC_1_ADConversion_ISR:
08ED: 7A 05    DEC   [0x5]              (0093)     dec  [ADCINC_1_bState]
                                        (0094) if1:
08EF: C0 02    JC    0x08F2             (0095)     jc endif1 ; no underflow
08F1: 7E       RETI                     (0096)     reti
                                        (0097) endif1:
08F2: 3C 06 00 CMP   [0x6],0x0          (0098)     cmp [ADCINC_1_fMode],0
                                        (0099) if2: 
08F5: B0 12    JNZ   0x0908             (0100)     jnz endif2  ;leaving reset mode
08F7: 08       PUSH  A                  (0101)     push A                            ;read decimator
08F8: 5D E5    MOV   A,REG[0xE5]        (0102)     mov  A, reg[DEC_DL]
08FA: 53 03    MOV   [0x3],A            (0103)     mov  [iTemp + LowByte],A
08FC: 5D E4    MOV   A,REG[0xE4]        (0104)     mov  A, reg[DEC_DH]
08FE: 53 02    MOV   [0x2],A            (0105)     mov  [iTemp + HighByte], A
0900: 18       POP   A                  (0106)     pop A
0901: 55 06 01 MOV   [0x6],0x1          (0107)     mov [ADCINC_1_fMode],1
0904: 55 05 1F MOV   [0x5],0x1F         (0108)     mov [ADCINC_1_bState],((1<<(ADCINC_1_bNUMBITS- 6))-1)
0907: 7E       RETI                     (0109)     reti
0908: 43 82 20 OR    REG[0x82],0x20     
090B: 43 83 10 OR    REG[0x83],0x10     
                                        (0110) endif2:
                                        (0111)     ;This code runs at end of integrate
                                        (0112)     ADCINC_1_RESET_INTEGRATOR_M
090E: 08       PUSH  A                  (0113)     push A
090F: 5D E5    MOV   A,REG[0xE5]        (0114)     mov  A, reg[DEC_DL]
0911: 12 03    SUB   A,[0x3]            (0115)     sub  A,[iTemp + LowByte]
0913: 53 03    MOV   [0x3],A            (0116)     mov  [iTemp +LowByte],A
0915: 5D E4    MOV   A,REG[0xE4]        (0117)     mov  A, reg[DEC_DH]
0917: 1A 02    SBB   A,[0x2]            (0118)     sbb  A,[iTemp + HighByte]
                                        (0119) 
                                        (0120)        ;check for overflow
                                        (0121) IF     ADCINC_1_8_OR_MORE_BITS
0919: 39 08    CMP   A,0x8              (0122)     cmp A,(1<<(ADCINC_1_bNUMBITS - 8))
                                        (0123) if3: 
091B: B0 05    JNZ   0x0921             (0124)     jnz endif3 ;overflow
091D: 78       DEC   A                  (0125)     dec A
091E: 55 03 FF MOV   [0x3],0xFF         (0126)     mov [iTemp + LowByte],ffh
                                        (0127) endif3:
                                        (0128) ELSE
                                        (0129)     cmp [iTemp + LowByte],(1<<(ADCINC_1_bNUMBITS))
                                        (0130) if4: 
                                        (0131)     jnz endif4 ;overflow
                                        (0132)     dec [iTemp + LowByte]
                                        (0133) endif4:
                                        (0134) ENDIF
                                        (0135) IF ADCINC_1_SIGNED_DATA
                                        (0136) IF ADCINC_1_9_OR_MORE_BITS
                                        (0137)     sub A,(1<<(ADCINC_1_bNUMBITS - 9))
                                        (0138) ELSE
                                        (0139)     sub [iTemp +LowByte],(1<<(ADCINC_1_bNUMBITS - 1))
                                        (0140)     sbb A,0
                                        (0141) ENDIF
                                        (0142) ENDIF
0921: 5F 01 03 MOV   [0x1],[0x3]        (0143)     mov  [ADCINC_1_iResult + LowByte],[iTemp +LowByte]
0924: 53 00    MOV   [0x0],A            (0144)     mov  [ADCINC_1_iResult + HighByte],A
0926: 55 04 01 MOV   [0x4],0x1          (0145)     mov  [ADCINC_1_fStatus],1
                                        (0146) ConversionReady:
                                        (0147)     ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0148)     ;---------------------------------------------------
                                        (0149)     ; Insert your custom code below this banner
                                        (0150)     ;---------------------------------------------------
                                        (0151)     ;  Sample data is now in iResult
                                        (0152)     ;
                                        (0153)     ;  NOTE: This interrupt service routine has already
                                        (0154)     ;  preserved the values of the A CPU register. If
                                        (0155)     ;  you need to use the X register you must preserve
                                        (0156)     ;  its value and restore it before the return from
                                        (0157)     ;  interrupt.
                                        (0158)     ;---------------------------------------------------
                                        (0159)     ; Insert your custom code above this banner
                                        (0160)     ;---------------------------------------------------
                                        (0161)     ;@PSoC_UserCode_END@ (Do not change this line.)
0929: 18       POP   A                  (0162)     pop A
092A: 3C 07 00 CMP   [0x7],0x0          (0163)     cmp [ADCINC_1_bNumSamples],0
                                        (0164) if5: 
092D: B0 0E    JNZ   0x093C             (0165)     jnz endif5 ; Number of samples is zero
092F: 55 06 00 MOV   [0x6],0x0          (0166)     mov [ADCINC_1_fMode],0
0932: 55 05 00 MOV   [0x5],0x0          (0167)     mov [ADCINC_1_bState],0
0935: 41 83 EF AND   REG[0x83],0xEF     
0938: 41 82 DF AND   REG[0x82],0xDF     
                                        (0168)     ADCINC_1_ENABLE_INTEGRATOR_M
093B: 7E       RETI                     (0169)     reti       
                                        (0170) endif5:
093C: 7A 07    DEC   [0x7]              (0171)     dec [ADCINC_1_bNumSamples]
                                        (0172) if6:
093E: A0 0E    JZ    0x094D             (0173)     jz endif6  ; count not zero
0940: 55 06 00 MOV   [0x6],0x0          (0174)     mov [ADCINC_1_fMode],0
0943: 55 05 00 MOV   [0x5],0x0          (0175)     mov [ADCINC_1_bState],0
0946: 41 83 EF AND   REG[0x83],0xEF     
0949: 41 82 DF AND   REG[0x82],0xDF     
                                        (0176)     ADCINC_1_ENABLE_INTEGRATOR_M
094C: 7E       RETI                     (0177)     reti       
094D: 71 10    OR    F,0x10             
                                        (0178) endif6:
                                        (0179)     ;All samples done
                                        (0180)     M8C_SetBank1
094F: 41 E7 3F AND   REG[0xE7],0x3F     (0181)     and reg[E7h], 3Fh            ; if we are in 29xxx or 24x94   
0952: 43 E7 80 OR    REG[0xE7],0x80     (0182)     or  reg[E7h], 80h            ; then set to incremental Mode
0955: 70 EF    AND   F,0xEF             
0957: 41 E1 7F AND   REG[0xE1],0x7F     
                                        (0183)     M8C_SetBank0
                                        (0184)     ADCINC_1_STOPADC_M
095A: 7E       RETI                     (0185)  reti 
FILE: lib\adcinc_1.asm                  (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: ADCINC_1.asm
                                        (0004) ;;   Version: 1.20, Updated on 2012/3/2 at 9:12:19
                                        (0005) ;;  Generated by PSoC Designer 5.2.2551
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Assembler source for the ADCINC A/D Converter
                                        (0008) ;;               User Module with 1st-order modulator.
                                        (0009) ;;
                                        (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0012) ;;        This means it is the caller's responsibility to preserve any values
                                        (0013) ;;        in the X and A registers that are still needed after the API
                                        (0014) ;;        function returns. Even though these registers may be preserved now,
                                        (0015) ;;        there is no guarantee they will be preserved in future releases.
                                        (0016) ;;-----------------------------------------------------------------------------
                                        (0017) ;;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0018) ;;*****************************************************************************
                                        (0019) ;;*****************************************************************************
                                        (0020) 
                                        (0021) include "m8c.inc"
                                        (0022) include "memory.inc"
                                        (0023) 
                                        (0024) include "ADCINC_1.inc"
                                        (0025) 
                                        (0026) 
                                        (0027) ;-----------------------------------------------
                                        (0028) ;  Global Symbols
                                        (0029) ;-----------------------------------------------
                                        (0030) export  ADCINC_1_Start
                                        (0031) export _ADCINC_1_Start
                                        (0032) export  ADCINC_1_SetPower
                                        (0033) export _ADCINC_1_SetPower
                                        (0034) export  ADCINC_1_Stop
                                        (0035) export _ADCINC_1_Stop
                                        (0036) export  ADCINC_1_GetSamples
                                        (0037) export _ADCINC_1_GetSamples
                                        (0038) export  ADCINC_1_StopADC
                                        (0039) export _ADCINC_1_StopADC
                                        (0040) export  ADCINC_1_fIsDataAvailable
                                        (0041) export _ADCINC_1_fIsDataAvailable
                                        (0042) export  ADCINC_1_iClearFlagGetData
                                        (0043) export _ADCINC_1_iClearFlagGetData
                                        (0044) export  ADCINC_1_wClearFlagGetData
                                        (0045) export _ADCINC_1_wClearFlagGetData
                                        (0046) export  ADCINC_1_cClearFlagGetData
                                        (0047) export _ADCINC_1_cClearFlagGetData
                                        (0048) export  ADCINC_1_bClearFlagGetData
                                        (0049) export _ADCINC_1_bClearFlagGetData
                                        (0050) export  ADCINC_1_iGetData
                                        (0051) export _ADCINC_1_iGetData
                                        (0052) export  ADCINC_1_wGetData
                                        (0053) export _ADCINC_1_wGetData
                                        (0054) export  ADCINC_1_bGetData
                                        (0055) export _ADCINC_1_bGetData
                                        (0056) export  ADCINC_1_cGetData
                                        (0057) export _ADCINC_1_cGetData
                                        (0058) export  ADCINC_1_fClearFlag
                                        (0059) export _ADCINC_1_fClearFlag
                                        (0060) export  ADCINC_1_WritePulseWidth
                                        (0061) export _ADCINC_1_WritePulseWidth
                                        (0062) 
                                        (0063) 
                                        (0064) AREA bss (RAM,REL)
                                        (0065) 
                                        (0066) ;-----------------------------------------------
                                        (0067) ;  Constant Definitions
                                        (0068) ;-----------------------------------------------
                                        (0069) 
                                        (0070) ;-----------------------------------------------
                                        (0071) ; Variable Allocation
                                        (0072) ;-----------------------------------------------
                                        (0073) 
                                        (0074) 
                                        (0075) AREA UserModules (ROM, REL)
                                        (0076) 
                                        (0077) .SECTION
                                        (0078) ;-----------------------------------------------------------------------------
                                        (0079) ;  FUNCTION NAME: ADCINC_1_Start
                                        (0080) ;
                                        (0081) ;  DESCRIPTION: Applies power setting to the module's analog PSoc block.
                                        (0082) ;               and starts the PWM
                                        (0083) ;-----------------------------------------------------------------------------
                                        (0084) ;
                                        (0085) ;  ARGUMENTS:    The A register contains the power setting.
                                        (0086) ;  RETURNS:      Nothing.
                                        (0087) ;  SIDE EFFECTS:
                                        (0088) ;    The A and X registers may be modified by this or future implementations
                                        (0089) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0090) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0091) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0092) ;    functions.
                                        (0093) ;
                                        (0094)  ADCINC_1_Start:
                                        (0095) _ADCINC_1_Start:
                                        (0096)    RAM_PROLOGUE RAM_USE_CLASS_1
095B: 90 0D    CALL  _ADCINC_1_SetPower (0097)    call  ADCINC_1_SetPower
095D: 43 82 20 OR    REG[0x82],0x20     
0960: 43 83 10 OR    REG[0x83],0x10     
                                        (0098)    ADCINC_1_RESET_INTEGRATOR_M
0963: 62 3D FF MOV   REG[0x3D],0xFF     (0099)    mov   reg[ADCINC_1_PWMdr1],ffh
0966: 43 3F 01 OR    REG[0x3F],0x1      (0100)    or    reg[ADCINC_1_PWMcr0],01h                    ; start PWM
                                        (0101)    RAM_EPILOGUE RAM_USE_CLASS_1
0969: 7F       RET                      (0102)    ret
                                        (0103) .ENDSECTION
                                        (0104) 
                                        (0105)    
                                        (0106) .SECTION
                                        (0107) ;-----------------------------------------------------------------------------
                                        (0108) ;  FUNCTION NAME: ADCINC_1_SetPower
                                        (0109) ;
                                        (0110) ;  DESCRIPTION: Applies power setting to the module's analog PSoc block.
                                        (0111) ;-----------------------------------------------------------------------------
                                        (0112) ;
                                        (0113) ;  ARGUMENTS:    The A register contains the power setting.
                                        (0114) ;  RETURNS:      Nothing.
                                        (0115) ;  SIDE EFFECTS:
                                        (0116) ;    The A and X registers may be modified by this or future implementations
                                        (0117) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0118) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0119) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0120) ;    functions.
                                        (0121) ;
                                        (0122)  ADCINC_1_SetPower:
                                        (0123) _ADCINC_1_SetPower:
                                        (0124)    RAM_PROLOGUE RAM_USE_CLASS_2
096A: 4F       MOV   X,SP               (0125)    mov  X,SP                                     ; Set up Stack frame
096B: 21 03    AND   A,0x3              (0126)    and  A,03h                                    ; Ensure value is legal
096D: 08       PUSH  A                  (0127)    push A
096E: 5D 83    MOV   A,REG[0x83]        (0128)    mov  A,reg[ADCINC_1_AtoDcr3]                  ; First SC block:
0970: 21 FC    AND   A,0xFC             (0129)    and  A,~03h                                   ;   clear power bits to zero
0972: 2B 00    OR    A,[X+0]            (0130)    or   A,[ X ]                                  ;   establish new value
0974: 60 83    MOV   REG[0x83],A        (0131)    mov  reg[ADCINC_1_AtoDcr3],A                  ;   change the actual setting
0976: 18       POP   A                  (0132)    pop  A
0977: 70 3F    AND   F,0x3F             
0979: 71 C0    OR    F,0xC0             
                                        (0133)    RAM_EPILOGUE RAM_USE_CLASS_2
097B: 7F       RET                      (0134)    ret
097C: 41 E1 7F AND   REG[0xE1],0x7F     
                                        (0135) .ENDSECTION
                                        (0136) 
                                        (0137) .SECTION
                                        (0138) ;-----------------------------------------------------------------------------
                                        (0139) ;  FUNCTION NAME: ADCINC_1_Stop
                                        (0140) ;
                                        (0141) ;  DESCRIPTION:   Removes power from the module's analog PSoc block.
                                        (0142) ;                 and turns off PWM
                                        (0143) ;-----------------------------------------------------------------------------
                                        (0144) ;
                                        (0145) ;  ARGUMENTS:     None.
                                        (0146) ;  RETURNS:       Nothing.
                                        (0147) ;  SIDE EFFECTS:
                                        (0148) ;    The A and X registers may be modified by this or future implementations
                                        (0149) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0150) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0151) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0152) ;    functions.
                                        (0153) ;
                                        (0154)  ADCINC_1_Stop:
                                        (0155) _ADCINC_1_Stop:
                                        (0156)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0157)    ADCINC_1_STOPADC_M
097F: 41 83 FC AND   REG[0x83],0xFC     (0158)    and  reg[ADCINC_1_AtoDcr3], ~03h
0982: 41 3F FE AND   REG[0x3F],0xFE     (0159)    and  reg[ADCINC_1_PWMcr0], ~01h ; stop PWM
                                        (0160)    RAM_EPILOGUE RAM_USE_CLASS_1
0985: 7F       RET                      (0161)    ret
0986: 62 D0 00 MOV   REG[0xD0],0x0      
0989: 41 83 EF AND   REG[0x83],0xEF     
098C: 41 82 DF AND   REG[0x82],0xDF     
                                        (0162) .ENDSECTION
                                        (0163) 
                                        (0164) 
                                        (0165) .SECTION
                                        (0166) ;-----------------------------------------------------------------------------
                                        (0167) ;  FUNCTION NAME: ADCINC_1_GetSamples
                                        (0168) ;
                                        (0169) ;  DESCRIPTION: Activates interrupts for this user module and begins sampling.
                                        (0170) ;-----------------------------------------------------------------------------
                                        (0171) ;
                                        (0172) ;  ARGUMENTS:    A register contain number of samples
                                        (0173) ;  RETURNS:      Nothing.
                                        (0174) ;  SIDE EFFECTS:
                                        (0175) ;    The A and X registers may be modified by this or future implementations
                                        (0176) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0177) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0178) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0179) ;    functions.
                                        (0180) ;          
                                        (0181) ;    Currently only the page pointer registers listed below are modified: 
                                        (0182) ;          CUR_PP
                                        (0183) ;
                                        (0184)  ADCINC_1_GetSamples:
                                        (0185) _ADCINC_1_GetSamples:
                                        (0186)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0187)    RAM_SETPAGE_CUR >ADCINC_1_fMode
                                        (0188)    ADCINC_1_ENABLE_INTEGRATOR_M
098F: 55 06 00 MOV   [0x6],0x0          (0189)    mov [ADCINC_1_fMode],0
0992: 55 05 00 MOV   [0x5],0x0          (0190)    mov [ADCINC_1_bState],0
0995: 53 07    MOV   [0x7],A            (0191)    mov [ADCINC_1_bNumSamples],A
0997: 5D 3E    MOV   A,REG[0x3E]        (0192)    mov A, reg[ADCINC_1_PWMdr2]
0999: B0 04    JNZ   0x099E             (0193)    jnz  .SkipPulseWrite
099B: 62 3E 01 MOV   REG[0x3E],0x1      (0194)    mov reg[ADCINC_1_PWMdr2], 1
099E: 71 10    OR    F,0x10             
                                        (0195) .SkipPulseWrite:
                                        (0196) 
                                        (0197)    M8C_SetBank1
09A0: 41 E7 3F AND   REG[0xE7],0x3F     (0198)    and reg[E7h], 3Fh             ; if we are in 29xxx or 24x94   
09A3: 43 E7 40 OR    REG[0xE7],0x40     (0199)    or  reg[E7h], 40h             ; then set to incremental Mode
09A6: 70 EF    AND   F,0xEF             
09A8: 62 DB 7F MOV   REG[0xDB],0x7F     
09AB: 43 E1 80 OR    REG[0xE1],0x80     
                                        (0200)    M8C_SetBank0
                                        (0201) 
                                        (0202)    ADCINC_1_STARTADC_M  ;enable interrupt 
                                        (0203)    RAM_EPILOGUE RAM_USE_CLASS_4 
09AE: 7F       RET                      (0204)    ret
09AF: 71 10    OR    F,0x10             
                                        (0205) .ENDSECTION
                                        (0206) 
                                        (0207) 
                                        (0208) .SECTION
                                        (0209) ;-----------------------------------------------------------------------------
                                        (0210) ;  FUNCTION NAME: ADCINC_1_StopADC
                                        (0211) ;
                                        (0212) ;  DESCRIPTION: Shuts down the A/D is an orderly manner.  The interrupt
                                        (0213) ;               is disabled but the PWM output is still active.
                                        (0214) ;               Integrator is reset
                                        (0215) ;-----------------------------------------------------------------------------
                                        (0216) ;
                                        (0217) ;  ARGUMENTS:    None.
                                        (0218) ;  RETURNS:      Nothing.
                                        (0219) ;  SIDE EFFECTS:
                                        (0220) ;    The A and X registers may be modified by this or future implementations
                                        (0221) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0222) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0223) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0224) ;    functions.
                                        (0225) ;
                                        (0226)  ADCINC_1_StopADC:
                                        (0227) _ADCINC_1_StopADC:
                                        (0228)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0229)    M8C_SetBank1
09B1: 41 E7 3F AND   REG[0xE7],0x3F     (0230)    and reg[E7h], 3Fh             ; if we are in 29xxx or 24x94   
09B4: 43 E7 80 OR    REG[0xE7],0x80     (0231)    or  reg[E7h], 80h             ; then set to incremental Mode
09B7: 70 EF    AND   F,0xEF             
09B9: 41 E1 7F AND   REG[0xE1],0x7F     
09BC: 43 82 20 OR    REG[0x82],0x20     
09BF: 43 83 10 OR    REG[0x83],0x10     
                                        (0232)    M8C_SetBank0
                                        (0233)    ADCINC_1_STOPADC_M
                                        (0234)    ADCINC_1_RESET_INTEGRATOR_M
                                        (0235)    RAM_EPILOGUE RAM_USE_CLASS_1 
09C2: 7F       RET                      (0236)    ret
09C3: 62 D0 00 MOV   REG[0xD0],0x0      
09C6: 51 04    MOV   A,[0x4]            
                                        (0237) .ENDSECTION
                                        (0238) 
                                        (0239) 
                                        (0240) .SECTION
                                        (0241) ;-----------------------------------------------------------------------------
                                        (0242) ;  FUNCTION NAME: ADCINC_1_fIsDataAvailable
                                        (0243) ;
                                        (0244) ;  DESCRIPTION: Returns the status of the A/D Data
                                        (0245) ;-----------------------------------------------------------------------------
                                        (0246) ;  ARGUMENTS:    None.
                                        (0247) ;  RETURNS:      fastcall BOOL DataAvailable returned in the A register
                                        (0248) ;  SIDE EFFECTS:
                                        (0249) ;    The A and X registers may be modified by this or future implementations
                                        (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0253) ;    functions.
                                        (0254) ;          
                                        (0255) ;    Currently only the page pointer registers listed below are modified: 
                                        (0256) ;          CUR_PP
                                        (0257) ;
                                        (0258)  ADCINC_1_fIsDataAvailable:
                                        (0259) _ADCINC_1_fIsDataAvailable:
                                        (0260)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0261)    ADCINC_1_fIsDataAvailable_M   
                                        (0262)    RAM_EPILOGUE RAM_USE_CLASS_4
09C8: 7F       RET                      (0263)    ret
09C9: 62 D0 00 MOV   REG[0xD0],0x0      
09CC: 55 04 00 MOV   [0x4],0x0          
09CF: 58 00    MOV   X,[0x0]            
09D1: 51 01    MOV   A,[0x1]            
09D3: 3C 04 00 CMP   [0x4],0x0          
09D6: BF F5    JNZ   0x09CC             
                                        (0264) .ENDSECTION
                                        (0265) 
                                        (0266) 
                                        (0267) .SECTION
                                        (0268) ;-----------------------------------------------------------------------------
                                        (0269) ;  FUNCTION NAME:  ADCINC_1_iClearFlagGetData
                                        (0270) ;                  ADCINC_1_wClearFlagGetData
                                        (0271) ;
                                        (0272) ;  DESCRIPTION:    Clears the fStatus and places ADC data in iResult A/D.
                                        (0273) ;                  Flag is checked after trandfer to insure valid data.
                                        (0274) ;                  available. Also clears the DATA_READY flag. 
                                        (0275) ;-----------------------------------------------------------------------------
                                        (0276) ;  ARGUMENTS:    None.
                                        (0277) ;  RETURNS:      fastcall int iResult returned in the X and A register
                                        (0278) ;  SIDE EFFECTS:
                                        (0279) ;    The A and X registers may be modified by this or future implementations
                                        (0280) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0281) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0282) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0283) ;    functions.
                                        (0284) ;          
                                        (0285) ;    Currently only the page pointer registers listed below are modified: 
                                        (0286) ;          CUR_PP
                                        (0287) ;
                                        (0288)  ADCINC_1_iClearFlagGetData:
                                        (0289) _ADCINC_1_iClearFlagGetData:
                                        (0290)  ADCINC_1_wClearFlagGetData:
                                        (0291) _ADCINC_1_wClearFlagGetData:
                                        (0292)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0293)    ADCINC_1_iClearFlagGetData_M   
                                        (0294)    RAM_EPILOGUE RAM_USE_CLASS_4
09D8: 7F       RET                      (0295)    ret
09D9: 62 D0 00 MOV   REG[0xD0],0x0      
09DC: 55 04 00 MOV   [0x4],0x0          
09DF: 51 01    MOV   A,[0x1]            
                                        (0296) .ENDSECTION
                                        (0297) 
                                        (0298) 
                                        (0299) .SECTION
                                        (0300) ;-----------------------------------------------------------------------------
                                        (0301) ;  FUNCTION NAME:  ADCINC_1_cClearFlagGetData
                                        (0302) ;                  ADCINC_1_bClearFlagGetData
                                        (0303) ;
                                        (0304) ;  DESCRIPTION:    Clears the fStatus and places ADC data in iResult A/D.
                                        (0305) ;-----------------------------------------------------------------------------
                                        (0306) ;  ARGUMENTS:    None.
                                        (0307) ;  RETURNS:      fastcall int iResult returned in the X and A register
                                        (0308) ;  SIDE EFFECTS:
                                        (0309) ;    The A and X registers may be modified by this or future implementations
                                        (0310) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0311) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0312) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0313) ;    functions.
                                        (0314) ;          
                                        (0315) ;    Currently only the page pointer registers listed below are modified: 
                                        (0316) ;          CUR_PP
                                        (0317) ;
                                        (0318)  ADCINC_1_cClearFlagGetData:
                                        (0319) _ADCINC_1_cClearFlagGetData:
                                        (0320)  ADCINC_1_bClearFlagGetData:
                                        (0321) _ADCINC_1_bClearFlagGetData:
                                        (0322)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0323)    ADCINC_1_bClearFlagGetData_M     
                                        (0324)    RAM_EPILOGUE RAM_USE_CLASS_4
09E1: 7F       RET                      (0325)    ret
09E2: 62 D0 00 MOV   REG[0xD0],0x0      
09E5: 58 00    MOV   X,[0x0]            
09E7: 51 01    MOV   A,[0x1]            
                                        (0326) .ENDSECTION
                                        (0327) .SECTION
                                        (0328) ;-----------------------------------------------------------------------------
                                        (0329) ;  FUNCTION NAME:  ADCINC_1_iGetData
                                        (0330) ;				   ADCINC_1_wGetData
                                        (0331) ;
                                        (0332) ;  DESCRIPTION:     Returns the data from the A/D.  Does not check if data is
                                        (0333) ;                   available.
                                        (0334) ;-----------------------------------------------------------------------------
                                        (0335) ;  ARGUMENTS:    None.
                                        (0336) ;  RETURNS:      fastcall int iResult is returned in the X,A registers
                                        (0337) ;  SIDE EFFECTS:
                                        (0338) ;    The A and X registers may be modified by this or future implementations
                                        (0339) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0342) ;    functions.
                                        (0343) ;          
                                        (0344) ;    Currently only the page pointer registers listed below are modified: 
                                        (0345) ;          CUR_PP
                                        (0346) ;
                                        (0347)  ADCINC_1_iGetData:
                                        (0348) _ADCINC_1_iGetData:
                                        (0349)  ADCINC_1_wGetData:
                                        (0350) _ADCINC_1_wGetData:
                                        (0351)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0352)    ADCINC_1_wGetData_M          
                                        (0353)    RAM_EPILOGUE RAM_USE_CLASS_4
09E9: 7F       RET                      (0354)    ret
09EA: 62 D0 00 MOV   REG[0xD0],0x0      
09ED: 51 01    MOV   A,[0x1]            
                                        (0355) .ENDSECTION
                                        (0356) .SECTION
                                        (0357) ;-----------------------------------------------------------------------------
                                        (0358) ;  FUNCTION NAME:  ADCINC_1_bGetData
                                        (0359) ;                  ADCINC_1_cGetData
                                        (0360) ;
                                        (0361) ;  DESCRIPTION:     Returns the data from the A/D.  Does not check if data is
                                        (0362) ;                   available.
                                        (0363) ;-----------------------------------------------------------------------------
                                        (0364) ;  ARGUMENTS:    None.
                                        (0365) ;  RETURNS:      fastcall CHAR cData returned in the A register
                                        (0366) ;  SIDE EFFECTS:
                                        (0367) ;    The A and X registers may be modified by this or future implementations
                                        (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0371) ;    functions.
                                        (0372) ;          
                                        (0373) ;    Currently only the page pointer registers listed below are modified: 
                                        (0374) ;          CUR_PP
                                        (0375) ;
                                        (0376)  ADCINC_1_bGetData:
                                        (0377) _ADCINC_1_bGetData:
                                        (0378)  ADCINC_1_cGetData:
                                        (0379) _ADCINC_1_cGetData:
                                        (0380)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0381)    ADCINC_1_cGetData_M        
                                        (0382)    RAM_EPILOGUE RAM_USE_CLASS_4
09EF: 7F       RET                      (0383)    ret
09F0: 62 D0 00 MOV   REG[0xD0],0x0      
09F3: 51 04    MOV   A,[0x4]            
09F5: 55 04 00 MOV   [0x4],0x0          
                                        (0384) .ENDSECTION
                                        (0385) 
                                        (0386) 
                                        (0387) .SECTION
                                        (0388) ;-----------------------------------------------------------------------------
                                        (0389) ;  FUNCTION NAME: ADCINC_1_fClearFlag
                                        (0390) ;
                                        (0391) ;  DESCRIPTION: Clears the data ready flag.
                                        (0392) ;-----------------------------------------------------------------------------
                                        (0393) ;  ARGUMENTS:    None.
                                        (0394) ;  RETURNS:      Nothing.
                                        (0395) ;  SIDE EFFECTS: 
                                        (0396) ;    The DATA_READY flag is cleared.
                                        (0397) ;    
                                        (0398) ;    The A and X registers may be modified by this or future implementations
                                        (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0402) ;    functions.
                                        (0403) ;          
                                        (0404) ;    Currently only the page pointer registers listed below are modified: 
                                        (0405) ;          CUR_PP
                                        (0406) ;
                                        (0407)  ADCINC_1_fClearFlag:
                                        (0408) _ADCINC_1_fClearFlag:
                                        (0409)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0410)    ADCINC_1_fClearFlag_M    
                                        (0411)    RAM_EPILOGUE RAM_USE_CLASS_4
09F8: 7F       RET                      (0412)    ret
09F9: 60 3E    MOV   REG[0x3E],A        
                                        (0413) .ENDSECTION
                                        (0414) 
                                        (0415) 
                                        (0416) .SECTION
                                        (0417) ;-----------------------------------------------------------------------------
                                        (0418) ;  FUNCTION NAME: ADCINC_1_WritePulseWidth
                                        (0419) ;
                                        (0420) ;  DESCRIPTION:
                                        (0421) ;     Write the 8-bit period value into the compare register (DR2).
                                        (0422) ;-----------------------------------------------------------------------------
                                        (0423) ;
                                        (0424) ;  ARGUMENTS: fastcall BYTE bPeriodValue (passed in A)
                                        (0425) ;  RETURNS:   Nothing
                                        (0426) ;  SIDE EFFECTS:
                                        (0427) ;    The A and X registers may be modified by this or future implementations
                                        (0428) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0429) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0430) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0431) ;    functions.
                                        (0432) ;
                                        (0433)  ADCINC_1_WritePulseWidth:
                                        (0434) _ADCINC_1_WritePulseWidth:
                                        (0435)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0436)    ADCINC_1_WritePulseWidth_M  
                                        (0437)    RAM_EPILOGUE RAM_USE_CLASS_1
09FB: 7F       RET                      (0438)    ret
                                        (0439) .ENDSECTION
                                        (0440) 
                                        (0441) ; End of File ADCINC_1.asm
FILE: C:\DOCUME~1\KKP_E2\MYDOCU~1\PSOCDE~1.2PR\TIME_T~2\TIME_T~1\TIME_T~1\TIME_T~1\main.c
(0001) //----------------------------------------------------------------------------
(0002) // C main line
(0003) //----------------------------------------------------------------------------
(0004) 
(0005) #include <m8c.h>        // part specific constants and macros
(0006) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0007) //#include "BPF2_1.h" 
(0008) #include <Timer16_2.h> 
(0009) #include <stdlib.h>  
(0010) #include <string.h> 
(0011) #include <stdio.h> 
(0012) 
(0013) //#ints
(0014) void My_gpio_p2_6(void);
(0015) void MyGpioISR_pwm(void);
(0016) void My_16_pwm_isr(void);
(0017) void My_t16_1_isr(void);
(0018) void My_t16_2(void);
(0019) 
(0020) 
(0021) #pragma interrupt_handler My_gpio_p2_6
(0022) #pragma interrupt_handler MyGpioISR_pwm
(0023) #pragma interrupt_handler My_t16_1_isr
(0024) #pragma interrupt_handler My_16_pwm_isr
(0025) #pragma interrupt_handler My_t16_2
(0026) //________________
(0027) 
(0028) 
(0029) int q;
(0030) BYTE pwm2,x,i,r,d,Channel,m_started;
(0031) char a[10],b[10];
(0032) char i=0,j=0;
(0033) 
(0034) 
(0035) //#f()
(0036) unsigned int ReadADCChannel(BYTE Channel);
(0037) 
(0038) 
(0039) //void TxZeroTerminatedRamString( BYTE *pbStrPtr );
(0040) 
(0041) 
(0042) void send_results(void);
(0043) void m_test (void);
(0044) void cur_read(void);
(0045) void adc_read(void);
(0046) void my_tx(void);
(0047) 
(0048) void dir_l(void);
(0049) void dir_r(void);
(0050) void crlf(void);
(0051) void led_t(void);
(0052) void led_on(void);
(0053) void led_off(void);
(0054) void led2_t(void);
(0055) void left(void);
(0056) void right(void);
(0057) void stop(void);
(0058) void p0_3_on(void);
(0059) void p0_3_off(void);
(0060) void p0_5_on(void);
(0061) void p0_5_off(void);
(0062) 
(0063) //_________________
(0064) float tempf;
(0065) unsigned long temp_l,tempf1,temp2;
(0066) unsigned int rot_time[10],rot_time1[10];
(0067) unsigned int temp0,temp1,temp3,vdi,vdiff;
(0068) 
(0069) unsigned char rc,cr,flag1,flag,r,vout,vset,vsetv,tx_tim;
(0070) BYTE Port1Shadow; 
(0071) unsigned int vstart,rot_count,iData;
(0072) unsigned char results,pwm_val,* p_i;
(0073) unsigned int vdiff_t[20];
(0074) 
(0075) 
(0076) unsigned int ADCResult;
(0077) unsigned int ADCResult0;
(0078) unsigned int ADCResult1;
(0079) unsigned int ADCResult2;
(0080) unsigned int ADCResult3;
(0081) BYTE test,vlf,x,s,cur_tx,vd;
(0082) char AsciiString[7];
(0083) 
(0084) 
(0085) 
(0086) 
(0087) void main(void)
(0088) {	
(0089) 	m_started=0;
__UserModules_end|_main|__text_start|_main:
    09FC: 62 D0 00 MOV   REG[0xD0],0x0
    09FF: 55 D5 00 MOV   [m_started],0x0
(0090) 	test=0;
    0A02: 62 D0 00 MOV   REG[0xD0],0x0
    0A05: 55 CF 00 MOV   [test],0x0
(0091) 	vset=0;
    0A08: 62 D0 00 MOV   REG[0xD0],0x0
    0A0B: 55 C9 00 MOV   [vset],0x0
(0092) 	
(0093) 	pwm2=0;
    0A0E: 62 D0 00 MOV   REG[0xD0],0x0
    0A11: 55 DA 00 MOV   [pwm2],0x0
(0094) 	
(0095) 	temp_l=1920000;   //60sec 
    0A14: 62 D0 00 MOV   REG[0xD0],0x0
    0A17: 55 99 00 MOV   [temp_l],0x0
    0A1A: 55 9A 1D MOV   [temp_l+1],0x1D
    0A1D: 55 9B 4C MOV   [temp_l+2],0x4C
    0A20: 55 9C 00 MOV   [temp_l+3],0x0
(0096) 	
(0097) 	//vset=0x4d;	//1,5
(0098) 	//vset=0xb5;	//3,5
(0099) 	//vset=0xcf;	//4
(0100) 	
(0101) 	DigBuf_1_EnableInt();
    0A23: 10       PUSH  X
    0A24: 7C 08 C0 LCALL _DigBuf_1_EnableInt
(0102) 	DigBuf_1_Start();
    0A27: 7C 08 C8 LCALL _DigBuf_1_Start
(0103) 
(0104) 	
(0105) 	PGA_1_Start(PGA_1_HIGHPOWER);
    0A2A: 50 03    MOV   A,0x3
    0A2C: 7C 08 7C LCALL _PGA_1_SetPower|PGA_1_Start|_PGA_1_Start
    0A2F: 20       POP   X
(0106) 	
(0107) 	M8C_EnableIntMask(INT_MSK0, INT_MSK0_GPIO);
    0A30: 43 E0 20 OR    REG[0xE0],0x20
(0108) 	//BPF2_1_Start(BPF2_1_HIGHPOWER);
(0109) 	////BPF2_2_Start(BPF2_2_HIGHPOWER);
(0110) 	//PGA_1_SetGain(PGA_G8_00);
(0111)     ////PGA_1_Start(PGA_1_MEDPOWER);
(0112) 	////PGA_2_Start(PGA_2_MEDPOWER);
(0113) 	//PGA_3_Start(PGA_3_MEDPOWER);
(0114) 	
(0115) 	
(0116) 	Timer16_1_EnableInt();
    0A33: 10       PUSH  X
    0A34: 7C 07 2F LCALL _Timer16_1_EnableInt
(0117) 	Timer16_1_Start(); 
    0A37: 7C 07 37 LCALL _Timer16_1_Start
(0118) 	Timer16_2_Start(); 
    0A3A: 7C 06 D3 LCALL _Timer16_2_Start
(0119) 	//Timer16_2_EnableInt();
(0120) 	//Timer16_2_Start(); 
(0121) 	
(0122) 	PWM16_1_EnableInt(); 
    0A3D: 7C 08 20 LCALL _PWM16_1_EnableInt
(0123) 	PWM16_1_Start();
    0A40: 7C 08 28 LCALL _PWM16_1_Start
(0124) 	
(0125) 	//PWM8_1_EnableInt(); 
(0126) 	PWM8_1_Start();
    0A43: 7C 07 DE LCALL _PWM8_1_Start
(0127) 	PWM8_2_Start();
    0A46: 7C 07 97 LCALL _PWM8_2_Start
(0128) 	PWM8_2_WritePulseWidth(pwm2); 
    0A49: 62 D0 00 MOV   REG[0xD0],0x0
    0A4C: 51 DA    MOV   A,[pwm2]
    0A4E: 7C 07 A2 LCALL _PWM8_2_WritePulseWidth
    0A51: 20       POP   X
(0129) 	
(0130) 	
(0131) 	M8C_EnableGInt ;
    0A52: 71 01    OR    F,0x1
    0A54: 82 05    JMP   0x0C5A
(0132) 	while(1)
(0133) 	{
(0134) 				
(0135) 					
(0136) 		m_test();			
    0A56: 92 06    CALL  _m_test
(0137) 					
(0138) 					
(0139) 		
(0140) 		//###########################
(0141) 		//   Vset reg
(0142) 		//##########################
(0143) 		
(0144) 		if((flag&0x80)==0)  //@200hz
    0A58: 62 D0 00 MOV   REG[0xD0],0x0
    0A5B: 47 C8 80 TST   [flag],0x80
    0A5E: B0 EF    JNZ   0x0B4E
(0145) 			{
(0146) 			//led_t();
(0147) 			//tx_tim++;
(0148) 			cur_tx++;
    0A60: 62 D0 00 MOV   REG[0xD0],0x0
    0A63: 76 D2    INC   [cur_tx]
(0149) 			flag |= 0x80;
    0A65: 62 D0 00 MOV   REG[0xD0],0x0
    0A68: 2E C8 80 OR    [flag],0x80
(0150) 			//led_t();	// 
(0151) 			ADCResult3 = ReadADCChannel(3);
    0A6B: 50 03    MOV   A,0x3
    0A6D: 08       PUSH  A
    0A6E: 95 D8    CALL  _ReadADCChannel
    0A70: 38 FF    ADD   SP,0xFF
    0A72: 62 D0 00 MOV   REG[0xD0],0x0
    0A75: 51 8C    MOV   A,[__r1]
    0A77: 08       PUSH  A
    0A78: 51 8D    MOV   A,[__r0]
    0A7A: 62 D0 00 MOV   REG[0xD0],0x0
    0A7D: 53 AD    MOV   [ADCResult3],A
    0A7F: 18       POP   A
    0A80: 53 AE    MOV   [ADCResult3+1],A
(0152) 			//temp3=ADCResult3;
(0153) 			ADCResult3 >>=3; //11bit to 8 bit
    0A82: 70 FB    AND   F,0xFB
    0A84: 6E AD    RRC   [ADCResult3]
    0A86: 6E AE    RRC   [ADCResult3+1]
    0A88: 70 FB    AND   F,0xFB
    0A8A: 6E AD    RRC   [ADCResult3]
    0A8C: 6E AE    RRC   [ADCResult3+1]
    0A8E: 70 FB    AND   F,0xFB
    0A90: 6E AD    RRC   [ADCResult3]
    0A92: 6E AE    RRC   [ADCResult3+1]
(0154) 			vout=ADCResult3;
    0A94: 51 AE    MOV   A,[ADCResult3+1]
    0A96: 62 D0 00 MOV   REG[0xD0],0x0
    0A99: 53 DC    MOV   [vout],A
(0155) 			ADCResult2 = ReadADCChannel(2);
    0A9B: 50 02    MOV   A,0x2
    0A9D: 08       PUSH  A
    0A9E: 95 A8    CALL  _ReadADCChannel
    0AA0: 38 FF    ADD   SP,0xFF
    0AA2: 62 D0 00 MOV   REG[0xD0],0x0
    0AA5: 51 8C    MOV   A,[__r1]
    0AA7: 08       PUSH  A
    0AA8: 51 8D    MOV   A,[__r0]
    0AAA: 62 D0 00 MOV   REG[0xD0],0x0
    0AAD: 53 AF    MOV   [ADCResult2],A
    0AAF: 18       POP   A
    0AB0: 53 B0    MOV   [ADCResult2+1],A
(0156) 			ADCResult2 >>=3;
    0AB2: 70 FB    AND   F,0xFB
    0AB4: 6E AF    RRC   [ADCResult2]
    0AB6: 6E B0    RRC   [ADCResult2+1]
    0AB8: 70 FB    AND   F,0xFB
    0ABA: 6E AF    RRC   [ADCResult2]
    0ABC: 6E B0    RRC   [ADCResult2+1]
    0ABE: 70 FB    AND   F,0xFB
    0AC0: 6E AF    RRC   [ADCResult2]
    0AC2: 6E B0    RRC   [ADCResult2+1]
(0157) 			//vset=ADCResult2;
(0158) 			
(0159) 			if(vset>0)
    0AC4: 62 D0 00 MOV   REG[0xD0],0x0
    0AC7: 50 00    MOV   A,0x0
    0AC9: 3A C9    CMP   A,[vset]
    0ACB: D0 4C    JNC   0x0B18
(0160) 			{
(0161) 			if(vout>(vset+3))
    0ACD: 62 D0 00 MOV   REG[0xD0],0x0
    0AD0: 51 C9    MOV   A,[vset]
    0AD2: 01 03    ADD   A,0x3
    0AD4: 62 D0 00 MOV   REG[0xD0],0x0
    0AD7: 3A DC    CMP   A,[vout]
    0AD9: D0 0F    JNC   0x0AE9
(0162) 				{
(0163) 				if(pwm2>0)
    0ADB: 62 D0 00 MOV   REG[0xD0],0x0
    0ADE: 50 00    MOV   A,0x0
    0AE0: 3A DA    CMP   A,[pwm2]
    0AE2: D0 06    JNC   0x0AE9
(0164) 				pwm2--;
    0AE4: 62 D0 00 MOV   REG[0xD0],0x0
    0AE7: 7A DA    DEC   [pwm2]
(0165) 				}
(0166) 			if(vout<(vset-3))
    0AE9: 62 D0 00 MOV   REG[0xD0],0x0
    0AEC: 51 C9    MOV   A,[vset]
    0AEE: 11 03    SUB   A,0x3
    0AF0: 62 D0 00 MOV   REG[0xD0],0x0
    0AF3: 53 8D    MOV   [__r0],A
    0AF5: 62 D0 00 MOV   REG[0xD0],0x0
    0AF8: 51 DC    MOV   A,[vout]
    0AFA: 62 D0 00 MOV   REG[0xD0],0x0
    0AFD: 3A 8D    CMP   A,[__r0]
    0AFF: D0 0E    JNC   0x0B0E
(0167) 				{
(0168) 				if(pwm2<255)
    0B01: 62 D0 00 MOV   REG[0xD0],0x0
    0B04: 3C DA FF CMP   [pwm2],0xFF
    0B07: D0 06    JNC   0x0B0E
(0169) 				pwm2++;
    0B09: 62 D0 00 MOV   REG[0xD0],0x0
    0B0C: 76 DA    INC   [pwm2]
(0170) 				}	
(0171) 				
(0172) 			PWM8_2_WritePulseWidth(pwm2); 
    0B0E: 10       PUSH  X
    0B0F: 62 D0 00 MOV   REG[0xD0],0x0
    0B12: 51 DA    MOV   A,[pwm2]
    0B14: 7C 07 A2 LCALL _PWM8_2_WritePulseWidth
    0B17: 20       POP   X
(0173) 			}
(0174) 			if(vset==0)
    0B18: 62 D0 00 MOV   REG[0xD0],0x0
    0B1B: 3C C9 00 CMP   [vset],0x0
    0B1E: B0 08    JNZ   0x0B27
(0175) 			PWM8_2_WritePulseWidth(0); 
    0B20: 10       PUSH  X
    0B21: 50 00    MOV   A,0x0
    0B23: 7C 07 A2 LCALL _PWM8_2_WritePulseWidth
    0B26: 20       POP   X
(0176) 		//_________________________________
(0177) 		
(0178) 		
(0179) 		
(0180) 		if(cur_tx>20)	//curr read 
    0B27: 62 D0 00 MOV   REG[0xD0],0x0
    0B2A: 50 14    MOV   A,0x14
    0B2C: 3A D2    CMP   A,[cur_tx]
    0B2E: D0 0E    JNC   0x0B3D
(0181) 			{
(0182) 			tx_tim++;
    0B30: 62 D0 00 MOV   REG[0xD0],0x0
    0B33: 76 CB    INC   [tx_tim]
(0183) 			cur_tx=0;
    0B35: 62 D0 00 MOV   REG[0xD0],0x0
    0B38: 55 D2 00 MOV   [cur_tx],0x0
(0184) 			cur_read();
    0B3B: 92 E5    CALL  _cur_read
(0185) 			}	
(0186) 		
(0187) 		if(tx_tim>19)
    0B3D: 62 D0 00 MOV   REG[0xD0],0x0
    0B40: 50 13    MOV   A,0x13
    0B42: 3A CB    CMP   A,[tx_tim]
    0B44: D0 09    JNC   0x0B4E
(0188) 			{
(0189) 			tx_tim=0;
    0B46: 62 D0 00 MOV   REG[0xD0],0x0
    0B49: 55 CB 00 MOV   [tx_tim],0x0
(0190) 			my_tx();	// p2.3 tx
    0B4C: 94 31    CALL  _my_tx
(0191) 			}
(0192) 				
(0193) 		}
(0194) 		
(0195) 		if((flag&0x40)==0)
    0B4E: 62 D0 00 MOV   REG[0xD0],0x0
    0B51: 47 C8 40 TST   [flag],0x40
    0B54: B0 04    JNZ   0x0B59
(0196) 			{
(0197) 			flag |= 0x40;
    0B56: 2E C8 40 OR    [flag],0x40
(0198) 			//led_t();
(0199) 			}
(0200) 		
(0201) 		
(0202) 		if((flag&0x20)==0) // hall sens int
    0B59: 62 D0 00 MOV   REG[0xD0],0x0
    0B5C: 47 C8 20 TST   [flag],0x20
    0B5F: B0 EF    JNZ   0x0C4F
(0203) 			{
(0204) 			if(hall_in_Data_ADDR & hall_in_MASK){}
    0B61: 5D 04    MOV   A,REG[0x4]
    0B63: 62 D0 00 MOV   REG[0xD0],0x0
    0B66: 53 8D    MOV   [__r0],A
    0B68: 47 8D 40 TST   [__r0],0x40
    0B6B: A0 01    JZ    0x0B6D
(0205) 			
(0206) 			if(m_started>2)
    0B6D: 62 D0 00 MOV   REG[0xD0],0x0
    0B70: 50 02    MOV   A,0x2
    0B72: 3A D5    CMP   A,[m_started]
    0B74: D0 07    JNC   0x0B7C
(0207) 							{			
(0208) 							m_started=3;
    0B76: 62 D0 00 MOV   REG[0xD0],0x0
    0B79: 55 D5 03 MOV   [m_started],0x3
(0209) 							}
(0210) 					m_started++;
    0B7C: 62 D0 00 MOV   REG[0xD0],0x0
    0B7F: 76 D5    INC   [m_started]
(0211) 			
(0212) 			
(0213) 			//led_t();		
(0214) 			
(0215) 			flag |= 0x20;
    0B81: 62 D0 00 MOV   REG[0xD0],0x0
    0B84: 2E C8 20 OR    [flag],0x20
(0216) 			
(0217) 			
(0218) 			if((flag1&0x20)==0x20)
    0B87: 62 D0 00 MOV   REG[0xD0],0x0
    0B8A: 51 C5    MOV   A,[flag1]
    0B8C: 21 20    AND   A,0x20
    0B8E: 39 20    CMP   A,0x20
    0B90: B0 04    JNZ   0x0B95
(0219) 				{
(0220) 				flag1&=~0x20; //clr data ready flag
    0B92: 26 C5 DF AND   [flag1],0xDF
(0221) 				}
(0222) 				
(0223) 			rot_time[r]=Timer16_2_wReadTimer();
    0B95: 10       PUSH  X
    0B96: 7C 07 23 LCALL _Timer16_2_wReadTimer|_wTimer16_2_ReadTimer|_wTimer16_2_CaptureCounter|Timer16_2_wReadTimer|wTimer16_2_CaptureCounter|wTimer16_2_ReadTimer
    0B99: 62 D0 00 MOV   REG[0xD0],0x0
    0B9C: 5A 8D    MOV   [__r0],X
    0B9E: 53 8C    MOV   [__r1],A
    0BA0: 20       POP   X
    0BA1: 62 D0 00 MOV   REG[0xD0],0x0
    0BA4: 51 D8    MOV   A,[r]
    0BA6: 62 D0 00 MOV   REG[0xD0],0x0
    0BA9: 53 8A    MOV   [__r3],A
    0BAB: 55 8B 00 MOV   [__r2],0x0
    0BAE: 65 8A    ASL   [__r3]
    0BB0: 6B 8B    RLC   [__r2]
    0BB2: 06 8A 49 ADD   [__r3],0x49
    0BB5: 0E 8B 00 ADC   [__r2],0x0
    0BB8: 51 8B    MOV   A,[__r2]
    0BBA: 60 D5    MOV   REG[0xD5],A
    0BBC: 51 8D    MOV   A,[__r0]
    0BBE: 3F 8A    MVI   [__r3],A
    0BC0: 51 8C    MOV   A,[__r1]
    0BC2: 3F 8A    MVI   [__r3],A
(0224) 			Timer16_2_Stop(); 
    0BC4: 10       PUSH  X
    0BC5: 7C 06 D7 LCALL _Timer16_2_Stop
(0225) 			Timer16_2_WritePeriod(0xfa00);
    0BC8: 57 FA    MOV   X,0xFA
    0BCA: 50 00    MOV   A,0x0
    0BCC: 7C 06 DB LCALL _Timer16_2_WritePeriod
(0226) 			Timer16_2_Start();
    0BCF: 7C 06 D3 LCALL _Timer16_2_Start
    0BD2: 20       POP   X
(0227) 			
(0228) 			r++;
    0BD3: 62 D0 00 MOV   REG[0xD0],0x0
    0BD6: 76 D8    INC   [r]
(0229) 			if(r>1)
    0BD8: 50 01    MOV   A,0x1
    0BDA: 3A D8    CMP   A,[r]
    0BDC: D0 72    JNC   0x0C4F
(0230) 				{
(0231) 				r=0;
    0BDE: 62 D0 00 MOV   REG[0xD0],0x0
    0BE1: 55 D8 00 MOV   [r],0x0
(0232) 				flag1|=0x20; //flag for data ready
    0BE4: 62 D0 00 MOV   REG[0xD0],0x0
    0BE7: 2E C5 20 OR    [flag1],0x20
(0233) 				//rpm calc
(0234) 				temp0=0xfa00 - rot_time[0];//64k-elapsed time
    0BEA: 62 D0 00 MOV   REG[0xD0],0x0
    0BED: 50 00    MOV   A,0x0
    0BEF: 12 4A    SUB   A,[rot_time+1]
    0BF1: 62 D0 00 MOV   REG[0xD0],0x0
    0BF4: 53 BA    MOV   [temp0+1],A
    0BF6: 50 FA    MOV   A,0xFA
    0BF8: 62 D0 00 MOV   REG[0xD0],0x0
    0BFB: 1A 49    SBB   A,[rot_time]
    0BFD: 62 D0 00 MOV   REG[0xD0],0x0
    0C00: 53 B9    MOV   [temp0],A
(0235) 				temp1=0xfa00 - rot_time[1];//64k-elapsed time
    0C02: 62 D0 00 MOV   REG[0xD0],0x0
    0C05: 50 00    MOV   A,0x0
    0C07: 12 4C    SUB   A,[rot_time+3]
    0C09: 62 D0 00 MOV   REG[0xD0],0x0
    0C0C: 53 BC    MOV   [temp1+1],A
    0C0E: 50 FA    MOV   A,0xFA
    0C10: 62 D0 00 MOV   REG[0xD0],0x0
    0C13: 1A 4B    SBB   A,[rot_time+2]
    0C15: 62 D0 00 MOV   REG[0xD0],0x0
    0C18: 53 BB    MOV   [temp1],A
(0236) 				temp2=temp0+temp1;//sum
    0C1A: 62 D0 00 MOV   REG[0xD0],0x0
    0C1D: 51 BA    MOV   A,[temp0+1]
    0C1F: 62 D0 00 MOV   REG[0xD0],0x0
    0C22: 02 BC    ADD   A,[temp1+1]
    0C24: 62 D0 00 MOV   REG[0xD0],0x0
    0C27: 53 8C    MOV   [__r1],A
    0C29: 62 D0 00 MOV   REG[0xD0],0x0
    0C2C: 51 B9    MOV   A,[temp0]
    0C2E: 62 D0 00 MOV   REG[0xD0],0x0
    0C31: 0A BB    ADC   A,[temp1]
    0C33: 62 D0 00 MOV   REG[0xD0],0x0
    0C36: 53 8D    MOV   [__r0],A
    0C38: 51 8C    MOV   A,[__r1]
    0C3A: 62 D0 00 MOV   REG[0xD0],0x0
    0C3D: 53 A4    MOV   [temp2+3],A
    0C3F: 62 D0 00 MOV   REG[0xD0],0x0
    0C42: 51 8D    MOV   A,[__r0]
    0C44: 62 D0 00 MOV   REG[0xD0],0x0
    0C47: 53 A3    MOV   [temp2+2],A
    0C49: 55 A2 00 MOV   [temp2+1],0x0
    0C4C: 55 A1 00 MOV   [temp2],0x0
(0237) 						}
(0238) 			
(0239) 			
(0240) 			
(0241) 			
(0242) 			
(0243) 			
(0244) 			
(0245) 			//flag1^=0x20;
(0246) 			//if((flag1&0x20)==0) 
(0247) 			//{
(0248) 			//}
(0249) 			}
(0250) 			
(0251) 			
(0252) 			
(0253) 			
(0254) 		
(0255) 		if((flag1&0x01)==0x00)		//p2.6 int routine
    0C4F: 62 D0 00 MOV   REG[0xD0],0x0
    0C52: 47 C5 01 TST   [flag1],0x1
    0C55: B0 04    JNZ   0x0C5A
(0256) 			{
(0257) 			
(0258) 			
(0259) 			
(0260) 			/*flag1 ^= 0x10;
(0261) 			if((flag1&0x10) == 0x10)
(0262) 				{
(0263) 				Timer16_2_Start();
(0264) 				Timer16_2_WritePeriod(3200);
(0265) 				led_t();
(0266) 				}
(0267) 			else{
(0268) 				rot_count = Timer16_2_wReadTimerSaveCV();  
(0269) 				Timer16_2_Stop();
(0270) 				}
(0271) 			
(0272) 			//flag1^=0x02;
(0273) 			/*	/*
(0274) 				if(flag1&0x02)
(0275) 					{
(0276) 					Timer16_2_Start();
(0277) 					}
(0278) 				else
(0279) 					{
(0280) 					rot_count = Timer16_2_wReadTimerSaveCV();  
(0281) 					
(0282) 					}
(0283) 			*/
(0284) 			//Timer16_2_Stop();
(0285) 		//	rot_count = Timer16_2_wReadTimerSaveCV();  
(0286) 			flag1 |= 0x01;
    0C57: 2E C5 01 OR    [flag1],0x1
(0287) 			}
(0288) 		
(0289) 	
(0290) 	}
    0C5A: 8D FB    JMP   0x0A56
    0C5C: 8F FF    JMP   0x0C5C
(0291) 	// M8C_EnableGInt ; // Uncomment this line to enable Global Interrupts
(0292) 	// Insert your main routine code here.
(0293) }
(0294) 
(0295) 
(0296) 
(0297) void m_test(void)
(0298) {
_m_test:
    0C5E: 10       PUSH  X
    0C5F: 4F       MOV   X,SP
    0C60: 38 02    ADD   SP,0x2
(0299) 	switch (test)
    0C62: 62 D0 00 MOV   REG[0xD0],0x0
    0C65: 51 CF    MOV   A,[test]
    0C67: 54 01    MOV   [X+1],A
    0C69: 56 00 00 MOV   [X+0],0x0
    0C6C: 52 01    MOV   A,[X+1]
    0C6E: 11 00    SUB   A,0x0
    0C70: 52 00    MOV   A,[X+0]
    0C72: 31 80    XOR   A,0x80
    0C74: 19 80    SBB   A,0x80
    0C76: C0 F8    JC    0x0D6F
    0C78: 50 1E    MOV   A,0x1E
    0C7A: 13 01    SUB   A,[X+1]
    0C7C: 52 00    MOV   A,[X+0]
    0C7E: 31 80    XOR   A,0x80
    0C80: 62 D0 00 MOV   REG[0xD0],0x0
    0C83: 53 87    MOV   [__rX],A
    0C85: 50 80    MOV   A,0x80
    0C87: 1A 87    SBB   A,[__rX]
    0C89: C0 E5    JC    0x0D6F
    0C8B: 62 D0 00 MOV   REG[0xD0],0x0
    0C8E: 52 01    MOV   A,[X+1]
    0C90: 53 8C    MOV   [__r1],A
    0C92: 52 00    MOV   A,[X+0]
    0C94: 53 8D    MOV   [__r0],A
    0C96: 65 8C    ASL   [__r1]
    0C98: 6B 8D    RLC   [__r0]
    0C9A: 06 8C 4B ADD   [__r1],0x4B
    0C9D: 0E 8D 04 ADC   [__r0],0x4
    0CA0: 51 8D    MOV   A,[__r0]
    0CA2: 10       PUSH  X
    0CA3: 58 8C    MOV   X,[__r1]
    0CA5: 08       PUSH  A
    0CA6: 28       ROMX  
    0CA7: 53 8D    MOV   [__r0],A
    0CA9: 18       POP   A
    0CAA: 75       INC   X
    0CAB: 09 00    ADC   A,0x0
    0CAD: 28       ROMX  
    0CAE: 53 8C    MOV   [__r1],A
    0CB0: 20       POP   X
    0CB1: 51 8D    MOV   A,[__r0]
    0CB3: 08       PUSH  A
    0CB4: 51 8C    MOV   A,[__r1]
    0CB6: 08       PUSH  A
    0CB7: 7F       RET   
(0300) 				{
(0301) 				case 0:		//start test
(0302) 						if(m_started==3)
    0CB8: 62 D0 00 MOV   REG[0xD0],0x0
    0CBB: 3C D5 03 CMP   [m_started],0x3
    0CBE: B0 16    JNZ   0x0CD5
(0303) 							{
(0304) 							test=2;
    0CC0: 62 D0 00 MOV   REG[0xD0],0x0
    0CC3: 55 CF 02 MOV   [test],0x2
(0305) 							vstart=vout;
    0CC6: 62 D0 00 MOV   REG[0xD0],0x0
    0CC9: 51 DC    MOV   A,[vout]
    0CCB: 08       PUSH  A
    0CCC: 62 D0 00 MOV   REG[0xD0],0x0
    0CCF: 55 B7 00 MOV   [vstart],0x0
    0CD2: 18       POP   A
    0CD3: 53 B8    MOV   [vstart+1],A
(0306) 							//vset=0;
(0307) 							//vfl=1;
(0308) 							}
(0309) 						if(vlf>16)
    0CD5: 62 D0 00 MOV   REG[0xD0],0x0
    0CD8: 50 10    MOV   A,0x10
    0CDA: 3A D0    CMP   A,[vlf]
    0CDC: D0 0C    JNC   0x0CE9
(0310) 						{
(0311) 						vset++;
    0CDE: 62 D0 00 MOV   REG[0xD0],0x0
    0CE1: 76 C9    INC   [vset]
(0312) 						vlf=0;
    0CE3: 62 D0 00 MOV   REG[0xD0],0x0
    0CE6: 55 D0 00 MOV   [vlf],0x0
(0313) 						}
(0314) 						
(0315) 						vlf++;
    0CE9: 62 D0 00 MOV   REG[0xD0],0x0
    0CEC: 76 D0    INC   [vlf]
(0316) 						
(0317) 						break;
    0CEE: 80 80    JMP   0x0D6F
(0318) 				
(0319) 						
(0320) 				case 3:
(0321) 						vset=0x3a;		//1V
    0CF0: 62 D0 00 MOV   REG[0xD0],0x0
    0CF3: 55 C9 3A MOV   [vset],0x3A
(0322) 						break;
    0CF6: 80 78    JMP   0x0D6F
(0323) 						
(0324) 				case 6:
(0325) 						results=1; //send 1v results
    0CF8: 62 D0 00 MOV   REG[0xD0],0x0
    0CFB: 55 CD 01 MOV   [results],0x1
(0326) 						break;
    0CFE: 80 70    JMP   0x0D6F
(0327) 				case 7:
(0328) 						vset=0x53;	//1,5V
    0D00: 62 D0 00 MOV   REG[0xD0],0x0
    0D03: 55 C9 53 MOV   [vset],0x53
(0329) 						break;
    0D06: 80 68    JMP   0x0D6F
(0330) 				case 10:
(0331) 						results=15; //send 1,5v results
    0D08: 62 D0 00 MOV   REG[0xD0],0x0
    0D0B: 55 CD 0F MOV   [results],0xF
(0332) 						break;
    0D0E: 80 60    JMP   0x0D6F
(0333) 				
(0334) 				case 11:
(0335) 						vset=0x69;	//2V
    0D10: 62 D0 00 MOV   REG[0xD0],0x0
    0D13: 55 C9 69 MOV   [vset],0x69
(0336) 						break;
    0D16: 80 58    JMP   0x0D6F
(0337) 				case 14:
(0338) 						results=2; //send 2v results
    0D18: 62 D0 00 MOV   REG[0xD0],0x0
    0D1B: 55 CD 02 MOV   [results],0x2
(0339) 						break;				
    0D1E: 80 50    JMP   0x0D6F
(0340) 				case 15:
(0341) 						vset=0x7e;	//2,5V
    0D20: 62 D0 00 MOV   REG[0xD0],0x0
    0D23: 55 C9 7E MOV   [vset],0x7E
(0342) 						break;
    0D26: 80 48    JMP   0x0D6F
(0343) 				case 18:
(0344) 						results=25; //send 2,5v results
    0D28: 62 D0 00 MOV   REG[0xD0],0x0
    0D2B: 55 CD 19 MOV   [results],0x19
(0345) 						break;		
    0D2E: 80 40    JMP   0x0D6F
(0346) 				case 19:
(0347) 						vset=0x97;	//3V
    0D30: 62 D0 00 MOV   REG[0xD0],0x0
    0D33: 55 C9 97 MOV   [vset],0x97
(0348) 						break;
    0D36: 80 38    JMP   0x0D6F
(0349) 				case 22:
(0350) 						results=3; //send 3v results
    0D38: 62 D0 00 MOV   REG[0xD0],0x0
    0D3B: 55 CD 03 MOV   [results],0x3
(0351) 						break;				
    0D3E: 80 30    JMP   0x0D6F
(0352) 				case 23:
(0353) 						vset=0xad;	//3.5V
    0D40: 62 D0 00 MOV   REG[0xD0],0x0
    0D43: 55 C9 AD MOV   [vset],0xAD
(0354) 						break;
    0D46: 80 28    JMP   0x0D6F
(0355) 				case 26:
(0356) 						results=35; //send 3,5v results
    0D48: 62 D0 00 MOV   REG[0xD0],0x0
    0D4B: 55 CD 23 MOV   [results],0x23
(0357) 						break;		
    0D4E: 80 20    JMP   0x0D6F
(0358) 				case 27:
(0359) 						vset=0; //stop
    0D50: 62 D0 00 MOV   REG[0xD0],0x0
    0D53: 55 C9 00 MOV   [vset],0x0
(0360) 						break;
    0D56: 80 18    JMP   0x0D6F
(0361) 				case 28:
(0362) 						break;		
(0363) 				case 29:
(0364) 						break;	
(0365) 						
(0366) 				case 30:
(0367) 						//vset=0;
(0368) 						vstart=0;
    0D58: 62 D0 00 MOV   REG[0xD0],0x0
    0D5B: 55 B8 00 MOV   [vstart+1],0x0
    0D5E: 55 B7 00 MOV   [vstart],0x0
(0369) 						m_started=0;
    0D61: 62 D0 00 MOV   REG[0xD0],0x0
    0D64: 55 D5 00 MOV   [m_started],0x0
(0370) 						test=0;
    0D67: 62 D0 00 MOV   REG[0xD0],0x0
    0D6A: 55 CF 00 MOV   [test],0x0
(0371) 						led_t();
    0D6D: 92 5B    CALL  _led_t
(0372) 						//Port1Shadow = PRT1DR ;
(0373) 						//Port1Shadow ^= 0x04;     //p1.2
(0374) 						//Port1Shadow &= ~0x04;	//p0.7
(0375) 						//Port1Shadow |= 0x28;	//p0.5,p0.3
(0376) 						//Port1Shadow |= 0xa8;	//p0.7,p0.5,p0.3
(0377) 						//PRT1DR = Port1Shadow;
(0378) 						break;
(0379) 				
(0380) 				
(0381) 				default:
(0382) 						break;
    0D6F: 38 FE    ADD   SP,0xFE
    0D71: 20       POP   X
    0D72: 7F       RET   
(0383) 				}
(0384) 			
(0385) 
(0386) }
(0387) 
(0388) 
(0389) 
(0390) 
(0391) 
(0392) 
(0393) 
(0394) //####################################
(0395) //###       IRQ
(0396) //####################################
(0397) 
(0398) void My_gpio_p2_6(void)
(0399) {
_My_gpio_p2_6:
    0D73: 71 C0    OR    F,0xC0
    0D75: 08       PUSH  A
    0D76: 5D D0    MOV   A,REG[0xD0]
    0D78: 08       PUSH  A
(0400) 
(0401) flag1 &= ~0x01;
    0D79: 62 D0 00 MOV   REG[0xD0],0x0
    0D7C: 26 C5 FE AND   [flag1],0xFE
    0D7F: 18       POP   A
    0D80: 60 D0    MOV   REG[0xD0],A
    0D82: 18       POP   A
    0D83: 7E       RETI  
(0402) }
(0403) 
(0404) void My_t16_1_isr(void)
(0405) {
_My_t16_1_isr:
    0D84: 71 C0    OR    F,0xC0
    0D86: 08       PUSH  A
    0D87: 5D D0    MOV   A,REG[0xD0]
    0D89: 08       PUSH  A
(0406) #pragma nomac
(0407) //led_t();
(0408) //led2_t();
(0409) flag &= ~0x80;
    0D8A: 62 D0 00 MOV   REG[0xD0],0x0
    0D8D: 26 C8 7F AND   [flag],0x7F
(0410) return;
    0D90: 18       POP   A
    0D91: 60 D0    MOV   REG[0xD0],A
    0D93: 18       POP   A
    0D94: 7E       RETI  
(0411) }
(0412) 
(0413) void My_16_pwm_isr(void)
(0414) {
_My_16_pwm_isr:
    0D95: 71 C0    OR    F,0xC0
    0D97: 08       PUSH  A
    0D98: 5D D0    MOV   A,REG[0xD0]
    0D9A: 08       PUSH  A
(0415) //#pragma nomac
(0416) //led_t();
(0417) //led2_t();
(0418) flag &= ~0x40;
    0D9B: 62 D0 00 MOV   REG[0xD0],0x0
    0D9E: 26 C8 BF AND   [flag],0xBF
(0419) return;
    0DA1: 18       POP   A
    0DA2: 60 D0    MOV   REG[0xD0],A
    0DA4: 18       POP   A
    0DA5: 7E       RETI  
(0420) }
(0421) 
(0422) 
(0423) void My_t16_2(void)
(0424) {
_My_t16_2:
    0DA6: 08       PUSH  A
(0425) //#pragma nomac
(0426) //led_t();
(0427) //led2_t();
(0428) //flag &= ~0x80;
(0429) return;
    0DA7: 18       POP   A
    0DA8: 7E       RETI  
(0430) }
(0431) 
(0432) void MyGpioISR_pwm(void)
(0433) {	
_MyGpioISR_pwm:
    0DA9: 71 C0    OR    F,0xC0
    0DAB: 08       PUSH  A
    0DAC: 5D D0    MOV   A,REG[0xD0]
    0DAE: 08       PUSH  A
(0434) //led_t();
(0435) flag &= ~0x20;
    0DAF: 62 D0 00 MOV   REG[0xD0],0x0
    0DB2: 26 C8 DF AND   [flag],0xDF
    0DB5: 18       POP   A
    0DB6: 60 D0    MOV   REG[0xD0],A
    0DB8: 18       POP   A
    0DB9: 7E       RETI  
(0436) 
(0437) }
(0438) //____________________________________
(0439) 
(0440) 
(0441) 
(0442) //####################################
(0443) //####        f()
(0444) //###################################
(0445) 
(0446) void adc_read(void)
(0447) {
(0448) 		ADCINC_1_Start(ADCINC_1_HIGHPOWER);       // Apply power to the SC Block 
_adc_read:
    0DBA: 10       PUSH  X
    0DBB: 50 03    MOV   A,0x3
    0DBD: 7C 09 5B LCALL _ADCINC_1_Start
(0449) 		ADCINC_1_GetSamples(5);                 // Have ADC run continuously 
    0DC0: 50 05    MOV   A,0x5
    0DC2: 7C 09 86 LCALL _ADCINC_1_GetSamples
    0DC5: 20       POP   X
(0450) 		
(0451) 				while(ADCINC_1_fIsDataAvailable() == 0);   // Loop until value ready 
    0DC6: 10       PUSH  X
    0DC7: 7C 09 C3 LCALL _ADCINC_1_fIsDataAvailable
    0DCA: 20       POP   X
    0DCB: 62 D0 00 MOV   REG[0xD0],0x0
    0DCE: 39 00    CMP   A,0x0
    0DD0: AF F5    JZ    0x0DC6
(0452) 				ADCINC_1_iClearFlagGetData();              // Clear ADC flag and get data 
    0DD2: 10       PUSH  X
    0DD3: 7C 09 C9 LCALL _ADCINC_1_iClearFlagGetData|_ADCINC_1_wClearFlagGetData|ADCINC_1_wClearFlagGetData|ADCINC_1_iClearFlagGetData
    0DD6: 62 D0 00 MOV   REG[0xD0],0x0
(0453) 				// Add user code here to use or display result 
(0454) 				iData = ADCINC_1_wGetData();
    0DD9: 7C 09 E2 LCALL _ADCINC_1_iGetData|ADCINC_1_wGetData|ADCINC_1_iGetData|_ADCINC_1_wGetData
    0DDC: 62 D0 00 MOV   REG[0xD0],0x0
    0DDF: 5A 8D    MOV   [__r0],X
    0DE1: 20       POP   X
    0DE2: 08       PUSH  A
    0DE3: 51 8D    MOV   A,[__r0]
    0DE5: 62 D0 00 MOV   REG[0xD0],0x0
    0DE8: 53 B3    MOV   [iData],A
    0DEA: 18       POP   A
    0DEB: 53 B4    MOV   [iData+1],A
(0455) 				iData >>= 2;
    0DED: 70 FB    AND   F,0xFB
    0DEF: 6E B3    RRC   [iData]
    0DF1: 6E B4    RRC   [iData+1]
    0DF3: 70 FB    AND   F,0xFB
    0DF5: 6E B3    RRC   [iData]
    0DF7: 6E B4    RRC   [iData+1]
(0456) 				
(0457) 				vout = iData;
    0DF9: 51 B4    MOV   A,[iData+1]
    0DFB: 62 D0 00 MOV   REG[0xD0],0x0
    0DFE: 53 DC    MOV   [vout],A
(0458) 				
(0459) 				
(0460) 			//iData = ADCINC_1_wGetData();
(0461) 			ADCINC_1_Stop();
    0E00: 10       PUSH  X
    0E01: 7C 09 7C LCALL _ADCINC_1_Stop
    0E04: 20       POP   X
    0E05: 7F       RET   
(0462) 			
(0463) 			}
(0464) 
(0465) void left (void)
(0466) 	{
(0467) 	flag1 |= 0x40;
_left:
    0E06: 62 D0 00 MOV   REG[0xD0],0x0
    0E09: 2E C5 40 OR    [flag1],0x40
(0468) 	flag1 &= ~0x80;
    0E0C: 26 C5 7F AND   [flag1],0x7F
(0469) 	return;
    0E0F: 7F       RET   
(0470) 	}
(0471) 
(0472) void right (void)
(0473) 	{
(0474) 	flag1 |= 0x80;
_right:
    0E10: 62 D0 00 MOV   REG[0xD0],0x0
    0E13: 2E C5 80 OR    [flag1],0x80
(0475) 	flag1 &= ~0x40;
    0E16: 26 C5 BF AND   [flag1],0xBF
(0476) 	return;
    0E19: 7F       RET   
(0477) 	}
(0478) 
(0479) void stop (void)
(0480) 	{
(0481) 	PWM8_1_WritePulseWidth(0);
_stop:
    0E1A: 10       PUSH  X
    0E1B: 50 00    MOV   A,0x0
    0E1D: 7C 07 E9 LCALL _PWM8_1_WritePulseWidth
    0E20: 20       POP   X
    0E21: 7F       RET   
(0482) 	}
(0483) 
(0484) void cur_read(void)
(0485) {
(0486) //curr meas
(0487) 		ADCResult1 = ReadADCChannel(1);
_cur_read:
    0E22: 50 01    MOV   A,0x1
    0E24: 08       PUSH  A
    0E25: 92 21    CALL  _ReadADCChannel
    0E27: 38 FF    ADD   SP,0xFF
    0E29: 62 D0 00 MOV   REG[0xD0],0x0
    0E2C: 51 8C    MOV   A,[__r1]
    0E2E: 08       PUSH  A
    0E2F: 51 8D    MOV   A,[__r0]
    0E31: 62 D0 00 MOV   REG[0xD0],0x0
    0E34: 53 B1    MOV   [ADCResult1],A
    0E36: 18       POP   A
    0E37: 53 B2    MOV   [ADCResult1+1],A
(0488) 		temp3 = ReadADCChannel(3);
    0E39: 50 03    MOV   A,0x3
    0E3B: 08       PUSH  A
    0E3C: 92 0A    CALL  _ReadADCChannel
    0E3E: 38 FF    ADD   SP,0xFF
    0E40: 62 D0 00 MOV   REG[0xD0],0x0
    0E43: 51 8C    MOV   A,[__r1]
    0E45: 08       PUSH  A
    0E46: 51 8D    MOV   A,[__r0]
    0E48: 62 D0 00 MOV   REG[0xD0],0x0
    0E4B: 53 BD    MOV   [temp3],A
    0E4D: 18       POP   A
    0E4E: 53 BE    MOV   [temp3+1],A
(0489) 		vdi=ADCResult1-temp3; 
    0E50: 62 D0 00 MOV   REG[0xD0],0x0
    0E53: 51 B2    MOV   A,[ADCResult1+1]
    0E55: 62 D0 00 MOV   REG[0xD0],0x0
    0E58: 12 BE    SUB   A,[temp3+1]
    0E5A: 62 D0 00 MOV   REG[0xD0],0x0
    0E5D: 53 C0    MOV   [vdi+1],A
    0E5F: 62 D0 00 MOV   REG[0xD0],0x0
    0E62: 51 B1    MOV   A,[ADCResult1]
    0E64: 62 D0 00 MOV   REG[0xD0],0x0
    0E67: 1A BD    SBB   A,[temp3]
    0E69: 62 D0 00 MOV   REG[0xD0],0x0
    0E6C: 53 BF    MOV   [vdi],A
(0490) 		vdi*=5;	////12bit@5v scale--->>vdiffx5/4=(u(mV)) 
    0E6E: 51 C0    MOV   A,[vdi+1]
    0E70: 08       PUSH  A
    0E71: 51 BF    MOV   A,[vdi]
    0E73: 62 D0 00 MOV   REG[0xD0],0x0
    0E76: 53 8D    MOV   [__r0],A
    0E78: 18       POP   A
    0E79: 53 8C    MOV   [__r1],A
    0E7B: 55 8A 05 MOV   [__r3],0x5
    0E7E: 55 8B 00 MOV   [__r2],0x0
    0E81: 55 87 00 MOV   [__rX],0x0
    0E84: 55 86 00 MOV   [__rY],0x0
    0E87: 3C 8B 00 CMP   [__r2],0x0
    0E8A: B0 06    JNZ   0x0E91
    0E8C: 3C 8A 00 CMP   [__r3],0x0
    0E8F: A0 1A    JZ    0x0EAA
    0E91: 70 FB    AND   F,0xFB
    0E93: 6E 8B    RRC   [__r2]
    0E95: 6E 8A    RRC   [__r3]
    0E97: D0 0C    JNC   0x0EA4
    0E99: 62 D0 00 MOV   REG[0xD0],0x0
    0E9C: 51 8C    MOV   A,[__r1]
    0E9E: 04 87    ADD   [__rX],A
    0EA0: 51 8D    MOV   A,[__r0]
    0EA2: 0C 86    ADC   [__rY],A
    0EA4: 65 8C    ASL   [__r1]
    0EA6: 6B 8D    RLC   [__r0]
    0EA8: 8F DE    JMP   0x0E87
    0EAA: 62 D0 00 MOV   REG[0xD0],0x0
    0EAD: 51 87    MOV   A,[__rX]
    0EAF: 62 D0 00 MOV   REG[0xD0],0x0
    0EB2: 53 C0    MOV   [vdi+1],A
    0EB4: 62 D0 00 MOV   REG[0xD0],0x0
    0EB7: 51 86    MOV   A,[__rY]
    0EB9: 62 D0 00 MOV   REG[0xD0],0x0
    0EBC: 53 BF    MOV   [vdi],A
(0491) 		vdi/=2;
    0EBE: 70 FB    AND   F,0xFB
    0EC0: 6E BF    RRC   [vdi]
    0EC2: 6E C0    RRC   [vdi+1]
(0492) 		vdiff_t[vd] = vdi/10; //current in mA
    0EC4: 50 00    MOV   A,0x0
    0EC6: 08       PUSH  A
    0EC7: 50 0A    MOV   A,0xA
    0EC9: 08       PUSH  A
    0ECA: 51 BF    MOV   A,[vdi]
    0ECC: 08       PUSH  A
    0ECD: 51 C0    MOV   A,[vdi+1]
    0ECF: 08       PUSH  A
    0ED0: 62 D0 00 MOV   REG[0xD0],0x0
    0ED3: 7C 12 28 LCALL 0x1228
    0ED6: 18       POP   A
    0ED7: 53 8C    MOV   [__r1],A
    0ED9: 18       POP   A
    0EDA: 53 8D    MOV   [__r0],A
    0EDC: 38 FE    ADD   SP,0xFE
    0EDE: 62 D0 00 MOV   REG[0xD0],0x0
    0EE1: 51 D3    MOV   A,[vd]
    0EE3: 62 D0 00 MOV   REG[0xD0],0x0
    0EE6: 53 8A    MOV   [__r3],A
    0EE8: 55 8B 00 MOV   [__r2],0x0
    0EEB: 65 8A    ASL   [__r3]
    0EED: 6B 8B    RLC   [__r2]
    0EEF: 06 8A 08 ADD   [__r3],0x8
    0EF2: 0E 8B 00 ADC   [__r2],0x0
    0EF5: 51 8B    MOV   A,[__r2]
    0EF7: 60 D5    MOV   REG[0xD5],A
    0EF9: 51 8D    MOV   A,[__r0]
    0EFB: 3F 8A    MVI   [__r3],A
    0EFD: 51 8C    MOV   A,[__r1]
    0EFF: 3F 8A    MVI   [__r3],A
(0493) 		if(vd<20)
    0F01: 62 D0 00 MOV   REG[0xD0],0x0
    0F04: 3C D3 14 CMP   [vd],0x14
    0F07: D0 06    JNC   0x0F0E
(0494) 		vd++;
    0F09: 62 D0 00 MOV   REG[0xD0],0x0
    0F0C: 76 D3    INC   [vd]
(0495) 		if(vd==19)
    0F0E: 62 D0 00 MOV   REG[0xD0],0x0
    0F11: 3C D3 13 CMP   [vd],0x13
    0F14: B0 69    JNZ   0x0F7E
(0496) 			{
(0497) 			vd=0;
    0F16: 55 D3 00 MOV   [vd],0x0
(0498) 			for ( s = 0; s < 20; ++s )
    0F19: 62 D0 00 MOV   REG[0xD0],0x0
    0F1C: 55 D1 00 MOV   [s],0x0
    0F1F: 80 36    JMP   0x0F56
(0499) 				{
(0500)     			 vdiff = vdiff + vdiff_t[s];
    0F21: 62 D0 00 MOV   REG[0xD0],0x0
    0F24: 51 D1    MOV   A,[s]
    0F26: 62 D0 00 MOV   REG[0xD0],0x0
    0F29: 53 8C    MOV   [__r1],A
    0F2B: 55 8D 00 MOV   [__r0],0x0
    0F2E: 65 8C    ASL   [__r1]
    0F30: 6B 8D    RLC   [__r0]
    0F32: 06 8C 08 ADD   [__r1],0x8
    0F35: 0E 8D 00 ADC   [__r0],0x0
    0F38: 51 8D    MOV   A,[__r0]
    0F3A: 60 D4    MOV   REG[0xD4],A
    0F3C: 3E 8C    MVI   A,[__r1]
    0F3E: 53 8D    MOV   [__r0],A
    0F40: 3E 8C    MVI   A,[__r1]
    0F42: 62 D0 00 MOV   REG[0xD0],0x0
    0F45: 04 C4    ADD   [vdiff+1],A
    0F47: 62 D0 00 MOV   REG[0xD0],0x0
    0F4A: 51 8D    MOV   A,[__r0]
    0F4C: 62 D0 00 MOV   REG[0xD0],0x0
    0F4F: 0C C3    ADC   [vdiff],A
(0501) 				 }
    0F51: 62 D0 00 MOV   REG[0xD0],0x0
    0F54: 76 D1    INC   [s]
    0F56: 62 D0 00 MOV   REG[0xD0],0x0
    0F59: 3C D1 14 CMP   [s],0x14
    0F5C: CF C4    JC    0x0F21
(0502) 			vdiff =vdiff/20;
    0F5E: 62 D0 00 MOV   REG[0xD0],0x0
    0F61: 50 00    MOV   A,0x0
    0F63: 08       PUSH  A
    0F64: 50 14    MOV   A,0x14
    0F66: 08       PUSH  A
    0F67: 51 C3    MOV   A,[vdiff]
    0F69: 08       PUSH  A
    0F6A: 51 C4    MOV   A,[vdiff+1]
    0F6C: 08       PUSH  A
    0F6D: 62 D0 00 MOV   REG[0xD0],0x0
    0F70: 7C 12 28 LCALL 0x1228
    0F73: 18       POP   A
    0F74: 62 D0 00 MOV   REG[0xD0],0x0
    0F77: 53 C4    MOV   [vdiff+1],A
    0F79: 18       POP   A
    0F7A: 53 C3    MOV   [vdiff],A
    0F7C: 38 FE    ADD   SP,0xFE
(0503) 				 
(0504) 			}
    0F7E: 7F       RET   
(0505) 		
(0506) 		
(0507) }
(0508) void my_tx(void)
(0509) {		
(0510) 		
(0511) 		
(0512) 		if(d>5)
_my_tx:
    0F7F: 62 D0 00 MOV   REG[0xD0],0x0
    0F82: 50 05    MOV   A,0x5
    0F84: 3A D7    CMP   A,[d]
    0F86: D0 07    JNC   0x0F8E
(0513) 		{
(0514) 		d=0;
    0F88: 62 D0 00 MOV   REG[0xD0],0x0
    0F8B: 55 D7 00 MOV   [d],0x0
(0515) 		//dir_l();
(0516) 		}
(0517) 		//if(d==3){ dir_r();}
(0518) 		if(test>=2)
    0F8E: 62 D0 00 MOV   REG[0xD0],0x0
    0F91: 3C CF 02 CMP   [test],0x2
    0F94: C0 06    JC    0x0F9B
(0519) 		{test++;}
    0F96: 62 D0 00 MOV   REG[0xD0],0x0
    0F99: 76 CF    INC   [test]
(0520) 		
(0521) 		if(test==28)
    0F9B: 62 D0 00 MOV   REG[0xD0],0x0
    0F9E: 3C CF 1C CMP   [test],0x1C
    0FA1: B0 04    JNZ   0x0FA6
(0522) 		{test=30;}
    0FA3: 55 CF 1E MOV   [test],0x1E
(0523) 		
(0524) 		cr++;
    0FA6: 62 D0 00 MOV   REG[0xD0],0x0
    0FA9: 76 C6    INC   [cr]
(0525) 	
(0526) 			
(0527) 		 TX8_1_Start(TX8_PARITY_NONE);
    0FAB: 10       PUSH  X
    0FAC: 50 00    MOV   A,0x0
    0FAE: 7C 06 0D LCALL _TX8_1_Start
    0FB1: 20       POP   X
(0528) 		
(0529) 			
(0530) 			//crlf();
(0531) 				
(0532) 			
(0533) 			//csprintf(b,"t = %d xx ",temp0);
(0534) 			//TX8_1_PutString(b);
(0535) 			//crlf();
(0536) 			
(0537) 			send_results();
    0FB2: 91 4E    CALL  _send_results
(0538) 			
(0539) 			
(0540) 			/*
(0541) 			csprintf(b,"started@ %d V ",vstart);
(0542) 			TX8_1_PutString(b);
(0543) 			crlf();
(0544) 			
(0545) 			
(0546) 			temp0=temp_l/temp2;
(0547) 			csprintf(b,"R = %d U/min ",temp0);
(0548) 			TX8_1_PutString(b);
(0549) 			crlf();
(0550) 			
(0551) 			
(0552) 			vsetv=vout*1.95;  //11bit voltage value (*2 )
(0553) 			csprintf(b,"U = %d V ",vsetv);
(0554) 			TX8_1_PutString(b);
(0555) 			crlf();
(0556) 			
(0557) 			csprintf(b,"I = %d mA ",vdiff);
(0558) 			TX8_1_PutString(b);
(0559) 			crlf();
(0560) 			
(0561) 			
(0562) 			itoa(a,cr,10);
(0563) 			TX8_1_PutString(a);
(0564) 			crlf();
(0565) 			/*
(0566) 			
(0567) 			/*
(0568) 			TX8_1_PutSHexInt(temp0);
(0569) 			while( !( TX8_1_bReadTxStatus() & TX8_TX_COMPLETE ) );
(0570) 			crlf();	
(0571) 			
(0572) 			//TX8_1_PutString("start_volt");
(0573) 			while( !( TX8_1_bReadTxStatus() & TX8_TX_COMPLETE ) );
(0574) 			TX8_1_PutCRLF();							//Do a Line and Carriage Return
(0575) 				//Wait until TX operation Complete
(0576) 			while( !( TX8_1_bReadTxStatus() & TX8_TX_COMPLETE ) );
(0577) 			while( !( TX8_1_bReadTxStatus() & TX8_TX_COMPLETE ) );
(0578) 			*/
(0579) 			
(0580) 		TX8_1_Stop();
    0FB4: 10       PUSH  X
    0FB5: 7C 06 12 LCALL _TX8_1_Stop
    0FB8: 20       POP   X
    0FB9: 7F       RET   
(0581) 		
(0582) }
(0583) 
(0584) 
(0585) void TxZeroTerminatedRamString( BYTE *pbStrPtr )
(0586) {
_TxZeroTerminatedRamString:
  pbStrPtr             --> X-5
    0FBA: 10       PUSH  X
    0FBB: 4F       MOV   X,SP
(0587)     TX8_1_PutString(pbStrPtr);
    0FBC: 10       PUSH  X
    0FBD: 52 FB    MOV   A,[X-5]
    0FBF: 08       PUSH  A
    0FC0: 52 FC    MOV   A,[X-4]
    0FC2: 5C       MOV   X,A
    0FC3: 18       POP   A
    0FC4: 7C 06 4E LCALL _TX8_1_PutString
    0FC7: 20       POP   X
    0FC8: 20       POP   X
    0FC9: 7F       RET   
(0588) 
(0589) }
(0590) 
(0591) 
(0592) void led_t(void)
(0593) {
(0594) Port1Shadow = PRT0DR ;
_led_t:
    0FCA: 5D 00    MOV   A,REG[0x0]
    0FCC: 62 D0 00 MOV   REG[0xD0],0x0
    0FCF: 53 CC    MOV   [Port1Shadow],A
(0595) 		//Port1Shadow |= 0x80;
(0596) 		Port1Shadow ^= 0x80;  //toggle p0.7
    0FD1: 51 CC    MOV   A,[Port1Shadow]
    0FD3: 31 80    XOR   A,0x80
    0FD5: 53 CC    MOV   [Port1Shadow],A
(0597) 		PRT0DR = Port1Shadow;
    0FD7: 51 CC    MOV   A,[Port1Shadow]
    0FD9: 60 00    MOV   REG[0x0],A
(0598) 		return;
    0FDB: 7F       RET   
(0599) }
(0600) 
(0601) void led2_t(void)
(0602) {
(0603) Port1Shadow = PRT0DR ;
_led2_t:
    0FDC: 5D 00    MOV   A,REG[0x0]
    0FDE: 62 D0 00 MOV   REG[0xD0],0x0
    0FE1: 53 CC    MOV   [Port1Shadow],A
(0604) 		//Port1Shadow |= 0x80;
(0605) 		Port1Shadow ^= 0x40; //toggle p0.6
    0FE3: 51 CC    MOV   A,[Port1Shadow]
    0FE5: 31 40    XOR   A,0x40
    0FE7: 53 CC    MOV   [Port1Shadow],A
(0606) 		PRT0DR = Port1Shadow;
    0FE9: 51 CC    MOV   A,[Port1Shadow]
    0FEB: 60 00    MOV   REG[0x0],A
(0607) 		return;
    0FED: 7F       RET   
(0608) }
(0609) 
(0610) void led_on(void)
(0611) {
(0612) Port1Shadow = PRT0DR ;
_led_on:
    0FEE: 5D 00    MOV   A,REG[0x0]
    0FF0: 62 D0 00 MOV   REG[0xD0],0x0
    0FF3: 53 CC    MOV   [Port1Shadow],A
(0613) 		//Port1Shadow |= 0x80;
(0614) 		//Port1Shadow |= 0x80;	//p0.7
(0615) 		Port1Shadow |= 0x28;	//p0.5,p0.3
    0FF5: 2E CC 28 OR    [Port1Shadow],0x28
(0616) 		//Port1Shadow |= 0xa8;	//p0.7,p0.5,p0.3
(0617) 		PRT0DR = Port1Shadow;
    0FF8: 51 CC    MOV   A,[Port1Shadow]
    0FFA: 60 00    MOV   REG[0x0],A
    0FFC: 7F       RET   
(0618) }
(0619) 
(0620) void led_off(void)
(0621) {
(0622) Port1Shadow = PRT0DR ;
_led_off:
    0FFD: 5D 00    MOV   A,REG[0x0]
    0FFF: 62 D0 00 MOV   REG[0xD0],0x0
    1002: 53 CC    MOV   [Port1Shadow],A
(0623) 		//Port1Shadow |= 0x80;
(0624) 		//Port1Shadow &= ~0x80;
(0625) 		Port1Shadow &= ~0x28;	//p0.5,p0.3
    1004: 26 CC D7 AND   [Port1Shadow],0xD7
(0626) 		//Port1Shadow &= ~0xa8;	//p0.7,p0.5,p0.3
(0627) 		PRT0DR = Port1Shadow;
    1007: 51 CC    MOV   A,[Port1Shadow]
    1009: 60 00    MOV   REG[0x0],A
    100B: 7F       RET   
(0628) }
(0629) 
(0630) void p0_3_on(void)
(0631) {
(0632) Port1Shadow = PRT0DR ;
_p0_3_on:
    100C: 5D 00    MOV   A,REG[0x0]
    100E: 62 D0 00 MOV   REG[0xD0],0x0
    1011: 53 CC    MOV   [Port1Shadow],A
(0633) 		Port1Shadow |= 0x08;     //p03
    1013: 2E CC 08 OR    [Port1Shadow],0x8
(0634) 		//Port1Shadow |= 0x80;	//p0.7
(0635) 		//Port1Shadow |= 0x28;	//p0.5,p0.3
(0636) 		//Port1Shadow |= 0xa8;	//p0.7,p0.5,p0.3
(0637) 		PRT0DR = Port1Shadow;
    1016: 51 CC    MOV   A,[Port1Shadow]
    1018: 60 00    MOV   REG[0x0],A
    101A: 7F       RET   
(0638) }
(0639) 
(0640) void p0_3_off(void)
(0641) {
(0642) Port1Shadow = PRT0DR ;
_p0_3_off:
    101B: 5D 00    MOV   A,REG[0x0]
    101D: 62 D0 00 MOV   REG[0xD0],0x0
    1020: 53 CC    MOV   [Port1Shadow],A
(0643) 		//Port1Shadow |= 0x08;
(0644) 		//Port1Shadow &= ~0x80;
(0645) 		Port1Shadow &= ~0x08;	//p0.5,p0.3
    1022: 26 CC F7 AND   [Port1Shadow],0xF7
(0646) 		//Port1Shadow &= ~0xa8;	//p0.7,p0.5,p0.3
(0647) 		PRT0DR = Port1Shadow;
    1025: 51 CC    MOV   A,[Port1Shadow]
    1027: 60 00    MOV   REG[0x0],A
    1029: 7F       RET   
(0648) }
(0649) 
(0650) 
(0651) void p0_5_on(void)
(0652) {
(0653) Port1Shadow = PRT0DR ;
_p0_5_on:
    102A: 5D 00    MOV   A,REG[0x0]
    102C: 62 D0 00 MOV   REG[0xD0],0x0
    102F: 53 CC    MOV   [Port1Shadow],A
(0654) 		Port1Shadow |= 0x20;     //p03
    1031: 2E CC 20 OR    [Port1Shadow],0x20
(0655) 		//Port1Shadow |= 0x80;	//p0.7
(0656) 		//Port1Shadow |= 0x28;	//p0.5,p0.3
(0657) 		//Port1Shadow |= 0xa8;	//p0.7,p0.5,p0.3
(0658) 		PRT0DR = Port1Shadow;
    1034: 51 CC    MOV   A,[Port1Shadow]
    1036: 60 00    MOV   REG[0x0],A
    1038: 7F       RET   
(0659) }
(0660) 
(0661) void p0_5_off(void)
(0662) {
(0663) Port1Shadow = PRT0DR ;
_p0_5_off:
    1039: 5D 00    MOV   A,REG[0x0]
    103B: 62 D0 00 MOV   REG[0xD0],0x0
    103E: 53 CC    MOV   [Port1Shadow],A
(0664) 		//Port1Shadow |= 0x08;
(0665) 		//Port1Shadow &= ~0x80;
(0666) 		Port1Shadow &= ~0x20;	//p0.5,p0.3
    1040: 26 CC DF AND   [Port1Shadow],0xDF
(0667) 		//Port1Shadow &= ~0xa8;	//p0.7,p0.5,p0.3
(0668) 		PRT0DR = Port1Shadow;
    1043: 51 CC    MOV   A,[Port1Shadow]
    1045: 60 00    MOV   REG[0x0],A
    1047: 7F       RET   
(0669) }
(0670) 
(0671) 
(0672) //	0 - P0[7]
(0673) //	1 - P0[5]
(0674) //	2 - P0[3]
(0675) //	3 - P0[1]
(0676) unsigned int ReadADCChannel(BYTE Channel)
(0677) {	
_ReadADCChannel:
  Channel              --> X-4
    1048: 10       PUSH  X
    1049: 4F       MOV   X,SP
    104A: 38 02    ADD   SP,0x2
(0678) 
(0679) 
(0680) 	ADCINC_1_Start(ADCINC_1_HIGHPOWER);
    104C: 10       PUSH  X
    104D: 50 03    MOV   A,0x3
    104F: 7C 09 5B LCALL _ADCINC_1_Start
(0681) 	
(0682) 	AMUX4_1_Start();
    1052: 7C 08 EB LCALL _AMUX4_1_Start
    1055: 20       POP   X
(0683) 	//int ADCResult;
(0684) 	//BYTE x;
(0685) 	
(0686) 	switch (Channel)
    1056: 52 FC    MOV   A,[X-4]
    1058: 54 01    MOV   [X+1],A
    105A: 56 00 00 MOV   [X+0],0x0
    105D: 3D 00 00 CMP   [X+0],0x0
    1060: B0 06    JNZ   0x1067
    1062: 3D 01 00 CMP   [X+1],0x0
    1065: A0 21    JZ    0x1087
    1067: 3D 00 00 CMP   [X+0],0x0
    106A: B0 06    JNZ   0x1071
    106C: 3D 01 01 CMP   [X+1],0x1
    106F: A0 20    JZ    0x1090
    1071: 3D 00 00 CMP   [X+0],0x0
    1074: B0 06    JNZ   0x107B
    1076: 3D 01 02 CMP   [X+1],0x2
    1079: A0 1F    JZ    0x1099
    107B: 3D 00 00 CMP   [X+0],0x0
    107E: B0 06    JNZ   0x1085
    1080: 3D 01 03 CMP   [X+1],0x3
    1083: A0 1E    JZ    0x10A2
    1085: 80 23    JMP   0x10A9
(0687) 	{
(0688) 		case 0:
(0689) 			// Connect P0[7] to Mux Bus
(0690) 			//MUX_CR0 |= 0x80;
(0691) 			AMUX4_1_InputSelect(AMUX4_1_PORT0_7);
    1087: 10       PUSH  X
    1088: 50 03    MOV   A,0x3
    108A: 7C 08 D0 LCALL _AMUX4_1_InputSelect
    108D: 20       POP   X
(0692) 			
(0693) 			break;
    108E: 80 1A    JMP   0x10A9
(0694) 			
(0695) 		case 1:
(0696) 			// Connect P0[5] to Mux Bus
(0697) 			AMUX4_1_InputSelect(AMUX4_1_PORT0_5);
    1090: 10       PUSH  X
    1091: 50 02    MOV   A,0x2
    1093: 7C 08 D0 LCALL _AMUX4_1_InputSelect
    1096: 20       POP   X
(0698) 			break;
    1097: 80 11    JMP   0x10A9
(0699) 			
(0700) 		case 2:
(0701) 			// Connect P0[3] to Mux Bus
(0702) 			AMUX4_1_InputSelect(AMUX4_1_PORT0_3);
    1099: 10       PUSH  X
    109A: 50 01    MOV   A,0x1
    109C: 7C 08 D0 LCALL _AMUX4_1_InputSelect
    109F: 20       POP   X
(0703) 			break;
    10A0: 80 08    JMP   0x10A9
(0704) 			
(0705) 		case 3:
(0706) 			// Connect P0[1] to Mux Bus
(0707) 			AMUX4_1_InputSelect(AMUX4_1_PORT0_1);
    10A2: 10       PUSH  X
    10A3: 50 00    MOV   A,0x0
    10A5: 7C 08 D0 LCALL _AMUX4_1_InputSelect
    10A8: 20       POP   X
(0708) 			break;
(0709) 			
(0710) 			
(0711) 			
(0712) 	}
(0713) 		
(0714) 	// Give a small delay for the signal to settle at the PGA output. With the PGA
(0715) 	// operating at Highpower this takes less than a microsecond.  For low power operation
(0716) 	// this should be 6uS.  Refer the AC op amp electrical characteristics in the
(0717) 	// device data sheet
(0718) 	for (x = 0; x < 25; x++) {};
    10A9: 62 D0 00 MOV   REG[0xD0],0x0
    10AC: 55 D9 00 MOV   [x],0x0
    10AF: 80 06    JMP   0x10B6
    10B1: 62 D0 00 MOV   REG[0xD0],0x0
    10B4: 76 D9    INC   [x]
    10B6: 62 D0 00 MOV   REG[0xD0],0x0
    10B9: 3C D9 19 CMP   [x],0x19
    10BC: CF F4    JC    0x10B1
(0719) 	
(0720) 	// Start conversion of ADC
(0721) 	ADCINC_1_GetSamples(3);
    10BE: 10       PUSH  X
    10BF: 50 03    MOV   A,0x3
    10C1: 7C 09 86 LCALL _ADCINC_1_GetSamples
    10C4: 20       POP   X
(0722) 	
(0723) 	
(0724) 		while(!(ADCINC_1_fIsDataAvailable()));
    10C5: 10       PUSH  X
    10C6: 7C 09 C3 LCALL _ADCINC_1_fIsDataAvailable
    10C9: 20       POP   X
    10CA: 62 D0 00 MOV   REG[0xD0],0x0
    10CD: 39 00    CMP   A,0x0
    10CF: AF F5    JZ    0x10C5
(0725) 			
(0726) 			// Read the ADC result and clear the data ready flag
(0727) 			ADCResult=ADCINC_1_iClearFlagGetData();
    10D1: 10       PUSH  X
    10D2: 7C 09 C9 LCALL _ADCINC_1_iClearFlagGetData|_ADCINC_1_wClearFlagGetData|ADCINC_1_wClearFlagGetData|ADCINC_1_iClearFlagGetData
    10D5: 62 D0 00 MOV   REG[0xD0],0x0
    10D8: 5A 8D    MOV   [__r0],X
    10DA: 20       POP   X
    10DB: 08       PUSH  A
    10DC: 51 8D    MOV   A,[__r0]
    10DE: 62 D0 00 MOV   REG[0xD0],0x0
    10E1: 53 A7    MOV   [ADCResult],A
    10E3: 18       POP   A
    10E4: 53 A8    MOV   [ADCResult+1],A
(0728) 			
(0729) 	/*
(0730) 	for(i=0; i<3; i++)
(0731) 		{
(0732) 		// Wait till ADC conversion is over
(0733) 			while(!(ADCINC_1_fIsDataAvailable()));
(0734) 			
(0735) 			// Read the ADC result and clear the data ready flag
(0736) 			ADCResult=ADCINC_1_iClearFlagGetData();
(0737) 			
(0738) 			//ADCResult0=ADCResult;
(0739) 		} 
(0740) 	*/
(0741) 	// Disconnect all the pins from Mux Bus
(0742) 	//MUX_CR0 &= ~0xaa;	// Disconnect P0[7],P0[5],P0[3],P0[1]
(0743) 	//MUX_CR0 &= ~0x28;	// Disconnect P0[5] and P0[3]
(0744) 	//MUX_CR3 &= ~0x42;	// Disconnect P3[6] and P3[1]
(0745) 
(0746) 	// Return the result
(0747) 	
(0748) 	ADCINC_1_Stop();
    10E6: 10       PUSH  X
    10E7: 7C 09 7C LCALL _ADCINC_1_Stop
(0749) 	AMUX4_1_Stop();
    10EA: 7C 08 EC LCALL _AMUX4_1_Stop
    10ED: 20       POP   X
(0750) 	//ADCResult>>=2;
(0751) 	return ADCResult;
    10EE: 62 D0 00 MOV   REG[0xD0],0x0
    10F1: 51 A8    MOV   A,[ADCResult+1]
    10F3: 08       PUSH  A
    10F4: 51 A7    MOV   A,[ADCResult]
    10F6: 62 D0 00 MOV   REG[0xD0],0x0
    10F9: 53 8D    MOV   [__r0],A
    10FB: 18       POP   A
    10FC: 53 8C    MOV   [__r1],A
    10FE: 38 FE    ADD   SP,0xFE
    1100: 20       POP   X
    1101: 7F       RET   
(0752) }
(0753) 
(0754) void send_results(void)
(0755) {
(0756) if(results>0)
_send_results:
    1102: 62 D0 00 MOV   REG[0xD0],0x0
    1105: 50 00    MOV   A,0x0
    1107: 3A CD    CMP   A,[results]
    1109: D0 D1    JNC   0x11DB
(0757) 			{
(0758) 			temp0=temp_l/temp2;
    110B: 62 D0 00 MOV   REG[0xD0],0x0
    110E: 51 A1    MOV   A,[temp2]
    1110: 08       PUSH  A
    1111: 51 A2    MOV   A,[temp2+1]
    1113: 08       PUSH  A
    1114: 51 A3    MOV   A,[temp2+2]
    1116: 08       PUSH  A
    1117: 51 A4    MOV   A,[temp2+3]
    1119: 08       PUSH  A
    111A: 62 D0 00 MOV   REG[0xD0],0x0
    111D: 51 99    MOV   A,[temp_l]
    111F: 08       PUSH  A
    1120: 51 9A    MOV   A,[temp_l+1]
    1122: 08       PUSH  A
    1123: 51 9B    MOV   A,[temp_l+2]
    1125: 08       PUSH  A
    1126: 51 9C    MOV   A,[temp_l+3]
    1128: 08       PUSH  A
    1129: 62 D0 00 MOV   REG[0xD0],0x0
    112C: 7C 12 33 LCALL 0x1233
    112F: 18       POP   A
    1130: 53 8A    MOV   [__r3],A
    1132: 18       POP   A
    1133: 53 8B    MOV   [__r2],A
    1135: 18       POP   A
    1136: 18       POP   A
    1137: 38 FC    ADD   SP,0xFC
    1139: 51 8A    MOV   A,[__r3]
    113B: 53 8C    MOV   [__r1],A
    113D: 51 8B    MOV   A,[__r2]
    113F: 53 8D    MOV   [__r0],A
    1141: 51 8C    MOV   A,[__r1]
    1143: 08       PUSH  A
    1144: 51 8D    MOV   A,[__r0]
    1146: 62 D0 00 MOV   REG[0xD0],0x0
    1149: 53 B9    MOV   [temp0],A
    114B: 18       POP   A
    114C: 53 BA    MOV   [temp0+1],A
(0759) 			csprintf(b,"@%dV,R= %d U/min ",results,temp0);
    114E: 51 B9    MOV   A,[temp0]
    1150: 08       PUSH  A
    1151: 51 BA    MOV   A,[temp0+1]
    1153: 08       PUSH  A
    1154: 62 D0 00 MOV   REG[0xD0],0x0
    1157: 51 CD    MOV   A,[results]
    1159: 62 D0 00 MOV   REG[0xD0],0x0
    115C: 53 8C    MOV   [__r1],A
    115E: 50 00    MOV   A,0x0
    1160: 08       PUSH  A
    1161: 51 8C    MOV   A,[__r1]
    1163: 08       PUSH  A
    1164: 50 01    MOV   A,0x1
    1166: 08       PUSH  A
    1167: 50 BA    MOV   A,0xBA
    1169: 08       PUSH  A
    116A: 50 00    MOV   A,0x0
    116C: 08       PUSH  A
    116D: 50 71    MOV   A,0x71
    116F: 08       PUSH  A
    1170: 7C 16 D9 LCALL _csprintf
    1173: 38 F8    ADD   SP,0xF8
(0760) 			TX8_1_PutString(b);
    1175: 10       PUSH  X
    1176: 50 00    MOV   A,0x0
    1178: 08       PUSH  A
    1179: 50 71    MOV   A,0x71
    117B: 5C       MOV   X,A
    117C: 18       POP   A
    117D: 7C 06 4E LCALL _TX8_1_PutString
    1180: 20       POP   X
(0761) 			crlf();
    1181: 90 59    CALL  _crlf
(0762) 			
(0763) 			csprintf(b,"I = %d mA ",vdiff);
    1183: 62 D0 00 MOV   REG[0xD0],0x0
    1186: 51 C3    MOV   A,[vdiff]
    1188: 08       PUSH  A
    1189: 51 C4    MOV   A,[vdiff+1]
    118B: 08       PUSH  A
    118C: 50 01    MOV   A,0x1
    118E: 08       PUSH  A
    118F: 50 AF    MOV   A,0xAF
    1191: 08       PUSH  A
    1192: 50 00    MOV   A,0x0
    1194: 08       PUSH  A
    1195: 50 71    MOV   A,0x71
    1197: 08       PUSH  A
    1198: 7C 16 D9 LCALL _csprintf
    119B: 38 FA    ADD   SP,0xFA
(0764) 			TX8_1_PutString(b);
    119D: 10       PUSH  X
    119E: 50 00    MOV   A,0x0
    11A0: 08       PUSH  A
    11A1: 50 71    MOV   A,0x71
    11A3: 5C       MOV   X,A
    11A4: 18       POP   A
    11A5: 7C 06 4E LCALL _TX8_1_PutString
    11A8: 20       POP   X
(0765) 			crlf();
    11A9: 90 31    CALL  _crlf
(0766) 			
(0767) 			csprintf(b,"started@ %d V ",vstart);
    11AB: 62 D0 00 MOV   REG[0xD0],0x0
    11AE: 51 B7    MOV   A,[vstart]
    11B0: 08       PUSH  A
    11B1: 51 B8    MOV   A,[vstart+1]
    11B3: 08       PUSH  A
    11B4: 50 01    MOV   A,0x1
    11B6: 08       PUSH  A
    11B7: 50 A0    MOV   A,0xA0
    11B9: 08       PUSH  A
    11BA: 50 00    MOV   A,0x0
    11BC: 08       PUSH  A
    11BD: 50 71    MOV   A,0x71
    11BF: 08       PUSH  A
    11C0: 7C 16 D9 LCALL _csprintf
    11C3: 38 FA    ADD   SP,0xFA
(0768) 			TX8_1_PutString(b);
    11C5: 10       PUSH  X
    11C6: 50 00    MOV   A,0x0
    11C8: 08       PUSH  A
    11C9: 50 71    MOV   A,0x71
    11CB: 5C       MOV   X,A
    11CC: 18       POP   A
    11CD: 7C 06 4E LCALL _TX8_1_PutString
    11D0: 20       POP   X
(0769) 			crlf();
    11D1: 90 09    CALL  _crlf
(0770) 			crlf();
    11D3: 90 07    CALL  _crlf
(0771) 			results=0;
    11D5: 62 D0 00 MOV   REG[0xD0],0x0
    11D8: 55 CD 00 MOV   [results],0x0
(0772) 			}
    11DB: 7F       RET   
(0773) 			
(0774) }
(0775) 
(0776) 
(0777) 
(0778) void crlf(void)
(0779) {
(0780) TX8_1_PutCRLF();							//Do a Line and Carriage Return
_crlf:
    11DC: 10       PUSH  X
    11DD: 7C 06 C2 LCALL _TX8_1_PutCRLF
    11E0: 20       POP   X
(0781) 				//Wait until TX operation Complete
(0782) 			while( !( TX8_1_bReadTxStatus() & TX8_TX_COMPLETE ) );
    11E1: 10       PUSH  X
    11E2: 7C 06 19 LCALL _TX8_1_bReadTxStatus|_bTX8_1_ReadTxStatus|bTX8_1_ReadTxStatus
    11E5: 20       POP   X
    11E6: 62 D0 00 MOV   REG[0xD0],0x0
    11E9: 53 8D    MOV   [__r0],A
    11EB: 47 8D 20 TST   [__r0],0x20
    11EE: AF F2    JZ    0x11E1
(0783) 			while( !( TX8_1_bReadTxStatus() & TX8_TX_COMPLETE ) );
    11F0: 10       PUSH  X
    11F1: 7C 06 19 LCALL _TX8_1_bReadTxStatus|_bTX8_1_ReadTxStatus|bTX8_1_ReadTxStatus
    11F4: 20       POP   X
    11F5: 62 D0 00 MOV   REG[0xD0],0x0
    11F8: 53 8D    MOV   [__r0],A
    11FA: 47 8D 20 TST   [__r0],0x20
    11FD: AF F2    JZ    0x11F0
    11FF: 7F       RET   
(0784) }
(0785) 
(0786) void dir_l(void)
(0787) {
(0788) Port1Shadow = PRT1DR ;
_dir_l:
    1200: 5D 04    MOV   A,REG[0x4]
    1202: 62 D0 00 MOV   REG[0xD0],0x0
    1205: 53 CC    MOV   [Port1Shadow],A
(0789) 		Port1Shadow |= 0x04;     //p1.2
    1207: 2E CC 04 OR    [Port1Shadow],0x4
(0790) 		Port1Shadow &= ~0x10;	//p0.7
    120A: 26 CC EF AND   [Port1Shadow],0xEF
(0791) 		//Port1Shadow |= 0x28;	//p0.5,p0.3
(0792) 		//Port1Shadow |= 0xa8;	//p0.7,p0.5,p0.3
(0793) 		PRT1DR = Port1Shadow;
    120D: 51 CC    MOV   A,[Port1Shadow]
    120F: 60 04    MOV   REG[0x4],A
    1211: 7F       RET   
(0794) }
(0795) 
(0796) 
(0797) void dir_r(void)
(0798) {
(0799) Port1Shadow = PRT1DR ;
_dir_r:
    1212: 5D 04    MOV   A,REG[0x4]
    1214: 62 D0 00 MOV   REG[0xD0],0x0
    1217: 53 CC    MOV   [Port1Shadow],A
(0800) 		Port1Shadow |= 0x10;     //p1.2
    1219: 2E CC 10 OR    [Port1Shadow],0x10
(0801) 		Port1Shadow &= ~0x04;	//p0.7
    121C: 26 CC FB AND   [Port1Shadow],0xFB
(0802) 		//Port1Shadow |= 0x28;	//p0.5,p0.3
(0803) 		//Port1Shadow |= 0xa8;	//p0.7,p0.5,p0.3
(0804) 		PRT1DR = Port1Shadow;
    121F: 51 CC    MOV   A,[Port1Shadow]
(0805) }
(0806) 
(0807) /*
(0808) for ( s = 0; s < 5; ++s )
(0809) 				{
(0810) 				 temp0=0xfa00 - rot_time[s];//64k-elapsed time
(0811) 				 temp1=0xfa00 - rot_time[s+1];//64k-elapsed time
(0812) 				 temp_s[s]=temp0+temp1;//sum
(0813) 				 }
(0814) 			for ( s = 0; s < 5; ++s )
(0815) 				{
(0816)     			 temp2 = temp2+ temp_s[s];
(0817) 				 }
(0818) 			temp2 =temp2/4;
(0819) */FILE: lib\psocgpioint.asm               (0001) ;  Generated by PSoC Designer 5.2.2551
                                        (0002) ;
                                        (0003) ;;*****************************************************************************
                                        (0004) ;;*****************************************************************************
                                        (0005) ;;  FILENAME: PSoCGPIOINT.asm
                                        (0006) ;;   Version: 2.0.0.20, Updated on 2003/07/17 at 12:10:35
                                        (0007) ;;  @PSOC_VERSION
                                        (0008) ;;
                                        (0009) ;;  DESCRIPTION: PSoC GPIO Interrupt Service Routine
                                        (0010) ;;-----------------------------------------------------------------------------
                                        (0011) ;;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0012) ;;*****************************************************************************
                                        (0013) ;;*****************************************************************************
                                        (0014) 
                                        (0015) include "m8c.inc"
                                        (0016) include "PSoCGPIOINT.inc"
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export   PSoC_GPIO_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) ;-----------------------------------------------
                                        (0025) ;  Constant Definitions
                                        (0026) ;-----------------------------------------------
                                        (0027) 
                                        (0028) 
                                        (0029) ;-----------------------------------------------
                                        (0030) ; Variable Allocation
                                        (0031) ;-----------------------------------------------
                                        (0032) 	
                                        (0033) 
                                        (0034) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0035) ;---------------------------------------------------
                                        (0036) ; Insert your custom declarations below this banner
                                        (0037) ;---------------------------------------------------
                                        (0038) 
                                        (0039) ;---------------------------------------------------
                                        (0040) ; Insert your custom declarations above this banner
                                        (0041) ;---------------------------------------------------
                                        (0042) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0043) 
                                        (0044) 
                                        (0045) ;-----------------------------------------------------------------------------
                                        (0046) ;  FUNCTION NAME: PSoC_GPIO_ISR
                                        (0047) ;
                                        (0048) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0049) ;
                                        (0050) ;-----------------------------------------------------------------------------
                                        (0051) ;
                                        (0052) PSoC_GPIO_ISR:
                                        (0053) 
                                        (0054) 
                                        (0055)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0056)    ;---------------------------------------------------
                                        (0057)    ; Insert your custom code below this banner
                                        (0058)    ;---------------------------------------------------
1224: 7D 0D A9 LJMP  _MyGpioISR_pwm     (0059) 	ljmp _MyGpioISR_pwm
                                        (0060)    ;----------------
                                        (0061)    ;---------------------------------------------------
                                        (0062)    ; Insert your custom code above this banner
                                        (0063)    ;---------------------------------------------------
                                        (0064)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0065) 
1227: 7E       RETI                     (0066)    reti
                                        (0067) 
                                        (0068) 
                                        (0069) ; end of file PSoCGPIOINT.asm
__plcall:
    12DE: 53 87    MOV   [__rX],A
    12E0: 28       ROMX  
    12E1: 08       PUSH  A
    12E2: 51 87    MOV   A,[__rX]
    12E4: 75       INC   X
    12E5: 09 00    ADC   A,0x0
    12E7: 28       ROMX  
    12E8: 08       PUSH  A
    12E9: 7F       RET   
_itoa:
    12EA: 10       PUSH  X
    12EB: 4F       MOV   X,SP
    12EC: 38 09    ADD   SP,0x9
    12EE: 52 FA    MOV   A,[X-6]
    12F0: 54 03    MOV   [X+3],A
    12F2: 52 F9    MOV   A,[X-7]
    12F4: 54 02    MOV   [X+2],A
    12F6: 3D F9 00 CMP   [X-7],0x0
    12F9: B0 2F    JNZ   0x1329
    12FB: 3D FA 00 CMP   [X-6],0x0
    12FE: B0 2A    JNZ   0x1329
    1300: 62 D0 00 MOV   REG[0xD0],0x0
    1303: 52 FC    MOV   A,[X-4]
    1305: 53 8C    MOV   [__r1],A
    1307: 52 FB    MOV   A,[X-5]
    1309: 60 D5    MOV   REG[0xD5],A
    130B: 50 30    MOV   A,0x30
    130D: 3F 8C    MVI   [__r1],A
    130F: 52 FC    MOV   A,[X-4]
    1311: 01 01    ADD   A,0x1
    1313: 53 8C    MOV   [__r1],A
    1315: 52 FB    MOV   A,[X-5]
    1317: 09 00    ADC   A,0x0
    1319: 60 D5    MOV   REG[0xD5],A
    131B: 50 00    MOV   A,0x0
    131D: 3F 8C    MVI   [__r1],A
    131F: 52 FC    MOV   A,[X-4]
    1321: 53 8C    MOV   [__r1],A
    1323: 52 FB    MOV   A,[X-5]
    1325: 53 8D    MOV   [__r0],A
    1327: 81 97    JMP   0x14BF
    1329: 52 FA    MOV   A,[X-6]
    132B: 11 00    SUB   A,0x0
    132D: 52 F9    MOV   A,[X-7]
    132F: 31 80    XOR   A,0x80
    1331: 19 80    SBB   A,0x80
    1333: D0 29    JNC   0x135D
    1335: 3D F7 00 CMP   [X-9],0x0
    1338: B0 24    JNZ   0x135D
    133A: 3D F8 0A CMP   [X-8],0xA
    133D: B0 1F    JNZ   0x135D
    133F: 56 06 01 MOV   [X+6],0x1
    1342: 62 D0 00 MOV   REG[0xD0],0x0
    1345: 52 03    MOV   A,[X+3]
    1347: 73       CPL   A
    1348: 53 8C    MOV   [__r1],A
    134A: 52 02    MOV   A,[X+2]
    134C: 73       CPL   A
    134D: 53 8D    MOV   [__r0],A
    134F: 51 8C    MOV   A,[__r1]
    1351: 01 01    ADD   A,0x1
    1353: 54 03    MOV   [X+3],A
    1355: 51 8D    MOV   A,[__r0]
    1357: 09 00    ADC   A,0x0
    1359: 54 02    MOV   [X+2],A
    135B: 80 04    JMP   0x1360
    135D: 56 06 00 MOV   [X+6],0x0
    1360: 52 FC    MOV   A,[X-4]
    1362: 54 01    MOV   [X+1],A
    1364: 52 FB    MOV   A,[X-5]
    1366: 54 00    MOV   [X+0],A
    1368: 62 D0 00 MOV   REG[0xD0],0x0
    136B: 52 F7    MOV   A,[X-9]
    136D: 08       PUSH  A
    136E: 52 F8    MOV   A,[X-8]
    1370: 08       PUSH  A
    1371: 52 02    MOV   A,[X+2]
    1373: 08       PUSH  A
    1374: 52 03    MOV   A,[X+3]
    1376: 08       PUSH  A
    1377: 7C 12 28 LCALL 0x1228
    137A: 38 FE    ADD   SP,0xFE
    137C: 18       POP   A
    137D: 53 8C    MOV   [__r1],A
    137F: 18       POP   A
    1380: 53 8D    MOV   [__r0],A
    1382: 51 8C    MOV   A,[__r1]
    1384: 54 08    MOV   [X+8],A
    1386: 51 8D    MOV   A,[__r0]
    1388: 54 07    MOV   [X+7],A
    138A: 50 09    MOV   A,0x9
    138C: 13 08    SUB   A,[X+8]
    138E: 52 07    MOV   A,[X+7]
    1390: 31 80    XOR   A,0x80
    1392: 53 87    MOV   [__rX],A
    1394: 50 80    MOV   A,0x80
    1396: 1A 87    SBB   A,[__rX]
    1398: C0 28    JC    0x13C1
    139A: 62 D0 00 MOV   REG[0xD0],0x0
    139D: 52 01    MOV   A,[X+1]
    139F: 53 8C    MOV   [__r1],A
    13A1: 52 00    MOV   A,[X+0]
    13A3: 53 8D    MOV   [__r0],A
    13A5: 51 8C    MOV   A,[__r1]
    13A7: 01 01    ADD   A,0x1
    13A9: 54 01    MOV   [X+1],A
    13AB: 51 8D    MOV   A,[__r0]
    13AD: 09 00    ADC   A,0x0
    13AF: 54 00    MOV   [X+0],A
    13B1: 52 08    MOV   A,[X+8]
    13B3: 01 30    ADD   A,0x30
    13B5: 53 8B    MOV   [__r2],A
    13B7: 51 8D    MOV   A,[__r0]
    13B9: 60 D5    MOV   REG[0xD5],A
    13BB: 51 8B    MOV   A,[__r2]
    13BD: 3F 8C    MVI   [__r1],A
    13BF: 80 26    JMP   0x13E6
    13C1: 62 D0 00 MOV   REG[0xD0],0x0
    13C4: 52 01    MOV   A,[X+1]
    13C6: 53 8C    MOV   [__r1],A
    13C8: 52 00    MOV   A,[X+0]
    13CA: 53 8D    MOV   [__r0],A
    13CC: 51 8C    MOV   A,[__r1]
    13CE: 01 01    ADD   A,0x1
    13D0: 54 01    MOV   [X+1],A
    13D2: 51 8D    MOV   A,[__r0]
    13D4: 09 00    ADC   A,0x0
    13D6: 54 00    MOV   [X+0],A
    13D8: 52 08    MOV   A,[X+8]
    13DA: 01 57    ADD   A,0x57
    13DC: 53 8B    MOV   [__r2],A
    13DE: 51 8D    MOV   A,[__r0]
    13E0: 60 D5    MOV   REG[0xD5],A
    13E2: 51 8B    MOV   A,[__r2]
    13E4: 3F 8C    MVI   [__r1],A
    13E6: 52 F7    MOV   A,[X-9]
    13E8: 08       PUSH  A
    13E9: 52 F8    MOV   A,[X-8]
    13EB: 08       PUSH  A
    13EC: 52 02    MOV   A,[X+2]
    13EE: 08       PUSH  A
    13EF: 52 03    MOV   A,[X+3]
    13F1: 08       PUSH  A
    13F2: 62 D0 00 MOV   REG[0xD0],0x0
    13F5: 7C 12 28 LCALL 0x1228
    13F8: 18       POP   A
    13F9: 54 03    MOV   [X+3],A
    13FB: 18       POP   A
    13FC: 54 02    MOV   [X+2],A
    13FE: 38 FE    ADD   SP,0xFE
    1400: 3D 02 00 CMP   [X+2],0x0
    1403: BF 64    JNZ   0x1368
    1405: 3D 03 00 CMP   [X+3],0x0
    1408: BF 5F    JNZ   0x1368
    140A: 3D 06 00 CMP   [X+6],0x0
    140D: A0 20    JZ    0x142E
    140F: 62 D0 00 MOV   REG[0xD0],0x0
    1412: 52 01    MOV   A,[X+1]
    1414: 53 8C    MOV   [__r1],A
    1416: 52 00    MOV   A,[X+0]
    1418: 53 8D    MOV   [__r0],A
    141A: 51 8C    MOV   A,[__r1]
    141C: 01 01    ADD   A,0x1
    141E: 54 01    MOV   [X+1],A
    1420: 51 8D    MOV   A,[__r0]
    1422: 09 00    ADC   A,0x0
    1424: 54 00    MOV   [X+0],A
    1426: 51 8D    MOV   A,[__r0]
    1428: 60 D5    MOV   REG[0xD5],A
    142A: 50 2D    MOV   A,0x2D
    142C: 3F 8C    MVI   [__r1],A
    142E: 62 D0 00 MOV   REG[0xD0],0x0
    1431: 52 01    MOV   A,[X+1]
    1433: 53 8C    MOV   [__r1],A
    1435: 52 00    MOV   A,[X+0]
    1437: 53 8D    MOV   [__r0],A
    1439: 51 8C    MOV   A,[__r1]
    143B: 01 FF    ADD   A,0xFF
    143D: 54 01    MOV   [X+1],A
    143F: 51 8D    MOV   A,[__r0]
    1441: 09 FF    ADC   A,0xFF
    1443: 54 00    MOV   [X+0],A
    1445: 51 8D    MOV   A,[__r0]
    1447: 60 D5    MOV   REG[0xD5],A
    1449: 50 00    MOV   A,0x0
    144B: 3F 8C    MVI   [__r1],A
    144D: 52 FC    MOV   A,[X-4]
    144F: 54 05    MOV   [X+5],A
    1451: 52 FB    MOV   A,[X-5]
    1453: 54 04    MOV   [X+4],A
    1455: 80 54    JMP   0x14AA
    1457: 62 D0 00 MOV   REG[0xD0],0x0
    145A: 52 05    MOV   A,[X+5]
    145C: 53 8C    MOV   [__r1],A
    145E: 52 04    MOV   A,[X+4]
    1460: 60 D4    MOV   REG[0xD4],A
    1462: 3E 8C    MVI   A,[__r1]
    1464: 54 06    MOV   [X+6],A
    1466: 52 05    MOV   A,[X+5]
    1468: 53 8C    MOV   [__r1],A
    146A: 52 04    MOV   A,[X+4]
    146C: 53 8D    MOV   [__r0],A
    146E: 51 8C    MOV   A,[__r1]
    1470: 01 01    ADD   A,0x1
    1472: 54 05    MOV   [X+5],A
    1474: 51 8D    MOV   A,[__r0]
    1476: 09 00    ADC   A,0x0
    1478: 54 04    MOV   [X+4],A
    147A: 52 01    MOV   A,[X+1]
    147C: 53 8A    MOV   [__r3],A
    147E: 52 00    MOV   A,[X+0]
    1480: 60 D4    MOV   REG[0xD4],A
    1482: 3E 8A    MVI   A,[__r3]
    1484: 53 8B    MOV   [__r2],A
    1486: 51 8D    MOV   A,[__r0]
    1488: 60 D5    MOV   REG[0xD5],A
    148A: 51 8B    MOV   A,[__r2]
    148C: 3F 8C    MVI   [__r1],A
    148E: 52 01    MOV   A,[X+1]
    1490: 53 8C    MOV   [__r1],A
    1492: 52 00    MOV   A,[X+0]
    1494: 53 8D    MOV   [__r0],A
    1496: 51 8C    MOV   A,[__r1]
    1498: 01 FF    ADD   A,0xFF
    149A: 54 01    MOV   [X+1],A
    149C: 51 8D    MOV   A,[__r0]
    149E: 09 FF    ADC   A,0xFF
    14A0: 54 00    MOV   [X+0],A
    14A2: 51 8D    MOV   A,[__r0]
    14A4: 60 D5    MOV   REG[0xD5],A
    14A6: 52 06    MOV   A,[X+6]
    14A8: 3F 8C    MVI   [__r1],A
    14AA: 52 05    MOV   A,[X+5]
    14AC: 13 01    SUB   A,[X+1]
    14AE: 52 04    MOV   A,[X+4]
    14B0: 1B 00    SBB   A,[X+0]
    14B2: CF A4    JC    0x1457
    14B4: 62 D0 00 MOV   REG[0xD0],0x0
    14B7: 52 FC    MOV   A,[X-4]
    14B9: 53 8C    MOV   [__r1],A
    14BB: 52 FB    MOV   A,[X-5]
    14BD: 53 8D    MOV   [__r0],A
    14BF: 38 F7    ADD   SP,0xF7
    14C1: 20       POP   X
    14C2: 7F       RET   
_utoa:
    14C3: 10       PUSH  X
    14C4: 4F       MOV   X,SP
    14C5: 38 07    ADD   SP,0x7
    14C7: 52 FC    MOV   A,[X-4]
    14C9: 54 01    MOV   [X+1],A
    14CB: 52 FB    MOV   A,[X-5]
    14CD: 54 00    MOV   [X+0],A
    14CF: 62 D0 00 MOV   REG[0xD0],0x0
    14D2: 52 F7    MOV   A,[X-9]
    14D4: 08       PUSH  A
    14D5: 52 F8    MOV   A,[X-8]
    14D7: 08       PUSH  A
    14D8: 52 F9    MOV   A,[X-7]
    14DA: 08       PUSH  A
    14DB: 52 FA    MOV   A,[X-6]
    14DD: 08       PUSH  A
    14DE: 7C 12 28 LCALL 0x1228
    14E1: 38 FE    ADD   SP,0xFE
    14E3: 18       POP   A
    14E4: 53 8C    MOV   [__r1],A
    14E6: 18       POP   A
    14E7: 53 8D    MOV   [__r0],A
    14E9: 51 8C    MOV   A,[__r1]
    14EB: 54 06    MOV   [X+6],A
    14ED: 51 8D    MOV   A,[__r0]
    14EF: 54 05    MOV   [X+5],A
    14F1: 50 09    MOV   A,0x9
    14F3: 13 06    SUB   A,[X+6]
    14F5: 52 05    MOV   A,[X+5]
    14F7: 31 80    XOR   A,0x80
    14F9: 53 87    MOV   [__rX],A
    14FB: 50 80    MOV   A,0x80
    14FD: 1A 87    SBB   A,[__rX]
    14FF: C0 28    JC    0x1528
    1501: 62 D0 00 MOV   REG[0xD0],0x0
    1504: 52 01    MOV   A,[X+1]
    1506: 53 8C    MOV   [__r1],A
    1508: 52 00    MOV   A,[X+0]
    150A: 53 8D    MOV   [__r0],A
    150C: 51 8C    MOV   A,[__r1]
    150E: 01 01    ADD   A,0x1
    1510: 54 01    MOV   [X+1],A
    1512: 51 8D    MOV   A,[__r0]
    1514: 09 00    ADC   A,0x0
    1516: 54 00    MOV   [X+0],A
    1518: 52 06    MOV   A,[X+6]
    151A: 01 30    ADD   A,0x30
    151C: 53 8B    MOV   [__r2],A
    151E: 51 8D    MOV   A,[__r0]
    1520: 60 D5    MOV   REG[0xD5],A
    1522: 51 8B    MOV   A,[__r2]
    1524: 3F 8C    MVI   [__r1],A
    1526: 80 26    JMP   0x154D
    1528: 62 D0 00 MOV   REG[0xD0],0x0
    152B: 52 01    MOV   A,[X+1]
    152D: 53 8C    MOV   [__r1],A
    152F: 52 00    MOV   A,[X+0]
    1531: 53 8D    MOV   [__r0],A
    1533: 51 8C    MOV   A,[__r1]
    1535: 01 01    ADD   A,0x1
    1537: 54 01    MOV   [X+1],A
    1539: 51 8D    MOV   A,[__r0]
    153B: 09 00    ADC   A,0x0
    153D: 54 00    MOV   [X+0],A
    153F: 52 06    MOV   A,[X+6]
    1541: 01 57    ADD   A,0x57
    1543: 53 8B    MOV   [__r2],A
    1545: 51 8D    MOV   A,[__r0]
    1547: 60 D5    MOV   REG[0xD5],A
    1549: 51 8B    MOV   A,[__r2]
    154B: 3F 8C    MVI   [__r1],A
    154D: 52 F7    MOV   A,[X-9]
    154F: 08       PUSH  A
    1550: 52 F8    MOV   A,[X-8]
    1552: 08       PUSH  A
    1553: 52 F9    MOV   A,[X-7]
    1555: 08       PUSH  A
    1556: 52 FA    MOV   A,[X-6]
    1558: 08       PUSH  A
    1559: 62 D0 00 MOV   REG[0xD0],0x0
    155C: 7C 12 28 LCALL 0x1228
    155F: 18       POP   A
    1560: 54 FA    MOV   [X-6],A
    1562: 18       POP   A
    1563: 54 F9    MOV   [X-7],A
    1565: 38 FE    ADD   SP,0xFE
    1567: 3D F9 00 CMP   [X-7],0x0
    156A: BF 64    JNZ   0x14CF
    156C: 3D FA 00 CMP   [X-6],0x0
    156F: BF 5F    JNZ   0x14CF
    1571: 62 D0 00 MOV   REG[0xD0],0x0
    1574: 52 01    MOV   A,[X+1]
    1576: 53 8C    MOV   [__r1],A
    1578: 52 00    MOV   A,[X+0]
    157A: 53 8D    MOV   [__r0],A
    157C: 51 8C    MOV   A,[__r1]
    157E: 01 FF    ADD   A,0xFF
    1580: 54 01    MOV   [X+1],A
    1582: 51 8D    MOV   A,[__r0]
    1584: 09 FF    ADC   A,0xFF
    1586: 54 00    MOV   [X+0],A
    1588: 51 8D    MOV   A,[__r0]
    158A: 60 D5    MOV   REG[0xD5],A
    158C: 50 00    MOV   A,0x0
    158E: 3F 8C    MVI   [__r1],A
    1590: 52 FC    MOV   A,[X-4]
    1592: 54 03    MOV   [X+3],A
    1594: 52 FB    MOV   A,[X-5]
    1596: 54 02    MOV   [X+2],A
    1598: 80 54    JMP   0x15ED
    159A: 62 D0 00 MOV   REG[0xD0],0x0
    159D: 52 03    MOV   A,[X+3]
    159F: 53 8C    MOV   [__r1],A
    15A1: 52 02    MOV   A,[X+2]
    15A3: 60 D4    MOV   REG[0xD4],A
    15A5: 3E 8C    MVI   A,[__r1]
    15A7: 54 04    MOV   [X+4],A
    15A9: 52 03    MOV   A,[X+3]
    15AB: 53 8C    MOV   [__r1],A
    15AD: 52 02    MOV   A,[X+2]
    15AF: 53 8D    MOV   [__r0],A
    15B1: 51 8C    MOV   A,[__r1]
    15B3: 01 01    ADD   A,0x1
    15B5: 54 03    MOV   [X+3],A
    15B7: 51 8D    MOV   A,[__r0]
    15B9: 09 00    ADC   A,0x0
    15BB: 54 02    MOV   [X+2],A
    15BD: 52 01    MOV   A,[X+1]
    15BF: 53 8A    MOV   [__r3],A
    15C1: 52 00    MOV   A,[X+0]
    15C3: 60 D4    MOV   REG[0xD4],A
    15C5: 3E 8A    MVI   A,[__r3]
    15C7: 53 8B    MOV   [__r2],A
    15C9: 51 8D    MOV   A,[__r0]
    15CB: 60 D5    MOV   REG[0xD5],A
    15CD: 51 8B    MOV   A,[__r2]
    15CF: 3F 8C    MVI   [__r1],A
    15D1: 52 01    MOV   A,[X+1]
    15D3: 53 8C    MOV   [__r1],A
    15D5: 52 00    MOV   A,[X+0]
    15D7: 53 8D    MOV   [__r0],A
    15D9: 51 8C    MOV   A,[__r1]
    15DB: 01 FF    ADD   A,0xFF
    15DD: 54 01    MOV   [X+1],A
    15DF: 51 8D    MOV   A,[__r0]
    15E1: 09 FF    ADC   A,0xFF
    15E3: 54 00    MOV   [X+0],A
    15E5: 51 8D    MOV   A,[__r0]
    15E7: 60 D5    MOV   REG[0xD5],A
    15E9: 52 04    MOV   A,[X+4]
    15EB: 3F 8C    MVI   [__r1],A
    15ED: 52 03    MOV   A,[X+3]
    15EF: 13 01    SUB   A,[X+1]
    15F1: 52 02    MOV   A,[X+2]
    15F3: 1B 00    SBB   A,[X+0]
    15F5: CF A4    JC    0x159A
    15F7: 62 D0 00 MOV   REG[0xD0],0x0
    15FA: 52 FC    MOV   A,[X-4]
    15FC: 53 8C    MOV   [__r1],A
    15FE: 52 FB    MOV   A,[X-5]
    1600: 53 8D    MOV   [__r0],A
    1602: 38 F9    ADD   SP,0xF9
    1604: 20       POP   X
    1605: 7F       RET   
_isdigit:
    1606: 10       PUSH  X
    1607: 4F       MOV   X,SP
    1608: 62 D0 00 MOV   REG[0xD0],0x0
    160B: 52 FC    MOV   A,[X-4]
    160D: 01 D5    ADD   A,0xD5
    160F: 53 8C    MOV   [__r1],A
    1611: 52 FB    MOV   A,[X-5]
    1613: 09 02    ADC   A,0x2
    1615: 10       PUSH  X
    1616: 58 8C    MOV   X,[__r1]
    1618: 28       ROMX  
    1619: 20       POP   X
    161A: 53 8C    MOV   [__r1],A
    161C: 55 8D 00 MOV   [__r0],0x0
    161F: 26 8C 04 AND   [__r1],0x4
    1622: 26 8D 00 AND   [__r0],0x0
    1625: 20       POP   X
    1626: 7F       RET   
_islower:
    1627: 10       PUSH  X
    1628: 4F       MOV   X,SP
    1629: 62 D0 00 MOV   REG[0xD0],0x0
    162C: 52 FC    MOV   A,[X-4]
    162E: 01 D5    ADD   A,0xD5
    1630: 53 8C    MOV   [__r1],A
    1632: 52 FB    MOV   A,[X-5]
    1634: 09 02    ADC   A,0x2
    1636: 10       PUSH  X
    1637: 58 8C    MOV   X,[__r1]
    1639: 28       ROMX  
    163A: 20       POP   X
    163B: 53 8C    MOV   [__r1],A
    163D: 55 8D 00 MOV   [__r0],0x0
    1640: 26 8C 02 AND   [__r1],0x2
    1643: 26 8D 00 AND   [__r0],0x0
    1646: 20       POP   X
    1647: 7F       RET   
_isspace:
    1648: 10       PUSH  X
    1649: 4F       MOV   X,SP
    164A: 62 D0 00 MOV   REG[0xD0],0x0
    164D: 52 FC    MOV   A,[X-4]
    164F: 01 D5    ADD   A,0xD5
    1651: 53 8C    MOV   [__r1],A
    1653: 52 FB    MOV   A,[X-5]
    1655: 09 02    ADC   A,0x2
    1657: 10       PUSH  X
    1658: 58 8C    MOV   X,[__r1]
    165A: 28       ROMX  
    165B: 20       POP   X
    165C: 53 8C    MOV   [__r1],A
    165E: 55 8D 00 MOV   [__r0],0x0
    1661: 26 8C 10 AND   [__r1],0x10
    1664: 26 8D 00 AND   [__r0],0x0
    1667: 20       POP   X
    1668: 7F       RET   
_toupper:
    1669: 10       PUSH  X
    166A: 4F       MOV   X,SP
    166B: 52 FB    MOV   A,[X-5]
    166D: 08       PUSH  A
    166E: 52 FC    MOV   A,[X-4]
    1670: 08       PUSH  A
    1671: 7C 16 27 LCALL _islower
    1674: 38 FE    ADD   SP,0xFE
    1676: 62 D0 00 MOV   REG[0xD0],0x0
    1679: 3C 8D 00 CMP   [__r0],0x0
    167C: B0 06    JNZ   0x1683
    167E: 3C 8C 00 CMP   [__r1],0x0
    1681: A0 18    JZ    0x169A
    1683: 62 D0 00 MOV   REG[0xD0],0x0
    1686: 52 FC    MOV   A,[X-4]
    1688: 11 61    SUB   A,0x61
    168A: 53 8C    MOV   [__r1],A
    168C: 52 FB    MOV   A,[X-5]
    168E: 19 00    SBB   A,0x0
    1690: 53 8D    MOV   [__r0],A
    1692: 06 8C 41 ADD   [__r1],0x41
    1695: 0E 8D 00 ADC   [__r0],0x0
    1698: 80 0C    JMP   0x16A5
    169A: 62 D0 00 MOV   REG[0xD0],0x0
    169D: 52 FC    MOV   A,[X-4]
    169F: 53 8C    MOV   [__r1],A
    16A1: 52 FB    MOV   A,[X-5]
    16A3: 53 8D    MOV   [__r0],A
    16A5: 20       POP   X
    16A6: 7F       RET   
__csdepi:
    16A7: 10       PUSH  X
    16A8: 4F       MOV   X,SP
    16A9: 62 D0 00 MOV   REG[0xD0],0x0
    16AC: 51 C2    MOV   A,[vdi+3]
    16AE: 08       PUSH  A
    16AF: 51 C1    MOV   A,[vdi+2]
    16B1: 62 D0 00 MOV   REG[0xD0],0x0
    16B4: 53 8D    MOV   [__r0],A
    16B6: 18       POP   A
    16B7: 53 8C    MOV   [__r1],A
    16B9: 01 01    ADD   A,0x1
    16BB: 62 D0 00 MOV   REG[0xD0],0x0
    16BE: 53 C2    MOV   [vdi+3],A
    16C0: 62 D0 00 MOV   REG[0xD0],0x0
    16C3: 51 8D    MOV   A,[__r0]
    16C5: 09 00    ADC   A,0x0
    16C7: 62 D0 00 MOV   REG[0xD0],0x0
    16CA: 53 C1    MOV   [vdi+2],A
    16CC: 62 D0 00 MOV   REG[0xD0],0x0
    16CF: 51 8D    MOV   A,[__r0]
    16D1: 60 D5    MOV   REG[0xD5],A
    16D3: 52 FC    MOV   A,[X-4]
    16D5: 3F 8C    MVI   [__r1],A
    16D7: 20       POP   X
    16D8: 7F       RET   
_csprintf:
    16D9: 10       PUSH  X
    16DA: 4F       MOV   X,SP
    16DB: 38 02    ADD   SP,0x2
    16DD: 62 D0 00 MOV   REG[0xD0],0x0
    16E0: 52 FC    MOV   A,[X-4]
    16E2: 53 C2    MOV   [vdi+3],A
    16E4: 52 FB    MOV   A,[X-5]
    16E6: 53 C1    MOV   [vdi+2],A
    16E8: 62 D0 00 MOV   REG[0xD0],0x0
    16EB: 5A 8C    MOV   [__r1],X
    16ED: 16 8C 07 SUB   [__r1],0x7
    16F0: 51 8C    MOV   A,[__r1]
    16F2: 54 01    MOV   [X+1],A
    16F4: 56 00 07 MOV   [X+0],0x7
    16F7: 52 00    MOV   A,[X+0]
    16F9: 08       PUSH  A
    16FA: 52 01    MOV   A,[X+1]
    16FC: 08       PUSH  A
    16FD: 52 F9    MOV   A,[X-7]
    16FF: 08       PUSH  A
    1700: 52 FA    MOV   A,[X-6]
    1702: 08       PUSH  A
    1703: 50 04    MOV   A,0x4
    1705: 08       PUSH  A
    1706: 50 89    MOV   A,0x89
    1708: 08       PUSH  A
    1709: 7C 17 42 LCALL __cprint
    170C: 38 FA    ADD   SP,0xFA
    170E: 62 D0 00 MOV   REG[0xD0],0x0
    1711: 51 C2    MOV   A,[vdi+3]
    1713: 08       PUSH  A
    1714: 51 C1    MOV   A,[vdi+2]
    1716: 62 D0 00 MOV   REG[0xD0],0x0
    1719: 53 8D    MOV   [__r0],A
    171B: 18       POP   A
    171C: 53 8C    MOV   [__r1],A
    171E: 51 8D    MOV   A,[__r0]
    1720: 60 D5    MOV   REG[0xD5],A
    1722: 50 00    MOV   A,0x0
    1724: 3F 8C    MVI   [__r1],A
    1726: 62 D0 00 MOV   REG[0xD0],0x0
    1729: 51 C2    MOV   A,[vdi+3]
    172B: 13 FC    SUB   A,[X-4]
    172D: 62 D0 00 MOV   REG[0xD0],0x0
    1730: 53 8C    MOV   [__r1],A
    1732: 62 D0 00 MOV   REG[0xD0],0x0
    1735: 51 C1    MOV   A,[vdi+2]
    1737: 1B FB    SBB   A,[X-5]
    1739: 62 D0 00 MOV   REG[0xD0],0x0
    173C: 53 8D    MOV   [__r0],A
    173E: 38 FE    ADD   SP,0xFE
    1740: 20       POP   X
    1741: 7F       RET   
__cprint:
    1742: 10       PUSH  X
    1743: 4F       MOV   X,SP
    1744: 38 11    ADD   SP,0x11
    1746: 56 05 00 MOV   [X+5],0x0
    1749: 56 04 00 MOV   [X+4],0x0
    174C: 83 C7    JMP   0x1B14
    174E: 62 D0 00 MOV   REG[0xD0],0x0
    1751: 52 FA    MOV   A,[X-6]
    1753: 53 8C    MOV   [__r1],A
    1755: 52 F9    MOV   A,[X-7]
    1757: 10       PUSH  X
    1758: 58 8C    MOV   X,[__r1]
    175A: 28       ROMX  
    175B: 20       POP   X
    175C: 39 25    CMP   A,0x25
    175E: A0 23    JZ    0x1782
    1760: 52 FA    MOV   A,[X-6]
    1762: 53 8C    MOV   [__r1],A
    1764: 52 F9    MOV   A,[X-7]
    1766: 10       PUSH  X
    1767: 58 8C    MOV   X,[__r1]
    1769: 28       ROMX  
    176A: 20       POP   X
    176B: 10       PUSH  X
    176C: 08       PUSH  A
    176D: 52 FC    MOV   A,[X-4]
    176F: 53 8C    MOV   [__r1],A
    1771: 52 FB    MOV   A,[X-5]
    1773: 58 8C    MOV   X,[__r1]
    1775: 7C 12 DE LCALL __plcall
    1778: 38 FF    ADD   SP,0xFF
    177A: 20       POP   X
    177B: 77 05    INC   [X+5]
    177D: 0F 04 00 ADC   [X+4],0x0
    1780: 83 8E    JMP   0x1B0F
    1782: 56 0A 00 MOV   [X+10],0x0
    1785: 56 09 00 MOV   [X+9],0x0
    1788: 56 07 30 MOV   [X+7],0x30
    178B: 56 06 00 MOV   [X+6],0x0
    178E: 56 08 20 MOV   [X+8],0x20
    1791: 77 FA    INC   [X-6]
    1793: 0F F9 00 ADC   [X-7],0x0
    1796: 62 D0 00 MOV   REG[0xD0],0x0
    1799: 52 FA    MOV   A,[X-6]
    179B: 53 8C    MOV   [__r1],A
    179D: 52 F9    MOV   A,[X-7]
    179F: 10       PUSH  X
    17A0: 58 8C    MOV   X,[__r1]
    17A2: 28       ROMX  
    17A3: 20       POP   X
    17A4: 54 10    MOV   [X+16],A
    17A6: 56 0F 00 MOV   [X+15],0x0
    17A9: 52 10    MOV   A,[X+16]
    17AB: 11 58    SUB   A,0x58
    17AD: 53 86    MOV   [__rY],A
    17AF: 52 0F    MOV   A,[X+15]
    17B1: 31 80    XOR   A,0x80
    17B3: 19 80    SBB   A,0x80
    17B5: 2A 86    OR    A,[__rY]
    17B7: A0 ED    JZ    0x18A5
    17B9: D0 22    JNC   0x17DC
    17BB: 52 10    MOV   A,[X+16]
    17BD: 11 45    SUB   A,0x45
    17BF: 62 D0 00 MOV   REG[0xD0],0x0
    17C2: 53 86    MOV   [__rY],A
    17C4: 52 0F    MOV   A,[X+15]
    17C6: 31 80    XOR   A,0x80
    17C8: 19 80    SBB   A,0x80
    17CA: C0 83    JC    0x184E
    17CC: 2A 86    OR    A,[__rY]
    17CE: A3 38    JZ    0x1B07
    17D0: 3D 0F 00 CMP   [X+15],0x0
    17D3: B0 06    JNZ   0x17DA
    17D5: 3D 10 53 CMP   [X+16],0x53
    17D8: A2 32    JZ    0x1A0B
    17DA: 80 73    JMP   0x184E
    17DC: 3D 0F 00 CMP   [X+15],0x0
    17DF: B0 06    JNZ   0x17E6
    17E1: 3D 10 63 CMP   [X+16],0x63
    17E4: A1 F6    JZ    0x19DB
    17E6: 3D 0F 00 CMP   [X+15],0x0
    17E9: B0 06    JNZ   0x17F0
    17EB: 3D 10 64 CMP   [X+16],0x64
    17EE: A0 84    JZ    0x1873
    17F0: 3D 0F 00 CMP   [X+15],0x0
    17F3: B0 06    JNZ   0x17FA
    17F5: 3D 10 65 CMP   [X+16],0x65
    17F8: A3 0E    JZ    0x1B07
    17FA: 3D 0F 00 CMP   [X+15],0x0
    17FD: B0 06    JNZ   0x1804
    17FF: 3D 10 66 CMP   [X+16],0x66
    1802: A3 04    JZ    0x1B07
    1804: 3D 0F 00 CMP   [X+15],0x0
    1807: B0 06    JNZ   0x180E
    1809: 3D 10 69 CMP   [X+16],0x69
    180C: A0 66    JZ    0x1873
    180E: 3D 0F 00 CMP   [X+15],0x0
    1811: B0 06    JNZ   0x1818
    1813: 3D 10 6F CMP   [X+16],0x6F
    1816: A0 8E    JZ    0x18A5
    1818: 3D 0F 00 CMP   [X+15],0x0
    181B: B0 06    JNZ   0x1822
    181D: 3D 10 70 CMP   [X+16],0x70
    1820: A0 84    JZ    0x18A5
    1822: 52 10    MOV   A,[X+16]
    1824: 11 63    SUB   A,0x63
    1826: 52 0F    MOV   A,[X+15]
    1828: 31 80    XOR   A,0x80
    182A: 19 80    SBB   A,0x80
    182C: C0 21    JC    0x184E
    182E: 3D 0F 00 CMP   [X+15],0x0
    1831: B0 06    JNZ   0x1838
    1833: 3D 10 73 CMP   [X+16],0x73
    1836: A2 4A    JZ    0x1A81
    1838: 3D 0F 00 CMP   [X+15],0x0
    183B: B0 06    JNZ   0x1842
    183D: 3D 10 75 CMP   [X+16],0x75
    1840: A0 64    JZ    0x18A5
    1842: 3D 0F 00 CMP   [X+15],0x0
    1845: B0 06    JNZ   0x184C
    1847: 3D 10 78 CMP   [X+16],0x78
    184A: A0 5A    JZ    0x18A5
    184C: 80 01    JMP   0x184E
    184E: 62 D0 00 MOV   REG[0xD0],0x0
    1851: 52 FA    MOV   A,[X-6]
    1853: 53 8C    MOV   [__r1],A
    1855: 52 F9    MOV   A,[X-7]
    1857: 10       PUSH  X
    1858: 58 8C    MOV   X,[__r1]
    185A: 28       ROMX  
    185B: 20       POP   X
    185C: 10       PUSH  X
    185D: 08       PUSH  A
    185E: 52 FC    MOV   A,[X-4]
    1860: 53 8C    MOV   [__r1],A
    1862: 52 FB    MOV   A,[X-5]
    1864: 58 8C    MOV   X,[__r1]
    1866: 7C 12 DE LCALL __plcall
    1869: 38 FF    ADD   SP,0xFF
    186B: 20       POP   X
    186C: 77 05    INC   [X+5]
    186E: 0F 04 00 ADC   [X+4],0x0
    1871: 82 9D    JMP   0x1B0F
    1873: 07 F8 FE ADD   [X-8],0xFE
    1876: 0F F7 FF ADC   [X-9],0xFF
    1879: 62 D0 00 MOV   REG[0xD0],0x0
    187C: 52 F8    MOV   A,[X-8]
    187E: 53 8C    MOV   [__r1],A
    1880: 52 F7    MOV   A,[X-9]
    1882: 60 D4    MOV   REG[0xD4],A
    1884: 3E 8C    MVI   A,[__r1]
    1886: 54 0B    MOV   [X+11],A
    1888: 3E 8C    MVI   A,[__r1]
    188A: 54 0C    MOV   [X+12],A
    188C: 50 00    MOV   A,0x0
    188E: 08       PUSH  A
    188F: 50 0A    MOV   A,0xA
    1891: 08       PUSH  A
    1892: 52 0B    MOV   A,[X+11]
    1894: 08       PUSH  A
    1895: 52 0C    MOV   A,[X+12]
    1897: 08       PUSH  A
    1898: 52 06    MOV   A,[X+6]
    189A: 08       PUSH  A
    189B: 52 07    MOV   A,[X+7]
    189D: 08       PUSH  A
    189E: 7C 12 EA LCALL _itoa
    18A1: 38 FA    ADD   SP,0xFA
    18A3: 81 2F    JMP   0x19D3
    18A5: 07 F8 FE ADD   [X-8],0xFE
    18A8: 0F F7 FF ADC   [X-9],0xFF
    18AB: 62 D0 00 MOV   REG[0xD0],0x0
    18AE: 52 F8    MOV   A,[X-8]
    18B0: 53 8C    MOV   [__r1],A
    18B2: 52 F7    MOV   A,[X-9]
    18B4: 60 D4    MOV   REG[0xD4],A
    18B6: 3E 8C    MVI   A,[__r1]
    18B8: 53 8D    MOV   [__r0],A
    18BA: 3E 8C    MVI   A,[__r1]
    18BC: 54 0C    MOV   [X+12],A
    18BE: 51 8D    MOV   A,[__r0]
    18C0: 54 0B    MOV   [X+11],A
    18C2: 52 FA    MOV   A,[X-6]
    18C4: 53 8C    MOV   [__r1],A
    18C6: 52 F9    MOV   A,[X-7]
    18C8: 10       PUSH  X
    18C9: 58 8C    MOV   X,[__r1]
    18CB: 28       ROMX  
    18CC: 20       POP   X
    18CD: 39 75    CMP   A,0x75
    18CF: B0 1A    JNZ   0x18EA
    18D1: 50 00    MOV   A,0x0
    18D3: 08       PUSH  A
    18D4: 50 0A    MOV   A,0xA
    18D6: 08       PUSH  A
    18D7: 52 0B    MOV   A,[X+11]
    18D9: 08       PUSH  A
    18DA: 52 0C    MOV   A,[X+12]
    18DC: 08       PUSH  A
    18DD: 52 06    MOV   A,[X+6]
    18DF: 08       PUSH  A
    18E0: 52 07    MOV   A,[X+7]
    18E2: 08       PUSH  A
    18E3: 7C 14 C3 LCALL _utoa
    18E6: 38 FA    ADD   SP,0xFA
    18E8: 80 EA    JMP   0x19D3
    18EA: 62 D0 00 MOV   REG[0xD0],0x0
    18ED: 52 FA    MOV   A,[X-6]
    18EF: 53 8C    MOV   [__r1],A
    18F1: 52 F9    MOV   A,[X-7]
    18F3: 10       PUSH  X
    18F4: 58 8C    MOV   X,[__r1]
    18F6: 28       ROMX  
    18F7: 20       POP   X
    18F8: 39 6F    CMP   A,0x6F
    18FA: B0 1A    JNZ   0x1915
    18FC: 50 00    MOV   A,0x0
    18FE: 08       PUSH  A
    18FF: 50 08    MOV   A,0x8
    1901: 08       PUSH  A
    1902: 52 0B    MOV   A,[X+11]
    1904: 08       PUSH  A
    1905: 52 0C    MOV   A,[X+12]
    1907: 08       PUSH  A
    1908: 52 06    MOV   A,[X+6]
    190A: 08       PUSH  A
    190B: 52 07    MOV   A,[X+7]
    190D: 08       PUSH  A
    190E: 7C 14 C3 LCALL _utoa
    1911: 38 FA    ADD   SP,0xFA
    1913: 80 BF    JMP   0x19D3
    1915: 62 D0 00 MOV   REG[0xD0],0x0
    1918: 52 FA    MOV   A,[X-6]
    191A: 53 8C    MOV   [__r1],A
    191C: 52 F9    MOV   A,[X-7]
    191E: 10       PUSH  X
    191F: 58 8C    MOV   X,[__r1]
    1921: 28       ROMX  
    1922: 20       POP   X
    1923: 39 70    CMP   A,0x70
    1925: B0 39    JNZ   0x195F
    1927: 52 07    MOV   A,[X+7]
    1929: 53 8C    MOV   [__r1],A
    192B: 52 06    MOV   A,[X+6]
    192D: 53 8D    MOV   [__r0],A
    192F: 51 8C    MOV   A,[__r1]
    1931: 01 01    ADD   A,0x1
    1933: 54 07    MOV   [X+7],A
    1935: 51 8D    MOV   A,[__r0]
    1937: 09 00    ADC   A,0x0
    1939: 54 06    MOV   [X+6],A
    193B: 51 8D    MOV   A,[__r0]
    193D: 60 D5    MOV   REG[0xD5],A
    193F: 50 30    MOV   A,0x30
    1941: 3F 8C    MVI   [__r1],A
    1943: 52 07    MOV   A,[X+7]
    1945: 53 8C    MOV   [__r1],A
    1947: 52 06    MOV   A,[X+6]
    1949: 53 8D    MOV   [__r0],A
    194B: 51 8C    MOV   A,[__r1]
    194D: 01 01    ADD   A,0x1
    194F: 54 07    MOV   [X+7],A
    1951: 51 8D    MOV   A,[__r0]
    1953: 09 00    ADC   A,0x0
    1955: 54 06    MOV   [X+6],A
    1957: 51 8D    MOV   A,[__r0]
    1959: 60 D5    MOV   REG[0xD5],A
    195B: 50 78    MOV   A,0x78
    195D: 3F 8C    MVI   [__r1],A
    195F: 50 00    MOV   A,0x0
    1961: 08       PUSH  A
    1962: 50 10    MOV   A,0x10
    1964: 08       PUSH  A
    1965: 52 0B    MOV   A,[X+11]
    1967: 08       PUSH  A
    1968: 52 0C    MOV   A,[X+12]
    196A: 08       PUSH  A
    196B: 52 06    MOV   A,[X+6]
    196D: 08       PUSH  A
    196E: 52 07    MOV   A,[X+7]
    1970: 08       PUSH  A
    1971: 7C 14 C3 LCALL _utoa
    1974: 38 FA    ADD   SP,0xFA
    1976: 62 D0 00 MOV   REG[0xD0],0x0
    1979: 52 FA    MOV   A,[X-6]
    197B: 53 8C    MOV   [__r1],A
    197D: 52 F9    MOV   A,[X-7]
    197F: 10       PUSH  X
    1980: 58 8C    MOV   X,[__r1]
    1982: 28       ROMX  
    1983: 20       POP   X
    1984: 39 58    CMP   A,0x58
    1986: B0 4C    JNZ   0x19D3
    1988: 56 01 30 MOV   [X+1],0x30
    198B: 56 00 00 MOV   [X+0],0x0
    198E: 80 33    JMP   0x19C2
    1990: 62 D0 00 MOV   REG[0xD0],0x0
    1993: 52 01    MOV   A,[X+1]
    1995: 53 8C    MOV   [__r1],A
    1997: 52 00    MOV   A,[X+0]
    1999: 60 D4    MOV   REG[0xD4],A
    199B: 3E 8C    MVI   A,[__r1]
    199D: 53 8C    MOV   [__r1],A
    199F: 50 00    MOV   A,0x0
    19A1: 08       PUSH  A
    19A2: 51 8C    MOV   A,[__r1]
    19A4: 08       PUSH  A
    19A5: 7C 16 69 LCALL _toupper
    19A8: 38 FE    ADD   SP,0xFE
    19AA: 62 D0 00 MOV   REG[0xD0],0x0
    19AD: 51 8C    MOV   A,[__r1]
    19AF: 53 8D    MOV   [__r0],A
    19B1: 52 01    MOV   A,[X+1]
    19B3: 53 8A    MOV   [__r3],A
    19B5: 52 00    MOV   A,[X+0]
    19B7: 60 D5    MOV   REG[0xD5],A
    19B9: 51 8D    MOV   A,[__r0]
    19BB: 3F 8A    MVI   [__r3],A
    19BD: 77 01    INC   [X+1]
    19BF: 0F 00 00 ADC   [X+0],0x0
    19C2: 62 D0 00 MOV   REG[0xD0],0x0
    19C5: 52 01    MOV   A,[X+1]
    19C7: 53 8C    MOV   [__r1],A
    19C9: 52 00    MOV   A,[X+0]
    19CB: 60 D4    MOV   REG[0xD4],A
    19CD: 3E 8C    MVI   A,[__r1]
    19CF: 39 00    CMP   A,0x0
    19D1: BF BE    JNZ   0x1990
    19D3: 56 01 30 MOV   [X+1],0x30
    19D6: 56 00 00 MOV   [X+0],0x0
    19D9: 80 D2    JMP   0x1AAC
    19DB: 07 F8 FE ADD   [X-8],0xFE
    19DE: 0F F7 FF ADC   [X-9],0xFF
    19E1: 62 D0 00 MOV   REG[0xD0],0x0
    19E4: 52 F8    MOV   A,[X-8]
    19E6: 53 8C    MOV   [__r1],A
    19E8: 52 F7    MOV   A,[X-9]
    19EA: 60 D4    MOV   REG[0xD4],A
    19EC: 3E 8C    MVI   A,[__r1]
    19EE: 3E 8C    MVI   A,[__r1]
    19F0: 54 0D    MOV   [X+13],A
    19F2: 10       PUSH  X
    19F3: 52 0D    MOV   A,[X+13]
    19F5: 08       PUSH  A
    19F6: 52 FC    MOV   A,[X-4]
    19F8: 53 8C    MOV   [__r1],A
    19FA: 52 FB    MOV   A,[X-5]
    19FC: 58 8C    MOV   X,[__r1]
    19FE: 7C 12 DE LCALL __plcall
    1A01: 38 FF    ADD   SP,0xFF
    1A03: 20       POP   X
    1A04: 77 05    INC   [X+5]
    1A06: 0F 04 00 ADC   [X+4],0x0
    1A09: 81 05    JMP   0x1B0F
    1A0B: 07 F8 FE ADD   [X-8],0xFE
    1A0E: 0F F7 FF ADC   [X-9],0xFF
    1A11: 62 D0 00 MOV   REG[0xD0],0x0
    1A14: 52 F8    MOV   A,[X-8]
    1A16: 53 8C    MOV   [__r1],A
    1A18: 52 F7    MOV   A,[X-9]
    1A1A: 60 D4    MOV   REG[0xD4],A
    1A1C: 3E 8C    MVI   A,[__r1]
    1A1E: 54 02    MOV   [X+2],A
    1A20: 3E 8C    MVI   A,[__r1]
    1A22: 54 03    MOV   [X+3],A
    1A24: 3D 08 2D CMP   [X+8],0x2D
    1A27: B0 45    JNZ   0x1A6D
    1A29: 10       PUSH  X
    1A2A: 50 2D    MOV   A,0x2D
    1A2C: 08       PUSH  A
    1A2D: 62 D0 00 MOV   REG[0xD0],0x0
    1A30: 52 FC    MOV   A,[X-4]
    1A32: 53 8C    MOV   [__r1],A
    1A34: 52 FB    MOV   A,[X-5]
    1A36: 58 8C    MOV   X,[__r1]
    1A38: 7C 12 DE LCALL __plcall
    1A3B: 38 FF    ADD   SP,0xFF
    1A3D: 20       POP   X
    1A3E: 77 05    INC   [X+5]
    1A40: 0F 04 00 ADC   [X+4],0x0
    1A43: 80 29    JMP   0x1A6D
    1A45: 62 D0 00 MOV   REG[0xD0],0x0
    1A48: 52 03    MOV   A,[X+3]
    1A4A: 53 8C    MOV   [__r1],A
    1A4C: 52 02    MOV   A,[X+2]
    1A4E: 10       PUSH  X
    1A4F: 58 8C    MOV   X,[__r1]
    1A51: 28       ROMX  
    1A52: 20       POP   X
    1A53: 10       PUSH  X
    1A54: 08       PUSH  A
    1A55: 52 FC    MOV   A,[X-4]
    1A57: 53 8C    MOV   [__r1],A
    1A59: 52 FB    MOV   A,[X-5]
    1A5B: 58 8C    MOV   X,[__r1]
    1A5D: 7C 12 DE LCALL __plcall
    1A60: 38 FF    ADD   SP,0xFF
    1A62: 20       POP   X
    1A63: 77 05    INC   [X+5]
    1A65: 0F 04 00 ADC   [X+4],0x0
    1A68: 77 03    INC   [X+3]
    1A6A: 0F 02 00 ADC   [X+2],0x0
    1A6D: 62 D0 00 MOV   REG[0xD0],0x0
    1A70: 52 03    MOV   A,[X+3]
    1A72: 53 8C    MOV   [__r1],A
    1A74: 52 02    MOV   A,[X+2]
    1A76: 10       PUSH  X
    1A77: 58 8C    MOV   X,[__r1]
    1A79: 28       ROMX  
    1A7A: 20       POP   X
    1A7B: 39 00    CMP   A,0x0
    1A7D: BF C7    JNZ   0x1A45
    1A7F: 80 8F    JMP   0x1B0F
    1A81: 07 F8 FE ADD   [X-8],0xFE
    1A84: 0F F7 FF ADC   [X-9],0xFF
    1A87: 62 D0 00 MOV   REG[0xD0],0x0
    1A8A: 52 F8    MOV   A,[X-8]
    1A8C: 53 8C    MOV   [__r1],A
    1A8E: 52 F7    MOV   A,[X-9]
    1A90: 60 D4    MOV   REG[0xD4],A
    1A92: 3E 8C    MVI   A,[__r1]
    1A94: 54 00    MOV   [X+0],A
    1A96: 3E 8C    MVI   A,[__r1]
    1A98: 54 01    MOV   [X+1],A
    1A9A: 3D 00 00 CMP   [X+0],0x0
    1A9D: B0 0E    JNZ   0x1AAC
    1A9F: 3D 01 00 CMP   [X+1],0x0
    1AA2: B0 09    JNZ   0x1AAC
    1AA4: 56 03 D5 MOV   [X+3],0xD5
    1AA7: 56 02 03 MOV   [X+2],0x3
    1AAA: 8F 79    JMP   0x1A24
    1AAC: 3D 08 2D CMP   [X+8],0x2D
    1AAF: B0 44    JNZ   0x1AF4
    1AB1: 10       PUSH  X
    1AB2: 50 2D    MOV   A,0x2D
    1AB4: 08       PUSH  A
    1AB5: 62 D0 00 MOV   REG[0xD0],0x0
    1AB8: 52 FC    MOV   A,[X-4]
    1ABA: 53 8C    MOV   [__r1],A
    1ABC: 52 FB    MOV   A,[X-5]
    1ABE: 58 8C    MOV   X,[__r1]
    1AC0: 7C 12 DE LCALL __plcall
    1AC3: 38 FF    ADD   SP,0xFF
    1AC5: 20       POP   X
    1AC6: 77 05    INC   [X+5]
    1AC8: 0F 04 00 ADC   [X+4],0x0
    1ACB: 80 28    JMP   0x1AF4
    1ACD: 62 D0 00 MOV   REG[0xD0],0x0
    1AD0: 52 01    MOV   A,[X+1]
    1AD2: 53 8C    MOV   [__r1],A
    1AD4: 52 00    MOV   A,[X+0]
    1AD6: 60 D4    MOV   REG[0xD4],A
    1AD8: 3E 8C    MVI   A,[__r1]
    1ADA: 10       PUSH  X
    1ADB: 08       PUSH  A
    1ADC: 52 FC    MOV   A,[X-4]
    1ADE: 53 8C    MOV   [__r1],A
    1AE0: 52 FB    MOV   A,[X-5]
    1AE2: 58 8C    MOV   X,[__r1]
    1AE4: 7C 12 DE LCALL __plcall
    1AE7: 38 FF    ADD   SP,0xFF
    1AE9: 20       POP   X
    1AEA: 77 05    INC   [X+5]
    1AEC: 0F 04 00 ADC   [X+4],0x0
    1AEF: 77 01    INC   [X+1]
    1AF1: 0F 00 00 ADC   [X+0],0x0
    1AF4: 62 D0 00 MOV   REG[0xD0],0x0
    1AF7: 52 01    MOV   A,[X+1]
    1AF9: 53 8C    MOV   [__r1],A
    1AFB: 52 00    MOV   A,[X+0]
    1AFD: 60 D4    MOV   REG[0xD4],A
    1AFF: 3E 8C    MVI   A,[__r1]
    1B01: 39 00    CMP   A,0x0
    1B03: BF C9    JNZ   0x1ACD
    1B05: 80 09    JMP   0x1B0F
    1B07: 56 03 E7 MOV   [X+3],0xE7
    1B0A: 56 02 03 MOV   [X+2],0x3
    1B0D: 8F 16    JMP   0x1A24
    1B0F: 77 FA    INC   [X-6]
    1B11: 0F F9 00 ADC   [X-7],0x0
    1B14: 62 D0 00 MOV   REG[0xD0],0x0
    1B17: 52 FA    MOV   A,[X-6]
    1B19: 53 8C    MOV   [__r1],A
    1B1B: 52 F9    MOV   A,[X-7]
    1B1D: 10       PUSH  X
    1B1E: 58 8C    MOV   X,[__r1]
    1B20: 28       ROMX  
    1B21: 20       POP   X
    1B22: 39 00    CMP   A,0x0
    1B24: BC 29    JNZ   0x174E
    1B26: 52 05    MOV   A,[X+5]
    1B28: 53 8C    MOV   [__r1],A
    1B2A: 52 04    MOV   A,[X+4]
    1B2C: 53 8D    MOV   [__r0],A
    1B2E: 38 EF    ADD   SP,0xEF
    1B30: 20       POP   X
    1B31: 7F       RET   
    1B32: 10       PUSH  X
    1B33: 4F       MOV   X,SP
    1B34: 38 04    ADD   SP,0x4
    1B36: 80 06    JMP   0x1B3D
    1B38: 77 FC    INC   [X-4]
    1B3A: 0F FB 00 ADC   [X-5],0x0
    1B3D: 62 D0 00 MOV   REG[0xD0],0x0
    1B40: 52 FC    MOV   A,[X-4]
    1B42: 53 8C    MOV   [__r1],A
    1B44: 52 FB    MOV   A,[X-5]
    1B46: 10       PUSH  X
    1B47: 58 8C    MOV   X,[__r1]
    1B49: 28       ROMX  
    1B4A: 20       POP   X
    1B4B: 53 8C    MOV   [__r1],A
    1B4D: 50 00    MOV   A,0x0
    1B4F: 08       PUSH  A
    1B50: 51 8C    MOV   A,[__r1]
    1B52: 08       PUSH  A
    1B53: 7C 16 48 LCALL _isspace
    1B56: 38 FE    ADD   SP,0xFE
    1B58: 62 D0 00 MOV   REG[0xD0],0x0
    1B5B: 3C 8D 00 CMP   [__r0],0x0
    1B5E: BF D9    JNZ   0x1B38
    1B60: 3C 8C 00 CMP   [__r1],0x0
    1B63: BF D4    JNZ   0x1B38
    1B65: 56 03 00 MOV   [X+3],0x0
    1B68: 56 02 00 MOV   [X+2],0x0
    1B6B: 62 D0 00 MOV   REG[0xD0],0x0
    1B6E: 52 FC    MOV   A,[X-4]
    1B70: 53 8C    MOV   [__r1],A
    1B72: 52 FB    MOV   A,[X-5]
    1B74: 10       PUSH  X
    1B75: 58 8C    MOV   X,[__r1]
    1B77: 28       ROMX  
    1B78: 20       POP   X
    1B79: 39 2D    CMP   A,0x2D
    1B7B: B0 0E    JNZ   0x1B8A
    1B7D: 56 03 01 MOV   [X+3],0x1
    1B80: 56 02 00 MOV   [X+2],0x0
    1B83: 77 FC    INC   [X-4]
    1B85: 0F FB 00 ADC   [X-5],0x0
    1B88: 80 18    JMP   0x1BA1
    1B8A: 62 D0 00 MOV   REG[0xD0],0x0
    1B8D: 52 FC    MOV   A,[X-4]
    1B8F: 53 8C    MOV   [__r1],A
    1B91: 52 FB    MOV   A,[X-5]
    1B93: 10       PUSH  X
    1B94: 58 8C    MOV   X,[__r1]
    1B96: 28       ROMX  
    1B97: 20       POP   X
    1B98: 39 2B    CMP   A,0x2B
    1B9A: B0 06    JNZ   0x1BA1
    1B9C: 77 FC    INC   [X-4]
    1B9E: 0F FB 00 ADC   [X-5],0x0
    1BA1: 56 01 00 MOV   [X+1],0x0
    1BA4: 56 00 00 MOV   [X+0],0x0
    1BA7: 80 7C    JMP   0x1C24
    1BA9: 62 D0 00 MOV   REG[0xD0],0x0
    1BAC: 52 FC    MOV   A,[X-4]
    1BAE: 53 8C    MOV   [__r1],A
    1BB0: 52 FB    MOV   A,[X-5]
    1BB2: 53 8D    MOV   [__r0],A
    1BB4: 51 8C    MOV   A,[__r1]
    1BB6: 01 01    ADD   A,0x1
    1BB8: 54 FC    MOV   [X-4],A
    1BBA: 51 8D    MOV   A,[__r0]
    1BBC: 09 00    ADC   A,0x0
    1BBE: 54 FB    MOV   [X-5],A
    1BC0: 52 01    MOV   A,[X+1]
    1BC2: 53 8A    MOV   [__r3],A
    1BC4: 52 00    MOV   A,[X+0]
    1BC6: 53 8B    MOV   [__r2],A
    1BC8: 55 88 0A MOV   [__r5],0xA
    1BCB: 55 89 00 MOV   [__r4],0x0
    1BCE: 55 87 00 MOV   [__rX],0x0
    1BD1: 55 86 00 MOV   [__rY],0x0
    1BD4: 3C 89 00 CMP   [__r4],0x0
    1BD7: B0 06    JNZ   0x1BDE
    1BD9: 3C 88 00 CMP   [__r5],0x0
    1BDC: A0 1A    JZ    0x1BF7
    1BDE: 70 FB    AND   F,0xFB
    1BE0: 6E 89    RRC   [__r4]
    1BE2: 6E 88    RRC   [__r5]
    1BE4: D0 0C    JNC   0x1BF1
    1BE6: 62 D0 00 MOV   REG[0xD0],0x0
    1BE9: 51 8A    MOV   A,[__r3]
    1BEB: 04 87    ADD   [__rX],A
    1BED: 51 8B    MOV   A,[__r2]
    1BEF: 0C 86    ADC   [__rY],A
    1BF1: 65 8A    ASL   [__r3]
    1BF3: 6B 8B    RLC   [__r2]
    1BF5: 8F DE    JMP   0x1BD4
    1BF7: 5F 8A 87 MOV   [__r3],[__rX]
    1BFA: 5F 8B 86 MOV   [__r2],[__rY]
    1BFD: 62 D0 00 MOV   REG[0xD0],0x0
    1C00: 51 8D    MOV   A,[__r0]
    1C02: 10       PUSH  X
    1C03: 58 8C    MOV   X,[__r1]
    1C05: 28       ROMX  
    1C06: 20       POP   X
    1C07: 53 8C    MOV   [__r1],A
    1C09: 55 8D 00 MOV   [__r0],0x0
    1C0C: 51 8A    MOV   A,[__r3]
    1C0E: 02 8C    ADD   A,[__r1]
    1C10: 53 8C    MOV   [__r1],A
    1C12: 51 8B    MOV   A,[__r2]
    1C14: 0A 8D    ADC   A,[__r0]
    1C16: 53 8D    MOV   [__r0],A
    1C18: 51 8C    MOV   A,[__r1]
    1C1A: 11 30    SUB   A,0x30
    1C1C: 54 01    MOV   [X+1],A
    1C1E: 51 8D    MOV   A,[__r0]
    1C20: 19 00    SBB   A,0x0
    1C22: 54 00    MOV   [X+0],A
    1C24: 62 D0 00 MOV   REG[0xD0],0x0
    1C27: 52 FC    MOV   A,[X-4]
    1C29: 53 8C    MOV   [__r1],A
    1C2B: 52 FB    MOV   A,[X-5]
    1C2D: 10       PUSH  X
    1C2E: 58 8C    MOV   X,[__r1]
    1C30: 28       ROMX  
    1C31: 20       POP   X
    1C32: 53 8C    MOV   [__r1],A
    1C34: 50 00    MOV   A,0x0
    1C36: 08       PUSH  A
    1C37: 51 8C    MOV   A,[__r1]
    1C39: 08       PUSH  A
    1C3A: 7C 16 06 LCALL _isdigit
    1C3D: 38 FE    ADD   SP,0xFE
    1C3F: 62 D0 00 MOV   REG[0xD0],0x0
    1C42: 3C 8D 00 CMP   [__r0],0x0
    1C45: BF 63    JNZ   0x1BA9
    1C47: 3C 8C 00 CMP   [__r1],0x0
    1C4A: BF 5E    JNZ   0x1BA9
    1C4C: 3D 02 00 CMP   [X+2],0x0
    1C4F: B0 06    JNZ   0x1C56
    1C51: 3D 03 00 CMP   [X+3],0x0
    1C54: A0 14    JZ    0x1C69
    1C56: 62 D0 00 MOV   REG[0xD0],0x0
    1C59: 52 01    MOV   A,[X+1]
    1C5B: 73       CPL   A
    1C5C: 11 FF    SUB   A,0xFF
    1C5E: 53 8C    MOV   [__r1],A
    1C60: 52 00    MOV   A,[X+0]
    1C62: 73       CPL   A
    1C63: 19 FF    SBB   A,0xFF
    1C65: 53 8D    MOV   [__r0],A
    1C67: 80 0C    JMP   0x1C74
    1C69: 62 D0 00 MOV   REG[0xD0],0x0
    1C6C: 52 01    MOV   A,[X+1]
    1C6E: 53 8C    MOV   [__r1],A
    1C70: 52 00    MOV   A,[X+0]
    1C72: 53 8D    MOV   [__r0],A
    1C74: 38 FC    ADD   SP,0xFC
    1C76: 20       POP   X
    1C77: 7F       RET   
